% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/solvers.R
\name{solvers}
\alias{solvers}
\alias{add_default_solver}
\alias{add_gurobi_solver}
\alias{add_rsymphony_solver}
\alias{add_lpsymphony_solver}
\title{Problem solvers}
\usage{
add_default_solver(x, ...)

add_gurobi_solver(x, gap = 0.1, time_limit = .Machine$integer.max,
  presolve = 2, threads = 1, first_feasible = 0)

add_rsymphony_solver(x, gap = 0.1, time_limit = -1, first_feasible = 0,
  verbosity = 1)

add_lpsymphony_solver(x, gap = 0.1, time_limit = -1, verbosity = 1,
  first_feasible = 0)
}
\arguments{
\item{x}{\code{\link{ConservationProblem-class}} object.}

\item{...}{arguments passed to the default solver.}

\item{gap}{\code{numeric} gap to optimality. This gap is relative when
solving problems using \code{gurobi}, and will cause the optimizer to
terminate when the difference between the upper and lower objective
function bounds is less than the gap times the upper bound. For example, a
value of 0.01 will result in the optimizer stopping when the difference
between the bounds is 1 percent of the upper bound. But for other solvers
(eg. \code{Rsymhpony}), this gap is absolute and expresses the acceptable
deviance from the optimal objective. For example, solving a
minimum set objective problem with a gap of 5 will cause the solver
to terminate when the cost of the solution is within 5 cost units
from the optimal solution.}

\item{time_limit}{\code{numeric} time limit in seconds to run the optimizer.
The solver will return the current best solution when this time limit is
exceeded.}

\item{presolve}{\code{integer} number indicating how intensively the
solver should try to simplify the problem before solving it. The default
value of 2 indicates to that the solver should be very aggressive in
trying to simplify the problem.}

\item{threads}{\code{integer} number of threads to use for the
optimization algorithm. The default value of 1 will result in only
one thread being used.}

\item{first_feasible}{\code{logical} should the first feasible solution be
be returned? If \code{first_feasible} is set to \code{TRUE}, the solver
will return the first solution it encounters that meets all the
constraints, regardless of solution quality. Note that the first feasible
solution is not an arbitrary solution, rather it is derived from the
relaxed solution, and is therefore often reasonably close to optimality.}

\item{verbosity}{\code{integer} how verbose should the solver be when
reporting progress on solving the problem?}
}
\description{
Specify the software and configurations used to solve a conservation planning
problem. Below is a list of different solvers that can be added to a
\code{\link{ConservationProblem-class}} object.
}
\details{
\describe{

\item{\code{default_solver}}{This solver uses the best software
   currently installed on the system.}

\item{\code{add_gurobi_solver}}{\href{http://gurobi.com}{Gurobi} is a
    state-of-the-art commercial optimization software with an R package
    interface. It is by far the fastest of the solvers available in this
    package, however, it is also the only solver that is not freely
    available. That said, licenses are available to academics at no cost. The
    \code{gurobi} package is distributed with the Gurobi software suite.
    This solver uses the \code{gurobi} package to solve problems.}

\item{\code{add_rsymphony_solver}}{
    \href{https://projects.coin-or.org/SYMPHONY}{SYMPHONY} is an open-source
    integer programming solver that is part of the Computational
    Infrastructure for Operations Research (COIN-OR) project, an initiative
    to promote development of open-source tools for operations research (a
    field that includes linear programming). The \code{Rsymphony} package
    provides an interface to COIN-OR and is available on CRAN. This solver
    uses the \code{Rsymphony} package to solve problems.}

\item{\code{add_lpsymphony_solver}}{The \code{lpsymphony} package provides a
   different interface to the COIN-OR software suite. Unlike the
   \code{Rsymhpony} package, the \code{lpsymphony} package is distributed
   through
   \href{http://bioconducto/packages/release/bioc/html/lpsymphony.html}{Bioconductor}.
   On Windows and Mac, \code{lpsymphony} may be easier to
   may be easier to install. This solver uses the \code{lpsymphony} package
   to solve.}

}
}
\examples{
\donttest{
# load packages
require(gurobi)
require(lpsymphony)
require(Rsymphony)

# load data
data(sim_pu_raster, sim_features)

# create basic problem
p <- problem(sim_pu_raster, sim_features) \%>\%
  add_min_set_objective() \%>\%
  add_relative_targets(0.1)

# create vector to store plot titles
titles <- c()

# create empty stack to store solutions
s <- stack()

# create problem with added rsymphony solver and limit the time spent
# searching for the optimal solution to 2 seconds
if (requireNamespace("Rsymphony", quietly = TRUE)) {
  titles <- c(titles, "Rsymphony (2s)")
  p1 <- p \%>\% add_rsymphony_solver(time_limit = 2)
  s <- addLayer(s, solve(p1))
}

# create problem with added rsymphony solver and limit the time spent
# searching for the optimal solution to 5 seconds
if (requireNamespace("Rsymphony", quietly = TRUE)) {
  titles <- c(titles, "Rsymphony (5s)")
  p2 <- p \%>\% add_rsymphony_solver(time_limit = 5)
  s <- addLayer(s, solve(p2))
}

# if the gurobi is installed: create problem with added gurobi solver
if (requireNamespace("gurobi", quietly = TRUE)) {
  titles <- c(titles, "gurobi (5s)")
  p3 <- p \%>\% add_gurobi_solver(gap = 0.1, presolve = 2, time_limit = 5)
  s <- addLayer(s, solve(p3))
}

# if the lpsymphony is installed: create problem with added lpsymphony solver
if (requireNamespace("lpsymphony", quietly = TRUE)) {
  titles <- c(titles, "lpsymphony")
  p4 <- p \%>\% add_lpsymphony_solver(gap = 0.1, time_limit = 5)
  s <- addLayer(s, solve(p4))
}

# plot solutions
plot(s, main = titles)
}

}
