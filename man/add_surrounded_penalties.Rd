% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/add_surrounded_penalties.R
\name{add_surrounded_penalties}
\alias{add_surrounded_penalties}
\alias{add_surrounded_penalties,ConservationProblem,ANY,ANY,array-method}
\alias{add_surrounded_penalties,ConservationProblem,ANY,ANY,matrix-method}
\alias{add_surrounded_penalties,ConservationProblem,ANY,ANY,data.frame-method}
\alias{add_surrounded_penalties,ConservationProblem,ANY,ANY,ANY-method}
\title{Add surrounded penalties}
\usage{
\S4method{add_surrounded_penalties}{ConservationProblem,ANY,ANY,data.frame}(x, penalty, zones, data)

\S4method{add_surrounded_penalties}{ConservationProblem,ANY,ANY,matrix}(x, penalty, zones, data)

\S4method{add_surrounded_penalties}{ConservationProblem,ANY,ANY,ANY}(x, penalty, zones, data)
}
\arguments{
\item{x}{\code{\link[=problem]{problem()}} object.}

\item{penalty}{\code{numeric} penalty that is used to scale the importance
of selecting planning units that are spatially clumped together compared
to the main problem objective (e.g., solution cost when the argument to
\code{x} has a minimum set objective per \code{\link[=add_min_set_objective]{add_min_set_objective()}}).
Higher \code{penalty} values prefer solutions with a higher degree of spatial
clumping, and smaller \code{penalty} values prefer solutions with a smaller
degree of clumping. Note that negative \code{penalty} values are not permitted.}

\item{zones}{\code{matrix} or \code{Matrix} object describing the
neighborhood scheme for different zones. Each row and column corresponds
to a different zone in the argument to \code{x}, and cell values must
contain binary \code{numeric} values (i.e., one or zero) that indicate
if neighboring planning units (as specified in the argument to
\code{data}) should be considered neighbors if they are allocated to
different zones. The cell values along the diagonal
of the matrix indicate if planning units that are allocated to the same
zone should be considered neighbors or not. The default argument to
\code{zones} is an identity matrix (i.e., a matrix with ones along the
matrix diagonal and zeros elsewhere), so that planning units are
only considered neighbors if they are both allocated to the same zone.}

\item{data}{\code{NULL}, \code{matrix}, \code{Matrix}, \code{data.frame}, or
\code{array} object showing which planning units are neighbors with each
other. The argument defaults to \code{NULL} which means that the
neighborhood data is calculated automatically using the
\code{\link[=adjacency_matrix]{adjacency_matrix()}} function.
See the Data format section for more information.}
}
\value{
An updated \code{\link[=problem]{problem()}} object with the penalties added to it.
}
\description{
Add penalties to a conservation planning problem to favor solutions
that spatially clump planning units together based on spatial
boundary of selected planning units that are fully surrounded by
other selected planning units.
}
\details{
This function adds penalties to a conservation planning problem
to penalize fragmented solutions.
Note that this function can only
be used to represent symmetric relationships between planning units. If
asymmetric relationships are required, use the
\code{\link[=add_connectivity_penalties]{add_connectivity_penalties()}} function.
Additionally, this function cannot be used to promote the selection
of highly fragmented solutions (unlike \code{\link[=add_boundary_penalties]{add_boundary_penalties()}}).
}
\section{Mathematical formulation}{

The surrounded penalties are implemented using the following equations. Let
\eqn{I} represent the set of planning units
(indexed by \eqn{i} or \eqn{j}), \eqn{Z} represent
the set of management zones (indexed by \eqn{z} or \eqn{y}), and
\eqn{X_{iz}}{Xiz} represent the decision
variable for planning unit \eqn{i} for in zone \eqn{z} (e.g., with binary
values one indicating if planning unit is allocated or not). Also, let
\eqn{p} represent the argument to \code{penalty},
\eqn{A_{ij}}{Aij} indicate if planning units \eqn{i} and \eqn{j} are
neighbors (using values of zero or one) based on the matrix argument
to \code{data} (e.g., generated using \code{\link[=boundary_matrix]{boundary_matrix()}}), and
\eqn{W_{zz}}{Wzz} represent the matrix argument to \code{zones}..
Additionally, let \eqn{T_i} denote the total boundary for planning unit
\eqn{i}, and \eqn{S_{iz}} indicate if planning unit \eqn{i} is selected
and fully surrounded or not by other selected planning units.

\deqn{
\sum_{i}^{I} \sum_{z}^{Z} -p \times S_{iz} \\
((1 + T_{i}) \times S_{iz}) - X_{iz} - \sum_{j}^{I} \sum_{y}^{Z} W_{zy} \\ \times A_{ij} \times X_{jy} \geq 0 \\
T_{i} = \sum_{j}^{I} A_{ij}
}{
sum_i^I sum_z^Z p * Siz
((1 + Ti) * Siz) - Xiz - sum_j^I sum_y^Z Wzy * Aij * Xjy >= 0
Ti = sum_i^I Aij
}

Note that when the problem objective is to maximize some measure of
benefit and not minimize some measure of cost, the term \eqn{-p} is
replaced with \eqn{p}.
}

\section{Data format}{

The argument to \code{data} can be specified using the following formats.
Note that boundary data must always describe symmetric relationships
between planning units.

\describe{

\item{\code{data} as a \code{NULL} value}{indicating that the data should be
automatically calculated using the \code{\link[=boundary_matrix]{boundary_matrix()}} function.
This argument is the default.
Note that the boundary data must be supplied
using one of the other formats below if the planning unit data
in the argument to \code{x} do not explicitly contain spatial information
(e.g., planning unit data are a \code{data.frame} or \code{numeric} class).}

\item{\code{data} as a \code{matrix}/\code{Matrix} object}{where rows and columns represent
different planning units and the value of each cell represents the
amount of shared boundary length between two different planning units.
Cells that occur along the matrix diagonal denote the total
boundary length associated with each planning unit.}

\item{\code{data} as a \code{data.frame} object}{with the columns \code{"id1"},
\code{"id2"}, and \code{"boundary"}. The \code{"id1"} and \code{"id2"} columns contain
identifiers (indices) for a pair of planning units, and the \code{"boundary"}
column contains the amount of shared boundary length between these
two planning units.
Additionally, if the values in the \code{"id1"} and \code{"id2"} columns
contain the same values, then the value denotes the
amount of exposed boundary length (not total boundary).
This format follows the the standard \emph{Marxan} format for boundary
data (i.e., per the "bound.dat" file).}

}
}

\examples{
\dontrun{
# set seed for reproducibility
set.seed(500)

# load data
sim_pu_raster <- get_sim_pu_raster()
sim_features <- get_sim_features()
sim_zones_pu_raster <- get_sim_zones_pu_raster()
sim_zones_features <- get_sim_zones_features()

# define budget as 40\% of total costs
b = terra::global(sim_pu_raster, "sum", na.rm = TRUE)[[1]] * 0.4

# create minimal problem
p1 <-
  problem(sim_pu_raster, sim_features) \%>\%
  add_min_shortfall_objective(budget = b) \%>\%
  add_relative_targets(0.8) \%>\%
  add_binary_decisions() \%>\%
  add_default_solver(verbose = FALSE)

# create problem with low surrounded penalties
p2 <- p1 \%>\% add_surrounded_penalties(0.0001)

# create problem with high surrounded penalties
p3 <- p1 \%>\% add_surrounded_penalties(0.05)

# create a problem using precomputed boundary data
bmat <- boundary_matrix(sim_pu_raster)
p4 <- p1 \%>\% add_surrounded_penalties(0.05, data = bmat)

# solve problems
s1 <- c(solve(p1), solve(p2), solve(p3), solve(p4))
names(s1) <- c("basic solution", "small penalties", "high penalties",
  "precomputed data"
)

# plot solutions
plot(s1, axes = FALSE)


# compute budget for multi-zone example
b2 <- terra::global(sim_zones_pu_raster, "sum", na.rm = TRUE)[[1]] * 0.4
# create minimal problem with multiple zones and limit the run-time for
# solver to 10 seconds so this example doesn't take too long
p5 <-
  problem(sim_zones_pu_raster, sim_zones_features) \%>\%
  add_min_shortfall_objective(budget = b2) \%>\%
  add_relative_targets(matrix(0.8, nrow = 5, ncol = 3)) \%>\%
  add_binary_decisions() \%>\%
  add_default_solver(time_limit = 10, verbose = FALSE)

# create zone matrix which favors clumping planning units that are
# allocated to the same zone together - note that this is the default
zm6 <- diag(3)
print(zm6)

# create problem with the zone matrix and low penalties
p6 <- p5 \%>\% add_surrounded_penalties(0.00001, zone = zm6)

# create another problem with the same zone matrix and higher penalties
p7 <- p5 \%>\% add_surrounded_penalties(0.05, zone = zm6)

# solve problems
s2 <- list(solve(p5), solve(p6), solve(p7))

# convert to category layers for visualization
s2 <- terra::rast(lapply(s2, category_layer))
names(s2) <- c(
  "basic solution", "within zone clumping (low)",
  "within zone clumping (high)"
)

# plot solutions
plot(s2, axes = FALSE)
}

}
\seealso{
Other penalties: 
\code{\link{add_asym_connectivity_penalties}()},
\code{\link{add_boundary_penalties}()},
\code{\link{add_connectivity_penalties}()},
\code{\link{add_feature_weights}()},
\code{\link{add_linear_penalties}()}
}
\concept{penalties}
