[{"path":"https://prioritizr.net/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing","title":"Contributing","text":"First , thanks thinking contributing prioritizr R package! open source project, contributions extremely welcome.","code":""},{"path":"https://prioritizr.net/CONTRIBUTING.html","id":"how-you-can-contribute","dir":"","previous_headings":"","what":"How you can contribute","title":"Contributing","text":"several ways can contribute project. want know contribute open source projects like one, see Open Source Guide.","code":""},{"path":"https://prioritizr.net/CONTRIBUTING.html","id":"ask-a-question","dir":"","previous_headings":"How you can contribute","what":"Ask a question","title":"Contributing","text":"Using package got stuck? Browse documentation see can find solution. Still stuck? Post question issue GitHub. offer user support, ’ll try best address , questions often lead better documentation discovery bugs. Want ask question private? Please feel free email package developers Jeffrey Hanson Richard Schuster.","code":""},{"path":"https://prioritizr.net/CONTRIBUTING.html","id":"propose-an-idea","dir":"","previous_headings":"How you can contribute","what":"Propose an idea","title":"Contributing","text":"idea new feature? Take look documentation issue tracker see isn’t included suggested yet. , suggest idea issue GitHub. can’t promise implement idea, helps : Explain detail work. Keep scope narrow possible. See want contribute code idea well.","code":""},{"path":"https://prioritizr.net/CONTRIBUTING.html","id":"report-a-bug","dir":"","previous_headings":"How you can contribute","what":"Report a bug","title":"Contributing","text":"Using package discovered bug? ’s annoying! Don’t let others experience report issue GitHub can fix . good bug report makes easier us , please include: operating system name version (e.g., Mac OS 10.13.6). Details local setup might helpful troubleshooting, session information (via sessionInfo()). Detailed steps reproduce bug.","code":""},{"path":"https://prioritizr.net/CONTRIBUTING.html","id":"improve-the-documentation","dir":"","previous_headings":"How you can contribute","what":"Improve the documentation","title":"Contributing","text":"Noticed typo website? Think function use better example? Good documentation makes difference, help improve welcome!","code":""},{"path":"https://prioritizr.net/CONTRIBUTING.html","id":"the-website","dir":"","previous_headings":"How you can contribute > Improve the documentation","what":"The website","title":"Contributing","text":"website generated using pkgdown R package package. means don’t write html: content pulled together documentation code, vignettes, Markdown files, package DESCRIPTION _pkgdown.yml settings. know way around pkgdown, can propose file change improve documentation. , report issue can point right direction.","code":""},{"path":"https://prioritizr.net/CONTRIBUTING.html","id":"learning-resources","dir":"","previous_headings":"","what":"Learning resources","title":"Contributing","text":"’re new R package development, recommend reading Advanced R book. Since large part code base written C++ programming language using Rcpp R package, also recommend reading Rcpp everyone book. books free, online, absolutely fantastic resources.","code":""},{"path":"https://prioritizr.net/CONTRIBUTING.html","id":"function-documentation","dir":"","previous_headings":"Learning resources","what":"Function documentation","title":"Contributing","text":"Functions described comments near code translated documentation using roxygen2 R package package. want improve function description: Go R/ directory code repository. Look file name function. Propose file change update function documentation roxygen comments (starting #').","code":""},{"path":"https://prioritizr.net/CONTRIBUTING.html","id":"contribute-code","dir":"","previous_headings":"Learning resources","what":"Contribute code","title":"Contributing","text":"Care fix bugs implement new functionality? ’s brilliant! look issue list leave comment things want work . See also development guidelines . Please note use American spelling package, follow tidyverse style guide.","code":""},{"path":"https://prioritizr.net/CONTRIBUTING.html","id":"development-guidelines","dir":"","previous_headings":"","what":"Development guidelines","title":"Contributing","text":"try follow GitHub flow development. Fork repo clone computer. learn process, see guide. forked cloned project since worked , pull changes original repo clone using git pull upstream master. Open RStudio project file (.Rproj). Write code. Test code (bonus points adding unit tests). Document code (see function documentation ). Check code devtools::check() aim 0 errors warnings. Commit push changes. Submit pull request.","code":""},{"path":"https://prioritizr.net/CONTRIBUTING.html","id":"internal-design","dir":"","previous_headings":"","what":"Internal design","title":"Contributing","text":"describe internal design package. ConservationProblem class (defined R/ConservationProblem-class.R) used store data problem formulation conservation planning problem. Additionally, OptimizationProblem class (defined R/OptimizationProblem-class.R) used store precise mathematical formulation conservation planning problem. ConservationProblem object solved (using solve() function), ConservationProblem object first compiled OptimizationProblem object (using compile() function) OptimizationProblem object solved (using solve() function). distinction important want add new objective, constraint, penalty, decision function, ’ll need write code adds mathematical formulation function OptimizationProblem object. OptimizationProblem objects simply wrapper external pointer pointer (XPtr) points C++ OPTIMIZATIONPROBLEM class object (defined src/optimization_problem.h). C++ OPTIMIZATIONPROBLEM class contains standard data needed formulate mixed integer linear programming problem (.e., model sense, problem objective , constraint matrix, constraint senses, right-hand-side values, variable decision types, variable bounds). class also contains additional data pertain conservation problems (.e., number features, planning units, zones). ’re unfamiliar standard representation mixed integer linear programming problem, encourage read documentation gurobi R package. fields A_i, A_j, A_x correspond row, column, cells values constraint matrix optimization problem (respectively). fields follow standard conventions. Note constraint matrix , ultimately, constructed Matrix::sparseMatrix() row column indices need sequential. Additionally, C++ constraint penalty functions independent. words, though may computationally efficient reuse constraints variables encoded functions, C++ constraint penalty function define constraints variables. conservation planning problems defined following one two standard mathematical formulations: compressed expanded formulation. compressed formulation defines problem assumes instances conserved feature used achieve target count towards benefit solution. Although expanded formulation can provide identical solutions compressed formulation, compressed formulation provided simpler can used much larger sized problems. Currently, constraints use compressed formulation except add_feature_contiguity_constraints() function. formulation, first set decision variables (first number planning units × number zones) always pertain state planning units. Thus problem containing 3 planning units 2 zones, first six variables indicate allocation : planning unit 1 zone 1, planning unit 2 zone 1, planning unit 3 zone 1, planning unit 1 zone 2, planning unit 2 zone 2, planning unit 3 zone 2. first set constraints (rows) always correspond target (noting objectives use “fake” targets initialize feature planning unit data, see R/compile.R). rows, correspond single target, contain amount feature zone target pertains. Thus rows targets pertain single zone contain feature abundance data planning units (columns) single zone, rows targets pertain single feature multiple zones contain feature abundance data planning units (columns) multiple zones. help illustrate compressed formulation, consider following problem: compressed formulation expresses planning unit feature data using following constraint matrix. , variable (column) corresponds different planning unit different zone allocation, constraint (row) corresponds different target, cell corresponds amount feature planning unit given different zone (based rij data targets). expanded formulation, hand, defines problem can allow instances conserved features used achieving targets maximizing conservation benefit. formulation generalized version compressed formulation. contains additional variables (columns) constraints (rows) combination feature, planning unit, zone indicate given planning unit allocated specific zone also allocated conserve given feature. Given previous problem, expanded formulation expresses planning unit feature data constraint matrix :","code":"# simulate data pu <- data.frame(id = 1:3, cost_1 = 4:6, cost_2 = 7:9) zone <- data.frame(id = 1:2, name = c(\"z1\", \"z2\")) feature <- data.frame(id = 1:2, name = c(\"f1\", \"f2\")) rij <- expand.grid(pu = 1:3, species = 1:2, zone = 1:2) rij$amount <- seq_len(nrow(rij)) + nrow(rij) targets <- matrix(1, nrow = 2, ncol = 2)  # create problem p <-   problem(pu, feature, rij, c(\"cost_1\", \"cost_2\"), zone) %>%   add_absolute_targets(targets)  # print problem print(p) ## A conservation problem (<ConservationProblem>)  ## ├•data  ## │├•zones:       \"z1\" and \"z2\" (2 total)  ## │├•features:    \"f1\" and \"f2\" (2 total)  ## │└•planning units:  ## │ ├•data:       <data.frame> (3 total)  ## │ ├•costs:      continuous values (between 4 and 9)  ## │ ├•extent:     NA  ## │ └•CRS:        NA  ## └•formulation  ##  ├•objective:   none specified  ##  ├•penalties:   none specified  ##  ├•targets:     absolute targets (between 1 and 1)  ##  ├•constraints: none specified  ##  ├•decisions:   binary decision  ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …)  ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …)  ## # ℹ Use `summary(...)` to see complete formulation. ## 4 x 6 sparse Matrix of class \"dgCMatrix\" ##              pu1_z1 pu2_z1 pu3_z1 pu1_z2 pu2_z2 pu3_z2 ## target_f1_z1     13     14     15      .      .      . ## target_f2_z1     16     17     18      .      .      . ## target_f1_z2      .      .      .     19     20     21 ## target_f2_z2      .      .      .     22     23     24 # generate targets targets2 <- p$targets$output()  # create matrix m <- matrix(   NA,   ncol =     (p$number_of_zones() * p$number_of_planning_units()) +     (p$number_of_zones() * p$number_of_planning_units() *       p$number_of_features()),   nrow =     (p$number_of_zones() * p$number_of_planning_units() *       p$number_of_features()) +     (p$number_of_features() * p$number_of_zones()) )  # add row names rownames(m) <- c(   paste0(     \"pu\",     rep(       seq_len(p$number_of_planning_units()),       p$number_of_zones() * p$number_of_features()     ),     \"_\",     rep(       rep(p$feature_names(), each = p$number_of_planning_units()),       p$number_of_zones()     ),     \"_\",     rep(       p$zone_names(),       each = p$number_of_planning_units() * p$number_of_features()     )   ),   paste0(     \"target_\",     rep(       p$feature_names(), p$number_of_zones()), \"_\", rep(p$zone_names(),       each = p$number_of_features()     )   ) )  # add column names colnames(m) <- c(   paste0(     \"pu\",     rep(seq_len(p$number_of_planning_units()), p$number_of_zones()),     \"_\",     rep(p$zone_names(), each = p$number_of_planning_units())   ),   paste0(     \"pu\",     rep(       seq_len(p$number_of_planning_units()),       p$number_of_zones() * p$number_of_features()     ),     \"_\",     rep(       rep(p$feature_names(), each = p$number_of_planning_units()),       p$number_of_zones()     ),     \"_\",     rep(       p$zone_names(),       each = p$number_of_planning_units() *       p$number_of_features()     )   ) )  # add in indicator variables and constraints curr_row <- 0 for (z in seq_len(p$number_of_zones())) {   for (i in seq_len(p$number_of_features())) {     for (j in seq_len(p$number_of_planning_units())) {       curr_row <- curr_row + 1       curr_col1 <- ((z - 1) * p$number_of_planning_units()) + j       curr_col2 <-         (p$number_of_planning_units() * p$number_of_zones()) +         ((z - 1) * p$number_of_features() * p$number_of_planning_units()) +         ((i - 1) * p$number_of_planning_units()) + j       m[curr_row, curr_col1] <- -1       m[curr_row, curr_col2] <- 1     }   } }  # add in targets for (i in seq_len(nrow(targets2))) {   # extract indices   curr_row <- curr_row + 1   curr_feature <- targets2$feature[i]   curr_zone <- targets2$zone[i][[1]]   curr_cols <-     (p$number_of_planning_units() * p$number_of_zones()) +     ((curr_zone - 1) * p$number_of_features() * p$number_of_planning_units()) +     ((curr_feature - 1) * p$number_of_planning_units()) +     seq_len(p$number_of_planning_units())   curr_amount <-     rij$amount[unlist(rij$zone) == curr_zone & rij$species == curr_feature]   # set matrix values   m[curr_row, curr_cols] <- curr_amount }  # convert to sparse matrix m[is.na(m)] <- 0 m <- as(m, \"sparseMatrix\")  # print matrix print(m) ## 16 x 18 sparse Matrix of class \"dgCMatrix\"  ##   [[ suppressing 18 column names 'pu1_z1', 'pu2_z1', 'pu3_z1' ... ]]  ##                                                                    ## pu1_f1_z1    -1  .  .  .  .  .  1  .  .  .  .  .  .  .  .  .  .  . ## pu2_f1_z1     . -1  .  .  .  .  .  1  .  .  .  .  .  .  .  .  .  . ## pu3_f1_z1     .  . -1  .  .  .  .  .  1  .  .  .  .  .  .  .  .  . ## pu1_f2_z1    -1  .  .  .  .  .  .  .  .  1  .  .  .  .  .  .  .  . ## pu2_f2_z1     . -1  .  .  .  .  .  .  .  .  1  .  .  .  .  .  .  . ## pu3_f2_z1     .  . -1  .  .  .  .  .  .  .  .  1  .  .  .  .  .  . ## pu1_f1_z2     .  .  . -1  .  .  .  .  .  .  .  .  1  .  .  .  .  . ## pu2_f1_z2     .  .  .  . -1  .  .  .  .  .  .  .  .  1  .  .  .  . ## pu3_f1_z2     .  .  .  .  . -1  .  .  .  .  .  .  .  .  1  .  .  . ## pu1_f2_z2     .  .  . -1  .  .  .  .  .  .  .  .  .  .  .  1  .  . ## pu2_f2_z2     .  .  .  . -1  .  .  .  .  .  .  .  .  .  .  .  1  . ## pu3_f2_z2     .  .  .  .  . -1  .  .  .  .  .  .  .  .  .  .  .  1 ## target_f1_z1  .  .  .  .  .  . 13 14 15  .  .  .  .  .  .  .  .  . ## target_f2_z1  .  .  .  .  .  .  .  .  . 16 17 18  .  .  .  .  .  . ## target_f1_z2  .  .  .  .  .  .  .  .  .  .  .  . 19 20 21  .  .  . ## target_f2_z2  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 22 23 24"},{"path":"https://prioritizr.net/articles/calibrating_trade-offs_tutorial.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Calibrating trade-offs tutorial","text":"Systematic conservation planning requires making trade-offs (Margules & Pressey 2000; Vane-Wright et al. 1991). Since different criteria may conflict one another – align perfectly – prioritizations need make trade-offs different criteria (Klein et al. 2013). Although criteria can easily accounted using locked constraints representation targets (e.g., Dorji et al. 2020; Hermoso et al. 2018), always case (e.g., Beger et al. 2010). example, prioritizations often need balance overall cost overall level spatial fragmentation among reserves (Hermoso et al. 2011; Stewart & Possingham 2005). Additionally, prioritizations often need balance overall level connectivity among reserves criteria (Hermoso et al. 2012). Since best trade-depends range factors – available budgets, species’ connectivity requirements, management capacity – finding best balance can challenging. prioritizr R package provides multi-objective optimization methods help identify best trade-offs different criteria. achieve , conservation planning problem can formulated primary objective (e.g., add_min_set_objective()) penalties (e.g., add_boundary_penalties()) relate criteria. building problem, nature trade-offs can specified using certain parameters (e.g., penalty parameter add_boundary_penalties() function). identify prioritization finds best balance different criteria, trade-parameters can tuned using calibration analysis. analyses – context systematic conservation planning – typically involve generating set candidate prioritizations based different parameters, measuring performance according criteria, selecting prioritization (set prioritizations) based well achieve criteria (Hermoso et al. 2011; Stewart & Possingham 2005; Hermoso et al. 2012). example, Marxan decision support tool range parameters (e.g., species penalty factors, boundary length modifier) calibrated balance cost, species’ representation, spatial fragmentation (Ardron et al. 2010). aim tutorial provide guidance calibrating trade-offs using prioritizr R package. explore couple different approaches generating candidate prioritizations, methods finding best balance different criteria. Specifically, try generate prioritizations strike best balance total cost spatial fragmentation (measured total boundary length). , code used vignette directly applicable performing boundary length calibration analysis.","code":""},{"path":"https://prioritizr.net/articles/calibrating_trade-offs_tutorial.html","id":"data","dir":"Articles","previous_headings":"","what":"Data","title":"Calibrating trade-offs tutorial","text":"Let’s load packages dataset used tutorial. Since tutorial uses prioritizrdata R package along several R packages (see ), please ensure installed. particular dataset comprises two objects: tas_pu tas_features. Although briefly describe dataset , please refer ?prioritizrdata::tas_data details. tas_pu object contains planning units represented spatial polygons (.e., converted sf::st_sf() object). object three columns denote following information planning unit: unique identifier (id), unimproved land value (cost), current conservation status (locked_in). Specifically, conservation status column indicates least half area planning unit covered existing protected areas (denoted value 1) (denoted value zero).   tas_features object describes spatial distribution different vegetation communities (using presence/absence data). use vegetation communities biodiversity features prioritization.  can use dataset generate prioritization. Specifically, use minimum set objective optimization process minimizes total cost. add representation targets ensure prioritizations cover 17% vegetation community. Additionally, add constraints ensure planning units covered existing protected areas selected (.e., locked ). Finally, specify conservation planning exercise involves binary decisions (.e., selecting selecting planning units protected area establishment).  can see priority areas identified prioritization scattered across study area (shown green). Indeed, none priority areas connected existing protected areas (shown purple), connected priority areas. , prioritization high level spatial fragmentation. important avoid levels spatial fragmentation, need explicitly account spatial fragmentation optimization process.","code":"# load packages library(prioritizrdata) library(prioritizr) library(sf) library(terra) library(dplyr) library(tibble) library(ggplot2) library(topsis) library(withr)  # load planning unit data tas_pu <- get_tas_pu() print(tas_pu) ## Simple feature collection with 1130 features and 4 fields ## Geometry type: MULTIPOLYGON ## Dimension:     XY ## Bounding box:  xmin: 298809.6 ymin: 5167775 xmax: 613818.8 ymax: 5502544 ## Projected CRS: WGS 84 / UTM zone 55S ## # A tibble: 1,130 × 5 ##       id  cost locked_in locked_out                                         geom ##    <int> <dbl> <lgl>     <lgl>                                <MULTIPOLYGON [m]> ##  1     1 60.2  FALSE     TRUE       (((328497 5497704, 326783.8 5500050, 326775… ##  2     2 19.9  FALSE     FALSE      (((307121.6 5490487, 305344.4 5492917, 3053… ##  3     3 59.7  FALSE     TRUE       (((321726.1 5492382, 320111 5494593, 320127… ##  4     4 32.4  FALSE     FALSE      (((304314.5 5494324, 304342.2 5494287, 3043… ##  5     5 26.2  FALSE     FALSE      (((314958.5 5487057, 312336 5490646, 312339… ##  6     6 51.3  FALSE     FALSE      (((327904.3 5491218, 326594.6 5493012, 3284… ##  7     7 32.3  FALSE     FALSE      (((308194.1 5481729, 306601.2 5483908, 3066… ##  8     8 38.4  FALSE     FALSE      (((322792.7 5483624, 319965.3 5487497, 3199… ##  9     9  3.55 FALSE     FALSE      (((334896.6 5490731, 335610.4 5492490, 3357… ## 10    10  1.83 FALSE     FALSE      (((356377.1 5487952, 353903.1 5487635, 3538… ## # ℹ 1,120 more rows # load feature data tas_features <- get_tas_features() print(tas_features) ## class       : SpatRaster  ## dimensions  : 398, 359, 33  (nrow, ncol, nlyr) ## resolution  : 1000, 1000  (x, y) ## extent      : 288801.7, 647801.7, 5142976, 5540976  (xmin, xmax, ymin, ymax) ## coord. ref. : WGS 84 / UTM zone 55S (EPSG:32755)  ## source      : tas_features.tif  ## names       : Banks~lands, Bould~marks, Calli~lands, Cool ~orest, Eucal~hyll), Eucal~torey, ...  ## min values  :           0,           0,           0,           0,           0,           0, ...  ## max values  :           1,           1,           1,           1,           1,           1, ... # plot map of planning unit costs plot(tas_pu[, \"cost\"]) # plot map of planning unit statuses plot(tas_pu[, \"locked_in\"]) # plot map of the first four vegetation classes plot(tas_features[[1:4]]) # define a problem p0 <-   problem(tas_pu, tas_features, cost_column = \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.17) %>%   add_locked_in_constraints(\"locked_in\") %>%   add_binary_decisions()  # print problem print(p0) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"Banksia woodlands\" , … (33 total) ## │└•planning units: ## │ ├•data:       <sftbl_dftbldata.frame> (1130 total) ## │ ├•costs:      continuous values (between 0.1925 and 61.9273) ## │ ├•extent:     298809.5764, 5167774.5993, 613818.7743, 5502543.7119 (xmin, ymin, xmax, ymax) ## │ └•CRS:        WGS 84 / UTM zone 55S (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties:   none specified ## │├•targets:     relative targets (between 0.17 and 0.17) ## │├•constraints: ## ││└•1:          locked in constraints (257 planning units) ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # solve problem s0 <- solve(p0) ## Gurobi Optimizer version 10.0.2 build v10.0.2rc0 (linux64) ##  ## CPU model: 11th Gen Intel(R) Core(TM) i7-1185G7 @ 3.00GHz, instruction set [SSE2|AVX|AVX2|AVX512] ## Thread count: 4 physical cores, 8 logical processors, using up to 1 threads ##  ## Optimize a model with 33 rows, 1130 columns and 8157 nonzeros ## Model fingerprint: 0xd205b612 ## Variable types: 0 continuous, 1130 integer (1130 binary) ## Coefficient statistics: ##   Matrix range     [2e-06, 6e+01] ##   Objective range  [2e-01, 6e+01] ##   Bounds range     [1e+00, 1e+00] ##   RHS range        [2e-01, 2e+03] ## Found heuristic solution: objective 10337.581214 ## Presolve removed 19 rows and 354 columns ## Presolve time: 0.00s ## Presolved: 14 rows, 776 columns, 2296 nonzeros ## Variable types: 0 continuous, 776 integer (776 binary) ## Found heuristic solution: objective 9018.7830067 ##  ## Explored 0 nodes (0 simplex iterations) in 0.01 seconds (0.01 work units) ## Thread count was 1 (of 8 available processors) ##  ## Solution count 2: 9018.78 10337.6  ##  ## Optimal solution found (tolerance 1.00e-01) ## Best objective 9.018783006750e+03, best bound 8.496084047117e+03, gap 5.7957% # print result print(s0) ## Simple feature collection with 1130 features and 5 fields ## Geometry type: MULTIPOLYGON ## Dimension:     XY ## Bounding box:  xmin: 298809.6 ymin: 5167775 xmax: 613818.8 ymax: 5502544 ## Projected CRS: WGS 84 / UTM zone 55S ## # A tibble: 1,130 × 6 ##       id  cost locked_in locked_out solution_1                              geom ##    <int> <dbl> <lgl>     <lgl>           <dbl>                <MULTIPOLYGON [m]> ##  1     1 60.2  FALSE     TRUE                0 (((328497 5497704, 326783.8 5500… ##  2     2 19.9  FALSE     FALSE               0 (((307121.6 5490487, 305344.4 54… ##  3     3 59.7  FALSE     TRUE                0 (((321726.1 5492382, 320111 5494… ##  4     4 32.4  FALSE     FALSE               0 (((304314.5 5494324, 304342.2 54… ##  5     5 26.2  FALSE     FALSE               0 (((314958.5 5487057, 312336 5490… ##  6     6 51.3  FALSE     FALSE               0 (((327904.3 5491218, 326594.6 54… ##  7     7 32.3  FALSE     FALSE               0 (((308194.1 5481729, 306601.2 54… ##  8     8 38.4  FALSE     FALSE               0 (((322792.7 5483624, 319965.3 54… ##  9     9  3.55 FALSE     FALSE               0 (((334896.6 5490731, 335610.4 54… ## 10    10  1.83 FALSE     FALSE               0 (((356377.1 5487952, 353903.1 54… ## # ℹ 1,120 more rows # create column for making a map of the prioritization s0$map_1 <- case_when(   s0$locked_in > 0.5 ~ \"locked in\",   s0$solution_1 > 0.5 ~ \"priority\",   TRUE ~ \"other\" )  # plot map of prioritization plot(   s0[, \"map_1\"], pal = c(\"purple\", \"grey90\", \"darkgreen\"),   main = NULL, key.pos = 1 )"},{"path":"https://prioritizr.net/articles/calibrating_trade-offs_tutorial.html","id":"preliminary-processing","dir":"Articles","previous_headings":"","what":"Preliminary processing","title":"Calibrating trade-offs tutorial","text":"need conduct preliminary processing procedures prepare data subsequent analysis. important help make easier find suitable trade-parameters, avoid numerical scaling issues can result overly long run times (see presolve_check() information). processing steps akin data scaling (normalization) procedures applied statistical analysis improve model convergence. first processing procedure involves setting cost values locked planning units zero. total cost estimates prioritization reflects total cost establishing new protected areas – just total land value. words, want total cost estimate prioritization reflect cost implementing conservation actions. procedure especially important using hierarchical approach described , cost thresholds based percentage increases cost establishing new protected areas.  second procedure involves pre-computing boundary length data manually re-scaling boundary length values. procedure important boundary length values often high, can cause numerical issues result excessive run times (see presolve_check() details). applying procedures, data ready subsequent analysis.","code":"# set costs for planning units covered by existing protected areas to zero tas_pu$cost[tas_pu$locked_in > 0.5] <- 0  # plot map of planning unit costs plot(tas_pu[, \"cost\"]) # generate boundary length data for the planning units tas_bd <- boundary_matrix(tas_pu)  # manually re-scale the boundary length values tas_bd <- rescale_matrix(tas_bd)"},{"path":"https://prioritizr.net/articles/calibrating_trade-offs_tutorial.html","id":"generating-candidate-prioritizations","dir":"Articles","previous_headings":"","what":"Generating candidate prioritizations","title":"Calibrating trade-offs tutorial","text":"start calibration analysis generating set candidate prioritizations. Specifically, prioritizations generated using different parameters specify different trade-offs different criteria. Since tutorial involves navigating trade-offs overall cost prioritization level spatial fragmentation associated prioritization (measured total boundary length), generate prioritizations using different parameters related criteria. examine two approaches generating candidate prioritizations based multi-objective optimization procedures. Although ’ll examining approaches tutorial, normally use one approaches conducting analysis","code":""},{"path":"https://prioritizr.net/articles/calibrating_trade-offs_tutorial.html","id":"blended-approach","dir":"Articles","previous_headings":"Generating candidate prioritizations","what":"Blended approach","title":"Calibrating trade-offs tutorial","text":"blended approach multi-objective optimization involves combining separate criteria (e.g., total cost total boundary length) single joint criterion. achieve , trade-(scaling) parameter used specify relative importance criterion. approach default approach provided prioritizr R package. Specifically, functions adding penalty problem formulation (e.g., add_boundary_penalties()) contains parameter control relative importance penalties (.e., penalty parameter). example, using add_boundary_penalties() function, setting high penalty value indicate important reduce overall exposed boundary (perimeter) prioritization. main challenge blended approach identifying range suitable penalty values generate candidate prioritizations. set penalty value low, penalties effect (e.g., boundary length penalties effect prioritization). set penalty value high, prioritization effectively ignore primary objective. cases, prioritization overly spatially clustered – planning unit cost values effect — contain single reserve. Thus need find suitable range penalty values can generate set candidate prioritizations. can find suitable range penalty values generating set preliminary prioritizations. preliminary prioritizations based different penalty values – similar process generating candidate prioritizations – solved using customized settings sacrifice optimality fast run times (see details). especially important specifying penalty value high cause optimization process take long time generate solutions (due numerical scaling issues mentioned previously). find suitable range penalty values, need identify upper limit penalty value (.e., highest penalty value result prioritization containing single reserve). Let’s create preliminary penalty identify upper limit. Please note might need adjust prelim_upper value find upper limit analyzing different datasets. Next, let’s use preliminary penalty values generate preliminary prioritizations. mentioned earlier, generate preliminary prioritizations using customized settings reduce runtime. Specifically, set time limit 10 minutes per run, relax optimality gap 20%. Although normally use settings – resulting prioritizations guaranteed near-optimal (default gap 10%) – fine goal tune preliminary penalty values. Indeed, none preliminary prioritizations considered candidate prioritizations. Please note might need set higher time limit, relax optimality gap even (e.g., 40%) analyzing larger datasets. generating preliminary prioritizations, let’s create maps visualize . particular, want understand different penalty values influence spatial fragmentation prioritizations.  can see penalty value used generate prioritizations increases, spatial fragmentation prioritizations decreases. particular, can see penalty value 8.05842 results single reserve – meaning best guess upper limit. Using penalty value upper limit, now generate second series prioritizations candidate prioritizations. Critically, candidate prioritizations generated using time limit generated using suitable gap (.e., default gap 10%).  now set candidate prioritizations generated using blended approach. main advantages approach similar calibration analyses used decision support tools conservation (.e., Marxan) relatively straightforward implement. However, approach also key disadvantage. penalty parameter unitless trade-parameter – meaning can’t leverage existing knowledge specify suitable range penalty values – first conduct preliminary analysis identify upper limit. Although finding upper limit fairly simple example dataset, can difficult find realistic data. next section, show generate set candidate prioritizations using hierarchical approach – disadvantage.","code":"# define a range of different penalty values ## note that we use a power scale to avoid focusing on very high penalty values prelim_lower <- -5  # change this for your own data prelim_upper <- 1.75 # change this for your own data prelim_penalty <- round(10^seq(prelim_lower, prelim_upper, length.out = 9), 5)  # print penalty values print(prelim_penalty) ## [1]  0.00001  0.00007  0.00049  0.00340  0.02371  0.16548  1.15478  8.05842 ## [9] 56.23413 # define a problem without boundary penalties p0 <-   problem(tas_pu, tas_features, cost_column = \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.17) %>%   add_locked_in_constraints(\"locked_in\") %>%   add_binary_decisions()  # generate preliminary prioritizations based on each penalty ## note that we specify a relaxed gap and time limit for the solver prelim_blended_results <- lapply(prelim_penalty, function(x) {   s <-     p0 %>%     add_boundary_penalties(penalty = x, data = tas_bd) %>%     add_default_solver(gap = 0.2, time_limit = 10 * 60) %>%     solve()   s <- data.frame(s = s$solution_1)   names(s) <- with_options(list(scipen = 30), paste0(\"penalty_\", x))   s })  # format results as a single spatial object prelim_blended_results <- cbind(   tas_pu, do.call(bind_cols, prelim_blended_results) )  # preview results print(prelim_blended_results) # plot maps of prioritizations plot(   x =     prelim_blended_results %>%     dplyr::select(starts_with(\"penalty_\")) %>%     mutate_if(is.numeric, function(x) {       case_when(         prelim_blended_results$locked_in > 0.5 ~ \"locked in\",         x > 0.5 ~ \"priority\",         TRUE ~ \"other\"       )     }),   pal = c(\"purple\", \"grey90\", \"darkgreen\") ) # define a new set of penalty values penalty <- round(10^seq(-5, log10(prelim_penalty[8]), length.out = 9), 5)  # generate prioritizations based on each penalty blended_results <- lapply(penalty, function(x) {   ## generate solution   s <-     p0 %>%     add_boundary_penalties(penalty = x, data = tas_bd) %>%     solve()   ## return data frame with solution   s <- data.frame(s = s$solution_1)   names(s) <- with_options(list(scipen = 30), paste0(\"penalty_\", x))   s })  # format results as a single spatial object blended_results <- cbind(tas_pu, do.call(bind_cols, blended_results))  # plot maps of prioritizations plot(   x =     blended_results %>%     dplyr::select(starts_with(\"penalty_\")) %>%     mutate_if(is.numeric, function(x) {       case_when(         blended_results$locked_in > 0.5 ~ \"locked in\",         x > 0.5 ~ \"priority\",         TRUE ~ \"other\"       )     }),   pal = c(\"purple\", \"grey90\", \"darkgreen\") )"},{"path":"https://prioritizr.net/articles/calibrating_trade-offs_tutorial.html","id":"hierarchical-approach","dir":"Articles","previous_headings":"Generating candidate prioritizations","what":"Hierarchical approach","title":"Calibrating trade-offs tutorial","text":"hierarchical approach multi-objective optimization involves generating series incremental prioritizations – using different objective increment refine previous solution – final solution achieves objectives. advantage approach can specify trade-parameters objective based percentage optimality. means can leverage knowledge – decision maker – generate range suitable trade-parameters. , approach require us generate series preliminary prioritizations. approach slightly complicated implement within prioritizr R package blended approach. start , generate initial prioritization based problem formulation consider penalties. Critically, generate prioritization solving problem optimality (using gap parameter add_default_solver() function).  Next, calculate total cost initial prioritization. Now calculate series cost thresholds. cost thresholds calculated inflating cost initial prioritization range percentage values. Since values percentages – unitless values unlike used blended approach – can use domain knowledge specify suitable range cost thresholds. tutorial, let’s assume impractical – per domain knowledge – expend four times total cost initial prioritization reduce spatial fragmentation. generating cost thresholds, can use generate prioritizations. Specifically, generate prioritizations aim minimize total boundary length much possible – ignoring total cost prioritizations – whilst ensuring total cost prioritization exceed given cost threshold considerations (e.g., locked constraints). achieve , create new column tas_pu object contains zero values (called zeros) use new column specify cost data prioritizations. Although normally recommend cost data contain zero values – planning units zero costs often selected prioritizations even needed – use zero cost values prioritization focus exclusively spatial fragmentation. Additionally, comes generating prioritization, add linear constraints ensure total cost prioritization exceed given cost threshold (using add_linear_constraints() function).  now set candidate prioritizations generated using hierarchical approach. approach can much faster blended approach require generating set prioritizations identify upper limit penalty trade-parameter. generating set candidate prioritizations, can calculate performance metrics compare prioritizations.","code":"# define a problem without boundary penalties p1 <-   problem(tas_pu, tas_features, cost_column = \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.17) %>%   add_locked_in_constraints(\"locked_in\") %>%   add_binary_decisions() %>%   add_default_solver(gap = 0)  # solve problem s1 <- solve(p1)  # add column for making a map of the prioritization s1$map_1 <- case_when(   s1$locked_in > 0.5 ~ \"locked in\",   s1$solution_1 > 0.5 ~ \"priority\",   TRUE ~ \"other\" )  # plot map of prioritization plot(   s1[, \"map_1\"], pal = c(\"purple\", \"grey90\", \"darkgreen\"),   main = NULL, key.pos = 1 ) # calculate cost s1_cost <- eval_cost_summary(p1, s1[, \"solution_1\"])$cost  # print cost print(s1_cost) ## [1] 354.3258 # calculate cost threshold values threshold <- s1_cost + (s1_cost * seq(1e-5, 4, length.out = 9)) threshold <- ceiling(threshold)  # print cost thresholds print(threshold) ## [1]  355  532  709  886 1063 1241 1418 1595 1772 # add a column with zeros tas_pu$zeros <- 0  # define a problem with zero cost values and boundary penalties ## note that because all the costs are all zero, it doesn't actually ## matter what penalty value is used (as long as the value is > 0) ## and so we just use a value of 1 p2 <-   problem(tas_pu, tas_features, cost_column = \"zeros\") %>%   add_min_set_objective() %>%   add_boundary_penalties(penalty = 1, data = tas_bd) %>%   add_relative_targets(0.17) %>%   add_locked_in_constraints(\"locked_in\") %>%   add_binary_decisions() ## Warning: `x[, cost_column]` has only zero values. # generate prioritizations based on each cost threshold ## note that the prioritizations are solved to within 10% of optimality ## (the default gap) because the gap is not specified hierarchical_results <- lapply(threshold, function(x) {   ## generate solution by adding a constraint based on the threshold and   ## using the \"real\" cost values (i.e., not zeros)   s <-     p2 %>%     add_linear_constraints(threshold = x, sense = \"<=\", data = \"cost\") %>%     solve()   ## return data frame with solution   s <- data.frame(s = s$solution_1)   names(s) <- paste0(\"threshold_\", x)   s })  # format results as a single spatial object hierarchical_results <- cbind(tas_pu, do.call(bind_cols, hierarchical_results))  # plot maps of prioritizations plot(   x =     hierarchical_results %>%     dplyr::select(starts_with(\"threshold_\")) %>%     mutate_if(is.numeric, function(x) {       case_when(         hierarchical_results$locked_in > 0.5 ~ \"locked in\",         x > 0.5 ~ \"priority\",         TRUE ~ \"other\"       )     }),   pal = c(\"purple\", \"grey90\", \"darkgreen\") )"},{"path":"https://prioritizr.net/articles/calibrating_trade-offs_tutorial.html","id":"calculating-performance-metrics","dir":"Articles","previous_headings":"","what":"Calculating performance metrics","title":"Calibrating trade-offs tutorial","text":"calculate performance metrics compare prioritizations. Since aim navigate trade-offs total cost prioritization overall level spatial fragmentation associated prioritization (measured total boundary length), calculate metrics assess criteria. Although generated two sets candidate prioritizations previous section; brevity, consider candidate prioritizations generated using hierarchical approach. Please note also apply following procedures candidate prioritizations generated using blended approach. calculating metrics, let’s can use help select prioritization.","code":"# calculate metrics for prioritizations ## note that we use p0 and not p1 so that cost calculations are based ## on the cost values and not zeros hierarchical_metrics <- lapply(   grep(\"threshold_\", names(hierarchical_results)), function(x) {     x <- hierarchical_results[, x]     data.frame(       total_cost = eval_cost_summary(p0, x)$cost,       total_boundary_length = eval_boundary_summary(p0, x)$boundary     )   } ) hierarchical_metrics <- do.call(bind_rows, hierarchical_metrics) hierarchical_metrics$threshold <- threshold hierarchical_metrics <- as_tibble(hierarchical_metrics)  # preview metrics print(hierarchical_metrics) ## # A tibble: 9 × 3 ##   total_cost total_boundary_length threshold ##        <dbl>                 <dbl>     <dbl> ## 1       355.              2887523.       355 ## 2       526.              2288083.       532 ## 3       706.              2130949.       709 ## 4       886.              2044820.       886 ## 5      1063.              1952360.      1063 ## 6      1238.              1893076.      1241 ## 7      1416.              1809923.      1418 ## 8      1589.              1791258.      1595 ## 9      1767.              1743287.      1772"},{"path":"https://prioritizr.net/articles/calibrating_trade-offs_tutorial.html","id":"selecting-a-prioritization","dir":"Articles","previous_headings":"","what":"Selecting a prioritization","title":"Calibrating trade-offs tutorial","text":"Now need decide candidate prioritization achieves best trade-. range qualitative quantitative methods available select candidate prioritization (Ardron et al. 2010). consider three different methods. Since methods use set candidate prioritizations, use candidate prioritizations using hierarchical approach methods. keep track prioritizations selected different methods, let’s create results_data table. Next, let’s examine different methods selecting prioritizations.","code":"# create data for plotting result_data <-   hierarchical_metrics %>%   ## rename threshold column to value column   rename(value = \"threshold\") %>%   ## add column with column names that contain candidate prioritizations   mutate(name = grep(     \"threshold_\", names(hierarchical_results), value = TRUE, fixed = TRUE   )) %>%   ## add column with labels for plotting   mutate(label = paste(\"Threshold =\", value)) %>%   ## add column to keep track prioritizations selected by different methods   mutate(method = \"none\")  # print table print(result_data) ## # A tibble: 9 × 6 ##   total_cost total_boundary_length value name           label            method ##        <dbl>                 <dbl> <dbl> <chr>          <chr>            <chr>  ## 1       355.              2887523.   355 threshold_355  Threshold = 355  none   ## 2       526.              2288083.   532 threshold_532  Threshold = 532  none   ## 3       706.              2130949.   709 threshold_709  Threshold = 709  none   ## 4       886.              2044820.   886 threshold_886  Threshold = 886  none   ## 5      1063.              1952360.  1063 threshold_1063 Threshold = 1063 none   ## 6      1238.              1893076.  1241 threshold_1241 Threshold = 1241 none   ## 7      1416.              1809923.  1418 threshold_1418 Threshold = 1418 none   ## 8      1589.              1791258.  1595 threshold_1595 Threshold = 1595 none   ## 9      1767.              1743287.  1772 threshold_1772 Threshold = 1772 none"},{"path":"https://prioritizr.net/articles/calibrating_trade-offs_tutorial.html","id":"visual-method","dir":"Articles","previous_headings":"Selecting a prioritization","what":"Visual method","title":"Calibrating trade-offs tutorial","text":"One qualitative method involves plotting relationship different criteria, using plot visually select candidate prioritization. visual method often used help calibrate trade-offs among prioritizations generated using Marxan decision support tool (e.g., Hermoso et al. 2011; Stewart & Possingham 2005). , let’s create plot select prioritization.  can see clear relationship total cost total boundary length. seem order achieve lower total boundary length – thus lower spatial fragmentation – prioritization must greater cost. Although might expect results show smoother curve – words, Pareto dominant solutions – result expected generated candidate prioritizations using default optimality gap 10%. Typically, visual method involves selecting prioritization near elbow plot. , let’s select prioritization generated using threshold value 709. keep track prioritizations selected based different methods, let’s create method column result_data table. Next, let’s consider quantitative approach.","code":"# create plot to visualize trade-offs and show selected candidate prioritization result_plot <-   ggplot(     data = result_data,     aes(x = total_boundary_length, y = total_cost, label = label)   ) +   geom_line() +   geom_point(size = 3) +   geom_text(hjust = -0.15) +   scale_color_manual(     values = c(\"visual\" = \"blue\", \"not selected\" =\"black\")   ) +   xlab(\"Total boundary length of prioritization\") +   ylab(\"Total cost of prioritization\") +   scale_x_continuous(expand = expansion(mult = c(0.05, 0.4))) +   theme(legend.title = element_blank())  # render plot print(result_plot) # specify prioritization selected by visual method result_data$method[3] <- \"visual\""},{"path":"https://prioritizr.net/articles/calibrating_trade-offs_tutorial.html","id":"topsis-method","dir":"Articles","previous_headings":"Selecting a prioritization","what":"TOPSIS method","title":"Calibrating trade-offs tutorial","text":"Multiple-criteria decision analysis discipline uses analytical methods evaluate trade-offs multiple criteria (MCDA; reviewed Greene et al. 2011). Although discipline contains many different methods, use Technique Order Preference Similarity Ideal Solution (TOPSIS) method (Hwang & Yoon 1981). method requires () data describing performance prioritization according different criteria, (ii) weights encode relative importance criteria, (iii) details whether criteria ideally minimized maximized. Let’s run analysis, assuming want equal weighting total cost total boundary length. candidate prioritization greatest TOPSIS score considered represent best trade-total cost total boundary length. , based method, select prioritization generated using threshold value 532. Let’s update result_data information. Next, let’s consider another quantitative method.","code":"# calculate TOPSIS scores topsis_results <- topsis(   decision =     hierarchical_metrics %>%     dplyr::select(total_cost, total_boundary_length) %>%     as.matrix(),   weights = c(1, 1),   impacts = c(\"-\", \"-\") )  # print results print(topsis_results) ##   alt.row     score rank ## 1       1 0.6904297    3 ## 2       2 0.7873884    1 ## 3       3 0.7350137    2 ## 4       4 0.6415691    4 ## 5       5 0.5489621    5 ## 6       6 0.4625481    6 ## 7       7 0.3942993    7 ## 8       8 0.3386180    8 ## 9       9 0.3095703    9 # add column indicating prioritization selected by TOPSIS method result_data$method[which.max(topsis_results$score)] <- \"TOPSIS\""},{"path":"https://prioritizr.net/articles/calibrating_trade-offs_tutorial.html","id":"cohon-et-al--1979-method","dir":"Articles","previous_headings":"Selecting a prioritization","what":"Cohon et al. (1979) method","title":"Calibrating trade-offs tutorial","text":"method based algorithm originally developed Cohon et al. (Cohon et al. 1979), later adapted use systematic conservation planning (Fischer & Church 2005). Specifically, involves generating two ideal prioritizations – prioritization representing ideal prioritization criteria – using performance metrics calculated prioritizations automatically derive trade-penalty value (Ardron et al. 2010; Cohon et al. 1979). Thus, unlike two methods, method require set candidate prioritizations. , method can used find prioritization meets multiple criteria much shorter period time methods. implement method, first need generate ideal prioritizations (note specify gap 0% ensure optimality). Next, let’s calculate performance metrics prioritizations. calculating performance metrics, can use automatically calculate penalty value. Now calculated penalty value using method, can use generate prioritization. Let’s update results_data table results prioritization. Next, let’s compare prioritizations selected different methods.","code":"# generate ideal prioritization based on cost criteria ## note that this is simply the same as the s1 prioritization we generated ## for the hierarchical approach p3 <-   problem(tas_pu, tas_features, cost_column = \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.17) %>%   add_locked_in_constraints(\"locked_in\") %>%   add_binary_decisions() %>%   add_default_solver(gap = 0)  # solve problem s3 <- solve(p3)  # generate ideal prioritization based on spatial fragmentation criteria ## note that any non-zero penalty value would here, ## so we just use a penalty  of 1 p4 <-   problem(tas_pu, tas_features, cost_column = \"zeros\") %>%   add_min_set_objective() %>%   add_boundary_penalties(penalty = 1, data = tas_bd) %>%   add_relative_targets(0.17) %>%   add_locked_in_constraints(\"locked_in\") %>%   add_binary_decisions() %>%   add_default_solver(gap = 0) ## Warning: `x[, cost_column]` has only zero values. # solve problem s4 <- solve(p4) # generate problem formulation with costs and boundary penalties for # calculating performance metrics p5 <-   problem(tas_pu, tas_features, cost_column = \"cost\") %>%   add_min_set_objective() %>%   add_boundary_penalties(penalty = 1, data = tas_bd) %>%   add_relative_targets(0.17) %>%   add_locked_in_constraints(\"locked_in\") %>%   add_binary_decisions()  # calculate performance metrics for ideal cost prioritization s3_metrics <- tibble(   total_cost = eval_cost_summary(p5, s3[, \"solution_1\"])$cost,   total_boundary_length =     eval_boundary_summary(p5, s3[, \"solution_1\"])$boundary )  # calculate performance metrics for ideal boundary length prioritization s4_metrics <- tibble(   total_cost = eval_cost_summary(p5, s4[, \"solution_1\"])$cost,   total_boundary_length =     eval_boundary_summary(p5, s4[, \"solution_1\"])$boundary ) # calculate penalty value based on Cohon et al. 1979 cohon_penalty <- abs(   (s3_metrics$total_cost - s4_metrics$total_cost) /   (s3_metrics$total_boundary_length - s4_metrics$total_boundary_length) )  # round to 5 decimal places to avoid numerical issues during optimization cohon_penalty <- round(cohon_penalty, 5)  # print penalty value print(cohon_penalty) ## [1] 0.00902 # generate prioritization using penalty value calculated using Cohon et al. 1979 p6 <-   problem(tas_pu, tas_features, cost_column = \"cost\") %>%   add_min_set_objective() %>%   add_boundary_penalties(penalty = cohon_penalty, data = tas_bd) %>%   add_relative_targets(0.17) %>%   add_locked_in_constraints(\"locked_in\") %>%   add_binary_decisions()  # solve problem s6 <- solve(p6) # add new row with data for prioritization generated following Cohon et al. 1979 result_data <- bind_rows(   result_data,   tibble(     total_cost = eval_cost_summary(p6, s6[, \"solution_1\"])$cost,     total_boundary_length =       eval_boundary_summary(p6, s6[, \"solution_1\"])$boundary,     value = cohon_penalty,     name = paste0(\"penalty_\", cohon_penalty),     label = paste0(\"Penalty = \",  cohon_penalty),     method = \"Cohon\"   ) )"},{"path":"https://prioritizr.net/articles/calibrating_trade-offs_tutorial.html","id":"method-comparison","dir":"Articles","previous_headings":"Selecting a prioritization","what":"Method comparison","title":"Calibrating trade-offs tutorial","text":"Let’s create plot visualize results different methods.  can see different methods selected different prioritizations. compare results different methods, let’s create maps showing selected prioritizations.  determine one best? difficult say. Ideally, additional information used help select prioritization, knowledge available resources, species’ connectivity requirements, impacts neighboring land use. However, practical perspective, prioritizations generated academic contexts might find quantitative approaches useful greater transparency reproducibility. Ultimately, methods designed support decision making. means intended assist decision making process, serve replacement.","code":"# create plot to visualize trade-offs and show selected candidate prioritization result_plot <-   ggplot(     data =       result_data %>%       mutate(vjust = if_else(method == \"Cohon\", -1, 0.5)),     aes(x = total_boundary_length, y = total_cost, label = label)   ) +   geom_line() +   geom_point(aes(color = method), size = 3) +   geom_text(aes(vjust = vjust, color = method), hjust = -0.1) +   scale_color_manual(     name = \"Method\",     values = c(       \"visual\" = \"#984ea3\",       \"none\" = \"#000000\",       \"TOPSIS\" = \"#e41a1c\",       \"Cohon\" = \"#377eb8\"     )   ) +   xlab(\"Total boundary length of prioritization\") +   ylab(\"Total cost of prioritization\") +   scale_x_continuous(expand = expansion(mult = c(0.05, 0.4)))  # render plot print(result_plot) # extract column names for creating the prioritizations visual_name <- result_data$name[[which(result_data$method == \"visual\")]] topsis_name <- result_data$name[[which(result_data$method == \"TOPSIS\")]]  # create object with selected prioritizations solutions  <- bind_cols(   tas_pu,   hierarchical_results %>%     st_drop_geometry() %>%     dplyr::select(all_of(c(visual_name, topsis_name))) %>%     setNames(c(\"Visual\", \"TOPSIS\")),   s6 %>%     st_drop_geometry() %>%     dplyr::select(solution_1) %>%     rename(Cohon = \"solution_1\") )  # plot maps of selected prioritizations plot(   x =     solutions %>%     dplyr::select(Visual, TOPSIS, Cohon) %>%     mutate_if(is.numeric, function(x) {       case_when(         hierarchical_results$locked_in > 0.5 ~ \"locked in\",         x > 0.5 ~ \"priority\",         TRUE ~ \"other\"       )     }),   pal = c(\"purple\", \"grey90\", \"darkgreen\") )"},{"path":"https://prioritizr.net/articles/calibrating_trade-offs_tutorial.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Calibrating trade-offs tutorial","text":"Hopefully, vignette provided useful introduction resolving trade-offs prioritizations. Although explored trade-offs total cost spatial fragmentation tutorial, analysis adapted explore trade-offs wide range different criteria. instance, instead considering total cost primary objective, future analyses explore trade-offs feature representation (using add_min_shortfall_objective() function). Additionally, instead spatial fragmentation, future analyses explore trade-offs directly relate connectivity (using add_connectivity_penalties() function) specific variables interest – ecosystem intactness inverse human footprint index (Williams et al. 2020; Beyer et al. 2019) – inform decision making (using add_linear_penalties() function). Furthermore, identifying best penalty threshold values strike balance multiple criteria, generate portfolio prioritizations (e.g., using add_gap_portfolio_function()) find multiple options achieving similar balance. might helpful need generate set prioritizations comparable performance – terms well achieve different criteria – select different planning units.","code":""},{"path":[]},{"path":"https://prioritizr.net/articles/connectivity_tutorial.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Connectivity tutorial","text":"Connectivity key consideration systematic conservation planning (Margules & Pressey 2000; Briers 2002). isolated fragmented populations often vulnerable extinction (Dixo et al. 2009; Olds et al. 2012; Hodgson et al. 2009). promote connectivity prioritizations, range different approaches available (reviewed Balbar & Metaxas 2019). approaches can rely solely spatial configuration prioritization enhance structural connectivity (e.g, reducing spatial fragmentation prioritization; Watts et al. 2009). can also leverage data – environmental, river flow, telemetry data – generate prioritizations promote functional connectivity (e.g., Hermoso et al. 2012; Dwyer et al. 2019; Leonard et al. 2017). aim tutorial show connectivity can incorporated prioritizations using prioritizr R package. explore various approaches incorporating connectivity, see alter spatial configuration prioritizations. discover, many approaches involve setting threshold penalty values specify relative importance connectivity compared criteria (e.g., overall cost). information calibrating values, please see Calibrating trade-offs tutorial.","code":""},{"path":"https://prioritizr.net/articles/connectivity_tutorial.html","id":"data","dir":"Articles","previous_headings":"","what":"Data","title":"Connectivity tutorial","text":"dataset used tutorial created Coastal Douglas-fir Conservation Partnership (CDFCP; Morrell et al. 2017). Although original dataset covers much larger area; brevity, focus Salt Spring Island, British Columbia. Briefly, Salt Spring Island supports diverse globally unique mix dry forest savanna habitats. Today, habitats critically threatened due land conversion, invasive species, altered disturbance regimes. information data, please refer Marxan tool portal tool tutorial. Extent Coastal Douglas-fir Conservation Partnership Tool area location Salt Spring Island Let’s begin loading packages data tutorial. Since tutorial requires prioritizrdata R package, please ensure installed. Specifically, two objects underpin data tutorial. salt_pu object specifies planning unit data single-layer raster (.e., terra::rast() object), salt_features object contains biodiversity data represented multi-layer raster (.e., terra::rast() object). Now conduct preliminary processing. Specifically, aggregate 100 m resolution 300 m resolution. reduce time needed generate prioritizations tutorial. practice, generally recommend considering criteria – spatial scale relevant decision making resolution available datasets – deciding appropriate scale planning units. Next, let’s look salt_pu object. grid cell represents planning unit, grid cell values denote acquisition costs (BC Assessment 2015). aid visualization, log-transform values plotting map.  Next, let’s look salt_features object. multiple layers. layer corresponds different ecological communities (.e., Old Forest, Savannah, Wetland, Shrub communities), cell values indicate probability encountering bird species associated given community.  Let’s look salt_con object. describes inverse probability occurrence human commensal species. assume human modified areas impede connectivity native species, cells higher values greater connectivity.","code":"# load packages library(prioritizr) library(prioritizrdata) library(sf) library(terra)  # load planning unit data salt_pu <- get_salt_pu()  # load biodiversity feature data salt_features <- get_salt_features()  # load connectivity data salt_con <- get_salt_con() # aggregate data to coarser resolution salt_pu <- aggregate(salt_pu, fact = 3) salt_features <- aggregate(salt_features, fact = 3) salt_con <- aggregate(salt_con, fact = 3) # print planning unit data print(salt_pu) ## class       : SpatRaster  ## dimensions  : 94, 67, 1  (nrow, ncol, nlyr) ## resolution  : 300, 300  (x, y) ## extent      : 454589.9, 474689.9, 5394414, 5422614  (xmin, xmax, ymin, ymax) ## coord. ref. : WGS 84 / UTM zone 10N (EPSG:32610)  ## source(s)   : memory ## name        :       cost  ## min value   :    0.02552  ## max value   : 8290.38317 # plot map showing the planning units costs on a log-scale plot(log(salt_pu), main = \"Planning unit costs (log)\", axes = FALSE) # print feature data print(salt_features) ## class       : SpatRaster  ## dimensions  : 94, 67, 4  (nrow, ncol, nlyr) ## resolution  : 300, 300  (x, y) ## extent      : 454589.9, 474689.9, 5394414, 5422614  (xmin, xmax, ymin, ymax) ## coord. ref. : WGS 84 / UTM zone 10N (EPSG:32610)  ## source(s)   : memory ## names       : old forest,   savanna,   wetland,     shrub  ## min values  :  0.4235421, 0.3355335, 0.1485069, 0.4415211  ## max values  :  0.8951858, 0.6440319, 0.5441603, 0.8065580 # plot map showing the feature data plot(salt_features, axes = FALSE) # print connectivity data print(salt_con) ## class       : SpatRaster  ## dimensions  : 94, 67, 1  (nrow, ncol, nlyr) ## resolution  : 300, 300  (x, y) ## extent      : 454589.9, 474689.9, 5394414, 5422614  (xmin, xmax, ymin, ymax) ## coord. ref. : WGS 84 / UTM zone 10N (EPSG:32610)  ## source(s)   : memory ## name        : inverse human  ## min value   :     0.4060181  ## max value   :     0.8969550 # plot map showing the connectivity data plot(salt_con, axes = FALSE)"},{"path":"https://prioritizr.net/articles/connectivity_tutorial.html","id":"baseline-problem","dir":"Articles","previous_headings":"","what":"Baseline problem","title":"Connectivity tutorial","text":"tutorial, explore different ways incorporating connectivity prioritizations. enable comparisons among prioritizations based different approaches, first create baseline problem formulation subsequently customize incorporate connectivity. Specifically, formulate baseline problem using minimum set objective. use representation targets 17% – based Aichi Biodiversity Target 11 – provide adequate coverage ecological community. Additionally, land properties Salt Spring Island can either acquired entirety , use binary decision types. means planning units either selected solution selected solution—planning units partially acquired. Given details, let’s formulate baseline problem. formulating baseline problem, can solve generate prioritization.  Next, let’s explore options incorporating connectivity.","code":"# create problem p0 <-   problem(salt_pu, salt_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.17) %>%   add_binary_decisions() %>%   add_default_solver()  # print problem print(p0) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"old forest\", \"savanna\", \"wetland\", and \"shrub\" (4 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (2010 total) ## │ ├•costs:      continuous values (between 0.0255 and 8290.3832) ## │ ├•extent:     454589.8809, 5394413.7968, 474689.8809, 5422613.7968 (xmin, ymin, xmax, ymax) ## │ └•CRS:        WGS 84 / UTM zone 10N (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties:   none specified ## │├•targets:     relative targets (between 0.17 and 0.17) ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # solve problem s0 <- solve(p0) # print solution print(s0) ## class       : SpatRaster  ## dimensions  : 94, 67, 1  (nrow, ncol, nlyr) ## resolution  : 300, 300  (x, y) ## extent      : 454589.9, 474689.9, 5394414, 5422614  (xmin, xmax, ymin, ymax) ## coord. ref. : WGS 84 / UTM zone 10N (EPSG:32610)  ## source(s)   : memory ## name        : cost  ## min value   :    0  ## max value   :    1 # plot solution plot(   s0, main = \"Baseline prioritization\", axes = FALSE,   type = \"classes\", col = c(\"grey70\", \"darkgreen\") )"},{"path":"https://prioritizr.net/articles/connectivity_tutorial.html","id":"adding-constraints","dir":"Articles","previous_headings":"","what":"Adding constraints","title":"Connectivity tutorial","text":"Let’s explore approaches promoting connectivity prioritizations adding constraints baseline problem formulation. approaches ensure prioritizations exhibit certain characteristics (e.g., ensure prioritizations form contiguous reserve; Önal & Briers 2006). means , regardless optimality gap used generate prioritization, prioritization always exhibit characteristics.","code":""},{"path":"https://prioritizr.net/articles/connectivity_tutorial.html","id":"neighbor-constraints","dir":"Articles","previous_headings":"Adding constraints","what":"Neighbor constraints","title":"Connectivity tutorial","text":"Neighbor constraints can added ensure selected planning unit certain number neighbors surrounding (using add_neighbor_constraints() function) (based Billionnet 2013). k parameter can used specify required number neighbors selected planning unit. Let’s generate prioritization specifying planning unit requires least three neighbors.","code":"# create problem with added neighbor constraints and solve it s1 <-   p0 %>%   add_neighbor_constraints(k = 3) %>%   solve()  # plot solutions plot(   c(s0, s1), main = c(\"baseline\", \"neighbors constraints\"),   axes = FALSE, type = \"classes\", col = c(\"grey70\", \"darkgreen\") )"},{"path":"https://prioritizr.net/articles/connectivity_tutorial.html","id":"contiguity-constraints","dir":"Articles","previous_headings":"Adding constraints","what":"Contiguity constraints","title":"Connectivity tutorial","text":"Contiguity constraints can added ensure planning units form single contiguous reserve (using add_contiguity_constraints() function) (similar Önal & Briers 2006). constraints extremely complex. , can applied small conservation planning problems Gurobi solver required solve feasible period time. Since take long time generate near-optimal prioritization dataset contiguity constraints, also tell solver simply return first solution finds meets representation targets contiguity constraints.  also even complex version contiguity constraints available. constraints – termed feature contiguity constraints (similar Cerdeira et al. 2010) – can added ensure selected planning units used reach representation targets within prioritization form contiguous network feature (using add_feature_contiguity_constraints() function). words, ensure feature can disperse prioritization access target threshold amount habitat. However, constraints extraordinarily complex, feasible small problems, require preprocessing routines identify initial solutions. , consider tutorial.","code":"# create problem with added contiguity constraints and solve it s2 <-   p0 %>%   add_contiguity_constraints() %>%   add_gurobi_solver(first_feasible = TRUE) %>%   solve() ## Warning: Overwriting previously defined solver. # plot solutions plot(   c(s0, s2), main = c(\"baseline\", \"contiguity constraints\"),   axes = FALSE, type = \"classes\", col = c(\"grey70\", \"darkgreen\") )"},{"path":"https://prioritizr.net/articles/connectivity_tutorial.html","id":"linear-constraints","dir":"Articles","previous_headings":"Adding constraints","what":"Linear constraints","title":"Connectivity tutorial","text":"Linear constraints can used specify prioritizations must meet arbitrary set criteria. , can used ensure prioritizations provide adequate coverage planning units facilitate high level connectivity. Recall salt_con data used describe connectivity across study area. Since higher values denote planning units greater connectivity, use linear constraints ensure total sum connectivity values – based dataset – meets particular threshold (e.g. cover least 30% total amount). effectively treating connectivity additional feature (similar Daigle et al. 2020).  Although using continuous values advantage prioritization process can explicitly account differences relative amount connectivity facilitated different planning units, disadvantage prioritization potentially focus selecting lots planning units low connectivity values. avoid result, one strategy convert continuous values binary values using threshold limit (similar Carroll 2021). applying threshold limit, linear constraints can used ensure prioritization selects minimum amount planning units high connectivity values (.e., connectivity values equal greater threshold limit).   Another strategy clamp continuous values threshold limit assign value zero (similar Hanson et al. 2020). strategy advantage () prioritization won’t focus selecting lots planning units low connectivity values meet constraint threshold, (ii) optimization process can use semi-continuous values distinguish places can facilitate moderate amount high amount connectivity.   concerned prioritization facilitate high enough level connectivity, increase threshold value threshold_limit value. example, let’s increase threshold_limit value used clamp continuous connectivity values.   Despite advantages clamping connectivity values, can see prioritization relatively high level spatial fragmentation. fact, prioritizations generated using linear constraints can potentially issue. linear constraints explicitly account spatial arrangement planning units. , recommend combining linear constraints approach another approach [e.g., boundary penalties approach discussed ; Carroll (2021)].","code":"# compute threshold for constraints ## here we use a threshold of 30% of the total connectivity values threshold <- global(salt_con, \"sum\", na.rm = TRUE)[[1]] * 0.3  # print threshold print(threshold) ## [1] 449.6104 # create problem with added linear constraints and solve it s3 <-   p0 %>%   add_linear_constraints(     data = salt_con, threshold = threshold, sense = \">=\"   ) %>%   solve()  # plot solutions plot(   c(s0, s3), main = c(\"baseline\", \"linear constraints\"),    axes = FALSE, type = \"classes\", col = c(\"grey70\", \"darkgreen\") ) # calculate threshold limit ## here we set a threshold limit based on the median threshold_limit <- global(   salt_con, fun = quantile, na.rm = TRUE, probs = 0.5 )[[1]]  # convert continuous values to binary values salt_con_binary <- round(salt_con >= threshold_limit)  # plot binary values plot(salt_con_binary, main = \"salt_con_binary\", axes = FALSE) # create problem with added linear constraints and solve it ## note that we use the original threshold computed before, ## to ensure the prioritization covers at least 30% of the total amount ## connectivity values s4 <-   p0 %>%   add_linear_constraints(     data = salt_con_binary, threshold = threshold, sense = \">=\"   ) %>%   solve()  # plot solutions plot(   c(s0, s4), main = c(\"baseline\", \"linear constraints (binary)\"),   axes = FALSE, type = \"classes\", col = c(\"grey70\", \"darkgreen\") ) # clamp continuous values using the threshold limit we computed before salt_con_clamp <- salt_con salt_con_clamp[salt_con <= threshold_limit] <- 0  # plot clamped values plot(salt_con_clamp, main = \"salt_con_clamp\", axes = FALSE) # create problem with added linear constraints and solve it ## note that we use the original threshold computed before, ## to ensure the prioritization covers at least 30% of the total amount ## connectivity values s5 <-   p0 %>%   add_linear_constraints(     data = salt_con_clamp, threshold = threshold, sense = \">=\"   ) %>%   solve()  # plot solutions plot(   c(s0, s5), main = c(\"baseline\", \"linear constraints (clamped)\"),   axes = FALSE, type = \"classes\", col = c(\"grey70\", \"darkgreen\") ) # compute threshold limit threshold_limit2 <- global(   salt_con, fun = quantile, na.rm = TRUE, probs = 0.7 )[[1]]  # clamp continuous values using the new threshold limit salt_con_clamp2 <- salt_con salt_con_clamp2[salt_con <= threshold_limit2] <- 0  # plot clamped values plot(salt_con_clamp2, main = \"salt_con_clamp\", axes = FALSE) # create problem with added linear constraints and solve it ## note that we use the original threshold computed before, ## to ensure the prioritization covers at least 30% of the total amount ## connectivity values s6 <-   p0 %>%   add_linear_constraints(     data = salt_con_clamp2, threshold = threshold, sense = \">=\"   ) %>%   solve()  # plot solutions plot(   c(s0, s6), main = c(\"baseline\", \"linear constraints (clamped 2)\"),   axes = FALSE, type = \"classes\", col = c(\"grey70\", \"darkgreen\") )"},{"path":"https://prioritizr.net/articles/connectivity_tutorial.html","id":"adding-penalties","dir":"Articles","previous_headings":"","what":"Adding penalties","title":"Connectivity tutorial","text":"Now let’s explore approaches promoting connectivity prioritizations adding penalties baseline problem formulation. approaches involve penalizing solutions according certain criteria (e.g., penalize spatial fragmentation prioritizations; Watts et al. 2009). Unlike constraint-based methods incorporating connectivity – optimality gap used generate prioritization high – may necessarily produce prioritizations exhibit desirable characteristics.","code":""},{"path":"https://prioritizr.net/articles/connectivity_tutorial.html","id":"boundary-penalties","dir":"Articles","previous_headings":"Adding penalties","what":"Boundary penalties","title":"Connectivity tutorial","text":"Boundary penalties can used reduce spatial fragmentation prioritizations (using add_boundary_penalties() function). Specifically, penalties update problem formulation penalize solutions high total amount exposed boundary length (Ball et al. 2009). Since boundary data often large values can degrade solver performance result excessive run times (see Calibrating trade-offs tutorial details), first rescale boundary data. Next, let’s generate prioritization using boundary penalties. specify relative importance reducing spatial fragmentation – compared primary objective problem (e.g. minimizing cost) – need set value penalty parameter. Setting higher value penalty indicates important avoid highly fragmented solutions. Let’s generate prioritization penalty value 0.001.  can see resulting prioritization still relatively fragmented, let’s try generating another prioritization higher penalty value.  Although prioritization now less fragmented, also selected greater number planning units. Let’s calculate cost prioritizations see vary overall cost. can see cost prioritizations increase use higher penalty values. trade-cost prioritization level spatial fragmentation. Although can challenging find best balance, qualitative quantitative methods available help navigate trade-offs. Please see Calibrating trade-offs tutorial details methods.","code":"# precompute the boundary data salt_boundary_data <- boundary_matrix(salt_pu)  # rescale boundary data salt_boundary_data <- rescale_matrix(salt_boundary_data) # create problem with added boundary penalties s7 <-   p0 %>%   add_boundary_penalties(penalty = 0.001, data = salt_boundary_data) %>%   solve()  # plot solutions plot(   c(s0, s7), main = c(\"baseline\", \"boundary penalties (0.001)\"),   axes = FALSE, type = \"classes\", col = c(\"grey70\", \"darkgreen\") ) # create problem with increased boundary penalties s8 <-   p0 %>%   add_boundary_penalties(penalty = 10, data = salt_boundary_data) %>%   solve()  # plot solutions plot(   c(s0, s8), main = c(\"baseline\", \"boundary penalties (10)\"),   axes = FALSE, type = \"classes\", col = c(\"grey70\", \"darkgreen\") ) # calculate cost of baseline prioritization eval_cost_summary(p0, s0) ## # A tibble: 1 × 2 ##   summary  cost ##   <chr>   <dbl> ## 1 overall  36.0 # calculate cost of prioritization with low boundary penalties (i.e., 0.001) eval_cost_summary(p0, s7) ## # A tibble: 1 × 2 ##   summary  cost ##   <chr>   <dbl> ## 1 overall  46.2 # calculate cost of prioritization high low boundary penalties (i.e., 0.1) eval_cost_summary(p0, s8) ## # A tibble: 1 × 2 ##   summary  cost ##   <chr>   <dbl> ## 1 overall  318."},{"path":"https://prioritizr.net/articles/connectivity_tutorial.html","id":"connectivity-penalties","dir":"Articles","previous_headings":"Adding penalties","what":"Connectivity penalties","title":"Connectivity tutorial","text":"Connectivity penalties can used promote connectivity prioritizations (using add_connectivity_penalties() function). penalties use connectivity scores parametrize strength connectivity pairs planning units (Beger et al. 2010). Thus higher scores denote greater level connectivity different planning units. example, previous studies parametrized connectivity scores using habitat quality, environmental, river flow data (e.g. Leonard et al. 2017; Alagador et al. 2012; Hermoso et al. 2012). Although many approaches calculate connectivity scores, one approach involves using conductance data – data describe much planning unit facilitates movement (opposite landscape resistance data) – calculating scores pair planning units averaging conductance values (implemented using connectivity_matrix() function). Let’s compute connectivity scores treating salt_con object conductance data. means assume neighboring planning units higher values salt_con object capable facilitating greater amount connectivity. Note data used compute connectivity scores must conform spatial properties planning unit data (e.g., resolution, spatial extent, coordinate reference system). Also, although using raster data , scores can also computed vector data (e.g., sf::st_sf() objects). Similar boundary data, also rescale connectivity scores avoid numerical issues optimization. computing connectivity scores, can use generate prioritizations using connectivity penalties. Similar boundary penalties, use penalty parameter specify relative importance promoting connectivity relative primary objective problem (.e., minimizing overall cost). Let’s generate prioritization penalty value 0.001.  Now let’s try generating another prioritization higher penalty value.  can see increasing penalty parameter causes prioritizations select planning units regions greater connectivity values (.e., per salt_con object). discussed boundary penalties, increasing penalty value tells optimization process focus promoting connectivity—meaning won’t focus much primary objective (.e., primary objective minimize overall costs). details calibrating trade-offs please see Calibrating trade-offs tutorial. Note need use eval_connectivity_summary() function – instead eval_boundary_summary() function – adapting tutorial code connectivity penalties.","code":"# compute connectivity scores salt_con_scores <- connectivity_matrix(salt_pu, salt_con)  # rescale scores salt_con_scores <- rescale_matrix(salt_con_scores) # create problem with added connectivity penalties s9 <-   p0 %>%   add_connectivity_penalties(penalty = 0.0001, data = salt_con_scores) %>%   solve()  # plot solutions plot(   c(s0, s9), main = c(\"baseline\", \"connectivity penalties (0.001)\"),   axes = FALSE, type = \"classes\", col = c(\"grey70\", \"darkgreen\") ) # create problem with increased connectivity penalties s10 <-   p0 %>%   add_connectivity_penalties(penalty = 0.0002, data = salt_con_scores) %>%   solve()  # plot solutions plot(   c(s0, s10), main = c(\"baseline\", \"connectivity penalties (0.002)\"),   axes = FALSE, type = \"classes\", col = c(\"grey70\", \"darkgreen\") )"},{"path":"https://prioritizr.net/articles/connectivity_tutorial.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Connectivity tutorial","text":"Hopefully, tutorial provided helpful introduction incorporating connectivity prioritizations. Broadly speaking, recommend using boundary penalties connectivity penalties ensure prioritizations explicitly account spatial configuration selected planning units. Additionally, though fully explored , connectivity penalties flexible approach promoting connectivity. instance, addition parametrizing pair-wise connectivity scores neighboring planning units, can also used parametrize pair-wise connectivity scores distant planning units. Thus connectivity penalties used parametrize connectivity across small large spatial scales (e.g., using scaling procedure wherein connectivity scores pairs planning units decline distance ).","code":""},{"path":[]},{"path":"https://prioritizr.net/articles/gurobi_installation_guide.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Gurobi installation guide","text":"Gurobi powerful fastest solver prioritizr R package can use solve conservation planning problems (see Solver benchmarks vignette details). guide walk process setting Gurobi computer can used solve conservation planning problems. encounter problems following instructions , please refer official Gurobi documentation.","code":""},{"path":"https://prioritizr.net/articles/gurobi_installation_guide.html","id":"obtaining-a-license","dir":"Articles","previous_headings":"","what":"Obtaining a license","title":"Gurobi installation guide","text":"Gurobi commercial computer program. means users need obtain license Gurobi can use . Although academics can obtain special license cost, individuals affiliated recognized educational institution may need purchase license. academic affiliated recognized educational institution, can take advantage special academic license use Gurobi cost. signed free account can request free academic license.  accept Terms Service can generate license.  Now, copy save grbgetkey XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX command later use.","code":""},{"path":"https://prioritizr.net/articles/gurobi_installation_guide.html","id":"downloading-the-software","dir":"Articles","previous_headings":"","what":"Downloading the software","title":"Gurobi installation guide","text":"obtaining license, need download Gurobi installer computer. achieve , visit Gurobi downloads web page download correct version installer operating system.","code":""},{"path":"https://prioritizr.net/articles/gurobi_installation_guide.html","id":"software-installation","dir":"Articles","previous_headings":"","what":"Software installation","title":"Gurobi installation guide","text":"process installing Gurobi software depends operating system computer. Fortunately, Gurobi provide platform-specific “Quick Start Guides” Windows, MacOS, Linux systems help . Briefly, Windows systems, just need double-click Gurobi installer, follow prompts, installer automatically handle everything . Linux MacOS systems, need manually extract downloaded file’s contents folder, move extracted contents suitable location (typically /opt/gurobi), update system’s variables knows find Gurobi (.e., PATH variable). Additionally, using RStudio Linux system, might need add following text Rstudio configuration file (located /etc/rstudio/rserver.conf). installing Gurobi software suite computer, need activate license.","code":"rsession-ld-library-path=/opt/gurobi650/linux64/lib"},{"path":"https://prioritizr.net/articles/gurobi_installation_guide.html","id":"license-activation","dir":"Articles","previous_headings":"","what":"License activation","title":"Gurobi installation guide","text":"Now activate Gurobi software using license obtained earlier. Please note correct set instructions depends system license. activate license, simply copy paste grbgetkey command computer’s command prompt terminal (note Windows users can open command prompt typing cmd search box pressing enter key). running grbgetkey command correct license code, see output resembles following screen shot.  Next, now check license successfully activated. achieve , try running Gurobi directly command line. Note following commands assume using version 8.0.0 Gurobi, need modify command using recent version (e.g., using version 9.1.2, use gurobi912 instead gurobi800 ). Windows systems, users can type following system command check license activation. Linux MacOS systems, users can type following system command. license successfully activated, see output resembles screen shot .  activating license, now need install gurobi R package. can access Gurobi software within R statistical computing environment, enable prioritizr package interface Gurobi software.","code":"gurobi_cl c:\\gurobi800\\win64\\examples\\data\\coins.lp gurobi_cl /opt/gurobi800/linux64/examples/data/coins.lp"},{"path":"https://prioritizr.net/articles/gurobi_installation_guide.html","id":"r-package-installation","dir":"Articles","previous_headings":"","what":"R package installation","title":"Gurobi installation guide","text":"Now install gurobi R package. package available Comprehensive R Archive Network instead distributed Gurobi software suite. Specifically, gurobi R package located within folder installed Gurobi software suite. install gurobi R package running following R code within R session. Note following code assumes using version 8.0.0 Gurobi, need modify code using recent version (e.g., using version 9.1.2, use gurobi912 instead gurobi800 ). Assuming installed Gurobi default location, Windows users can install gurobi R package using following code. Similarly, Linux MacOS users can install gurobi R package using following code. Next, need install slam R package gurobi R package needs package work. Users platforms (.e., Windows, Linux, MacOS) can install package using following R code. Let’s check gurobi R package successfully installed. , can try using gurobi R package solve optimization problem. Copy paste R code R. see outputs result$objval result$x don’t see error messages, (1) successfully installed Gurobi software suite, (2) activated valid license, (3) successfully installed gurobi R package. see error message, might missed previous step something might gone wrong installing Gurobi activating license. cases, try going back vignette repeating previous steps see fixes issue.","code":"install.packages(\"c:/gurobi800/win64/R/gurobi_8.0-0.zip\", repos = NULL) install.packages(   file.path(     Sys.getenv(\"GUROBI_HOME\"),     \"R/gurobi_8.0-0_R_x86_64-pc-linux-gnu.tar.gz\"   ),   repos = NULL ) install.packages(\"slam\", repos = \"https://cloud.r-project.org\") # load gurobi package library(gurobi) ## Loading required package: slam # create optimization problem model <- list() model$obj        <- c(1, 1, 2) model$modelsense <- \"max\" model$rhs        <- c(4, 1) model$sense      <- c(\"<\", \">\") model$vtype      <- \"B\" model$A          <- matrix(c(1, 2, 3, 1, 1, 0), nrow = 2, ncol = 3,                            byrow = TRUE)  # solve the optimization problem using Gurobi result <- gurobi(model, list()) ## Gurobi Optimizer version 10.0.2 build v10.0.2rc0 (linux64) ##  ## CPU model: 11th Gen Intel(R) Core(TM) i7-1185G7 @ 3.00GHz, instruction set [SSE2|AVX|AVX2|AVX512] ## Thread count: 4 physical cores, 8 logical processors, using up to 8 threads ##  ## Optimize a model with 2 rows, 3 columns and 5 nonzeros ## Model fingerprint: 0xba2d0add ## Variable types: 0 continuous, 3 integer (3 binary) ## Coefficient statistics: ##   Matrix range     [1e+00, 3e+00] ##   Objective range  [1e+00, 2e+00] ##   Bounds range     [0e+00, 0e+00] ##   RHS range        [1e+00, 4e+00] ## Found heuristic solution: objective 2.0000000 ## Presolve removed 2 rows and 3 columns ## Presolve time: 0.00s ## Presolve: All rows and columns removed ##  ## Explored 0 nodes (0 simplex iterations) in 0.00 seconds (0.00 work units) ## Thread count was 1 (of 8 available processors) ##  ## Solution count 2: 3 2  ##  ## Optimal solution found (tolerance 1.00e-04) ## Best objective 3.000000000000e+00, best bound 3.000000000000e+00, gap 0.0000% # print the solution print(result$objval) # objective ## [1] 3 print(result$x)      # decision variables ## [1] 1 0 1"},{"path":"https://prioritizr.net/articles/gurobi_installation_guide.html","id":"solving-a-prioritzr-problem-with-gurobi","dir":"Articles","previous_headings":"","what":"Solving a prioritzr problem with Gurobi","title":"Gurobi installation guide","text":"successfully installed Gurobi software suite gurobi R package, can now try solving conservation planning problems using prioritzr R package. Although prioritizr R package automatically detect Gurobi installed, can use function add_gurobi_solver() manually specify Gurobi used solve problems. function also useful can use customize optimization process (e.g., specify desired optimality gap set limit much time spent searching solution). Finally, check everything installed correctly, use Gurobi software suite solve reserve selection problem created using prioritzr R package.  running code, hopefully, information printed -screen optimization process R produce map displaying solution. code produce errors, successfully installed everything can begin using Gurobi prioritizr R package solve conservation planning problems.","code":"# load package library(prioritizr) ## The legacy packages maptools, rgdal, and rgeos, underpinning the sp package, ## which was just loaded, will retire in October 2023. ## Please refer to R-spatial evolution reports for details, especially ## https://r-spatial.org/r/2023/05/15/evolution4.html. ## It may be desirable to make the sf package available; ## package maintainers should consider adding sf to Suggests:. ## The sp package is now running under evolution status 2 ##      (status 2 uses the sf package in place of rgdal) # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features()  # formulate the problem p <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_gurobi_solver()  # solve the problem s <- solve(p) ## Gurobi Optimizer version 10.0.2 build v10.0.2rc0 (linux64) ##  ## CPU model: 11th Gen Intel(R) Core(TM) i7-1185G7 @ 3.00GHz, instruction set [SSE2|AVX|AVX2|AVX512] ## Thread count: 4 physical cores, 8 logical processors, using up to 1 threads ##  ## Optimize a model with 5 rows, 90 columns and 450 nonzeros ## Model fingerprint: 0x4bb5d283 ## Variable types: 0 continuous, 90 integer (90 binary) ## Coefficient statistics: ##   Matrix range     [2e-01, 9e-01] ##   Objective range  [2e+02, 2e+02] ##   Bounds range     [1e+00, 1e+00] ##   RHS range        [3e+00, 8e+00] ## Found heuristic solution: objective 2337.9617767 ## Presolve time: 0.00s ## Presolved: 5 rows, 90 columns, 450 nonzeros ## Variable types: 0 continuous, 90 integer (90 binary) ## Found heuristic solution: objective 2332.1004028 ## Root relaxation presolved: 5 rows, 90 columns, 450 nonzeros ##  ##  ## Root relaxation: objective 1.931582e+03, 12 iterations, 0.00 seconds (0.00 work units) ##  ##     Nodes    |    Current Node    |     Objective Bounds      |     Work ##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time ##  ##      0     0 1931.58191    0    4 2332.10040 1931.58191  17.2%     -    0s ## H    0     0                    1987.3985291 1931.58191  2.81%     -    0s ##  ## Explored 1 nodes (12 simplex iterations) in 0.00 seconds (0.00 work units) ## Thread count was 1 (of 8 available processors) ##  ## Solution count 3: 1987.4 2332.1 2337.96  ##  ## Optimal solution found (tolerance 1.00e-01) ## Best objective 1.987398529053e+03, best bound 1.931581907658e+03, gap 2.8085% # plot solution plot(   s, col = c(\"grey90\", \"darkgreen\"), main = \"Solution\",   xlim = c(-0.1, 1.1), ylim = c(-0.1, 1.1) )"},{"path":"https://prioritizr.net/articles/management_zones_tutorial.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Management zones tutorial","text":"One main aims conservation planning identify cost-effective set areas manage biodiversity (Margules & Pressey 2000). achieve , prioritizations generally created identify areas expanding protected area systems. However, many real-world conservation problems simply involve deciding area protected (e.g., Klein et al. 2009; Stigner et al. 2016). Instead, many problems involve range different management categories goal determine areas allocated management category. example, manager might range different methods (e.g., baiting trapping various intensities) controlling invasive pests set different areas (e.g., Cattarino et al. 2018). need prioritization shows control methods implemented areas. particular case, binary prioritization showing areas contain biodiversity simply helpful. Furthermore, many real-world problems require decisions meet multiple, sometimes conflicting, objectives different stakeholders. example, manager might need implement set -take partial-take areas prevent overfishing, also ensure still remain plenty areas fishing activities (e.g., Wilson et al. 2010; Klein et al. 2013). Popularized Marxan Zones decision support tool (Watts et al. 2009), concept become known “zones” becoming increasingly important conservation planning. aim tutorial showcase zones functionality prioritizr R package. assume certain level familiarity conservation planning terminology package. don’t much experience either topics, recommend first reading Package overview vignette.","code":""},{"path":[]},{"path":"https://prioritizr.net/articles/management_zones_tutorial.html","id":"simple-minimum-set-problem","dir":"Articles","previous_headings":"Usage","what":"Simple minimum set problem","title":"Management zones tutorial","text":"prioritizr R package, conservation planning problems – including contain multiple management zones actions – initialized using problem function. refresh memory can construct problems, let us quickly construct simple conservation planning problem. problem use simulated built-planning unit feature data distributed package. minimum set objective, targets require solutions secure 10% habitat study area feature, binary decision variables indicating planning units selected selected protection.","code":"# load packages library(prioritizr) ## The legacy packages maptools, rgdal, and rgeos, underpinning the sp package, ## which was just loaded, will retire in October 2023. ## Please refer to R-spatial evolution reports for details, especially ## https://r-spatial.org/r/2023/05/15/evolution4.html. ## It may be desirable to make the sf package available; ## package maintainers should consider adding sf to Suggests:. ## The sp package is now running under evolution status 2 ##      (status 2 uses the sf package in place of rgdal) library(terra) ## terra 1.7.39 library(tibble) # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features()  # create targets for each of the five features t1 <- rep(0.1, 5)  # build single-zone problem p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(t1) %>%   add_binary_decisions()  # print problem print(p1) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties:   none specified ## │├•targets:     relative targets (between 0.1 and 0.1) ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # solve problem s1 <- solve(p1) ## Gurobi Optimizer version 10.0.2 build v10.0.2rc0 (linux64) ##  ## CPU model: 11th Gen Intel(R) Core(TM) i7-1185G7 @ 3.00GHz, instruction set [SSE2|AVX|AVX2|AVX512] ## Thread count: 4 physical cores, 8 logical processors, using up to 1 threads ##  ## Optimize a model with 5 rows, 90 columns and 450 nonzeros ## Model fingerprint: 0x4bb5d283 ## Variable types: 0 continuous, 90 integer (90 binary) ## Coefficient statistics: ##   Matrix range     [2e-01, 9e-01] ##   Objective range  [2e+02, 2e+02] ##   Bounds range     [1e+00, 1e+00] ##   RHS range        [3e+00, 8e+00] ## Found heuristic solution: objective 2337.9617767 ## Presolve time: 0.00s ## Presolved: 5 rows, 90 columns, 450 nonzeros ## Variable types: 0 continuous, 90 integer (90 binary) ## Found heuristic solution: objective 2332.1004028 ## Root relaxation presolved: 5 rows, 90 columns, 450 nonzeros ##  ##  ## Root relaxation: objective 1.931582e+03, 12 iterations, 0.00 seconds (0.00 work units) ##  ##     Nodes    |    Current Node    |     Objective Bounds      |     Work ##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time ##  ##      0     0 1931.58191    0    4 2332.10040 1931.58191  17.2%     -    0s ## H    0     0                    1987.3985291 1931.58191  2.81%     -    0s ##  ## Explored 1 nodes (12 simplex iterations) in 0.00 seconds (0.00 work units) ## Thread count was 1 (of 8 available processors) ##  ## Solution count 3: 1987.4 2332.1 2337.96  ##  ## Optimal solution found (tolerance 1.00e-01) ## Best objective 1.987398529053e+03, best bound 1.931581907658e+03, gap 2.8085% # calculate feature representation r1 <- eval_feature_representation_summary(p1, s1) print(r1) ## # A tibble: 5 × 5 ##   summary feature   total_amount absolute_held relative_held ##   <chr>   <chr>            <dbl>         <dbl>         <dbl> ## 1 overall feature_1         83.3          8.91         0.107 ## 2 overall feature_2         31.2          3.13         0.100 ## 3 overall feature_3         72.0          7.34         0.102 ## 4 overall feature_4         42.7          4.35         0.102 ## 5 overall feature_5         56.7          6.01         0.106 # plot solution plot(   s1, main = \"solution\",   xlim = c(-0.1, 1.1), ylim = c(-0.1, 1.1), axes = FALSE )"},{"path":"https://prioritizr.net/articles/management_zones_tutorial.html","id":"adding-management-zones","dir":"Articles","previous_headings":"Usage","what":"Adding management zones","title":"Management zones tutorial","text":"Now let us imagine instead single management zone (e.g., protected area), two management zones. Similar example , require solution secures 10 % habitat study area feature first management zone. also require solution secures 5 % habitat study area feature second management zone. planning unit must allocated either zone selected management . example, planning unit costs allocated either two zones. can formulate solve problem using following code.","code":"# create a matrix with the targets # here each column corresponds to a different zone, # each row corresponds to a different feature, and # each cell value corresponds to the target t2 <- matrix(NA, ncol = 2, nrow = 5) t2[, 1] <- 0.1 t2[, 2] <- 0.05  # print targets print(t2) ##      [,1] [,2] ## [1,]  0.1 0.05 ## [2,]  0.1 0.05 ## [3,]  0.1 0.05 ## [4,]  0.1 0.05 ## [5,]  0.1 0.05 # create a zones object that contains the amount of each feature # in each planning unit when it is allocated to each zone # since our zones pertain to the same habitat data, we will # specify the same habitat data for each zone z2 <- zones(\"zone 1\" = sim_features, \"zone 2\" = sim_features)  # print zones print(z2) ## A zones object <ZonesSpatRaster/Zones> ## • zones:    \"zone 1\" and \"zone 2\" (2 total) ## • features: \"1\", \"2\", \"3\", \"4\", and \"5\" (5 total) # create a multi-layer raster with the planning unit data ## since our planning unit costs are the same for each zone, ## we will create a raster with two replicates of the cost data pu2 <- c(sim_pu_raster, sim_pu_raster)  # print planning units print(pu2) ## class       : SpatRaster  ## dimensions  : 10, 10, 2  (nrow, ncol, nlyr) ## resolution  : 0.1, 0.1  (x, y) ## extent      : 0, 1, 0, 1  (xmin, xmax, ymin, ymax) ## coord. ref. : Undefined Cartesian SRS  ## sources     : sim_pu_raster.tif   ##               sim_pu_raster.tif   ## names       :    layer,    layer  ## min values  : 190.1328, 190.1328  ## max values  : 215.8638, 215.8638 # build two-zone problem p2 <-   problem(pu2, z2) %>%   add_min_set_objective() %>%   add_relative_targets(t2) %>%   add_binary_decisions()  # print problem print(p2) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•zones:       \"zone 1\" and \"zone 2\" (2 total) ## │├•features:    \"1\", \"2\", \"3\", \"4\", and \"5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties:   none specified ## │├•targets:     relative targets (between 0.05 and 0.1) ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # solve problem s2 <- solve(p2) ## Gurobi Optimizer version 10.0.2 build v10.0.2rc0 (linux64) ##  ## CPU model: 11th Gen Intel(R) Core(TM) i7-1185G7 @ 3.00GHz, instruction set [SSE2|AVX|AVX2|AVX512] ## Thread count: 4 physical cores, 8 logical processors, using up to 1 threads ##  ## Optimize a model with 100 rows, 180 columns and 1080 nonzeros ## Model fingerprint: 0x5c140ae3 ## Variable types: 0 continuous, 180 integer (180 binary) ## Coefficient statistics: ##   Matrix range     [2e-01, 1e+00] ##   Objective range  [2e+02, 2e+02] ##   Bounds range     [1e+00, 1e+00] ##   RHS range        [1e+00, 8e+00] ## Found heuristic solution: objective 3568.4931335 ## Presolve time: 0.00s ## Presolved: 100 rows, 180 columns, 1080 nonzeros ## Variable types: 0 continuous, 180 integer (180 binary) ## Found heuristic solution: objective 3440.6550903 ## Root relaxation presolved: 100 rows, 180 columns, 1080 nonzeros ##  ##  ## Root relaxation: objective 2.911333e+03, 75 iterations, 0.00 seconds (0.00 work units) ##  ##     Nodes    |    Current Node    |     Objective Bounds      |     Work ##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time ##  ##      0     0 2911.33336    0   10 3440.65509 2911.33336  15.4%     -    0s ## H    0     0                    2996.1175232 2911.33336  2.83%     -    0s ##  ## Explored 1 nodes (79 simplex iterations) in 0.00 seconds (0.00 work units) ## Thread count was 1 (of 8 available processors) ##  ## Solution count 3: 2996.12 3440.66 3568.49  ##  ## Optimal solution found (tolerance 1.00e-01) ## Best objective 2.996117523193e+03, best bound 2.911333356299e+03, gap 2.8298% # calculate feature representation r2 <- eval_feature_representation_summary(p2, s2) print(r2) ## # A tibble: 15 × 5 ##    summary feature total_amount absolute_held relative_held ##    <chr>   <chr>          <dbl>         <dbl>         <dbl> ##  1 overall 1              167.          13.4         0.0803 ##  2 overall 2               62.4          4.77        0.0765 ##  3 overall 3              144.          10.9         0.0758 ##  4 overall 4               85.3          6.41        0.0751 ##  5 overall 5              113.           9.06        0.0799 ##  6 zone 1  1               83.3          8.87        0.106  ##  7 zone 1  2               31.2          3.21        0.103  ##  8 zone 1  3               72.0          7.21        0.100  ##  9 zone 1  4               42.7          4.27        0.100  ## 10 zone 1  5               56.7          6.03        0.106  ## 11 zone 2  1               83.3          4.50        0.0541 ## 12 zone 2  2               31.2          1.56        0.0500 ## 13 zone 2  3               72.0          3.70        0.0515 ## 14 zone 2  4               42.7          2.14        0.0501 ## 15 zone 2  5               56.7          3.03        0.0533 # plot solution # here we use the category layer function to generate raster showing the zone # that each planning unit was allocated. Specifically, pixels with the # value 1 (yellow) are allocated to \"zone 1\" and pixels with the value 2 (green) # are allocated to \"zone 2\". Units depicted in gray are not allocated # to any zone. plot(   category_layer(s2), main = \"solution\",   xlim = c(-0.1, 1.1), ylim = c(-0.1, 1.1), axes = FALSE )"},{"path":"https://prioritizr.net/articles/management_zones_tutorial.html","id":"multiple-zones-with-varying-costs","dir":"Articles","previous_headings":"Usage","what":"Multiple zones with varying costs","title":"Management zones tutorial","text":"Real-world problems often different costs managing planning units different zones. problems also tend different expected amounts feature planning units managed differently. let us consider slightly complex example. Similar two management zones. time, cost managing planning unit different depending management zone assigned solution. Furthermore, assign planning unit second zone, expect end half habitat get managed unit first zone (e.g., second zone partial-take zone first zone -take zone). use target data previous example.","code":"# create new planning unit and cost data pu3 <- get_sim_zones_pu_raster()[[1:2]]  # plot cost data plot(   pu3, main = c(\"zone 1\", \"zone 2\"),   xlim = c(-0.1, 1.1), ylim = c(-0.1, 1.1), axes = FALSE ) # create problem p3 <-   problem(pu3, zones(sim_features, sim_features * 0.5)) %>%   add_min_set_objective() %>%   add_relative_targets(t2) %>%   add_binary_decisions()  # print problem print(p3) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•zones:       \"1\" and \"2\" (2 total) ## │├•features:    \"1\", \"2\", \"3\", \"4\", and \"5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 182.6017 and 221.363) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties:   none specified ## │├•targets:     relative targets (between 0.05 and 0.1) ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # solve problem s3 <- solve(p3) ## Gurobi Optimizer version 10.0.2 build v10.0.2rc0 (linux64) ##  ## CPU model: 11th Gen Intel(R) Core(TM) i7-1185G7 @ 3.00GHz, instruction set [SSE2|AVX|AVX2|AVX512] ## Thread count: 4 physical cores, 8 logical processors, using up to 1 threads ##  ## Optimize a model with 100 rows, 180 columns and 1080 nonzeros ## Model fingerprint: 0xdfa75166 ## Variable types: 0 continuous, 180 integer (180 binary) ## Coefficient statistics: ##   Matrix range     [1e-01, 1e+00] ##   Objective range  [2e+02, 2e+02] ##   Bounds range     [1e+00, 1e+00] ##   RHS range        [8e-01, 8e+00] ## Found heuristic solution: objective 3667.7708740 ## Presolve time: 0.00s ## Presolved: 100 rows, 180 columns, 1080 nonzeros ## Variable types: 0 continuous, 180 integer (180 binary) ## Found heuristic solution: objective 3388.0249329 ## Root relaxation presolved: 100 rows, 180 columns, 1080 nonzeros ##  ##  ## Root relaxation: objective 2.884872e+03, 38 iterations, 0.00 seconds (0.00 work units) ##  ##     Nodes    |    Current Node    |     Objective Bounds      |     Work ##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time ##  ##      0     0 2884.87201    0    8 3388.02493 2884.87201  14.9%     -    0s ## H    0     0                    2958.1201477 2884.87201  2.48%     -    0s ##  ## Explored 1 nodes (38 simplex iterations) in 0.00 seconds (0.00 work units) ## Thread count was 1 (of 8 available processors) ##  ## Solution count 3: 2958.12 3388.02 3667.77  ##  ## Optimal solution found (tolerance 1.00e-01) ## Best objective 2.958120147705e+03, best bound 2.884872007846e+03, gap 2.4762% # calculate feature representation r3 <- eval_feature_representation_summary(p3, s3) print(r3) ## # A tibble: 15 × 5 ##    summary feature total_amount absolute_held relative_held ##    <chr>   <chr>          <dbl>         <dbl>         <dbl> ##  1 overall 1              125.         11.1          0.0891 ##  2 overall 2               46.8         3.92         0.0838 ##  3 overall 3              108.          9.28         0.0860 ##  4 overall 4               64.0         5.37         0.0839 ##  5 overall 5               85.1         7.46         0.0877 ##  6 1       1               83.3         8.94         0.107  ##  7 1       2               31.2         3.13         0.100  ##  8 1       3               72.0         7.42         0.103  ##  9 1       4               42.7         4.29         0.101  ## 10 1       5               56.7         6.01         0.106  ## 11 2       1               41.6         2.19         0.0527 ## 12 2       2               15.6         0.794        0.0509 ## 13 2       3               36.0         1.87         0.0519 ## 14 2       4               21.3         1.08         0.0505 ## 15 2       5               28.4         1.44         0.0509 # plot solution plot(   category_layer(s3), main = \"solution\",   xlim = c(-0.1, 1.1), ylim = c(-0.1, 1.1), axes = FALSE )"},{"path":"https://prioritizr.net/articles/management_zones_tutorial.html","id":"multiple-zones-with-complex-targets","dir":"Articles","previous_headings":"Usage","what":"Multiple zones with complex targets","title":"Management zones tutorial","text":"far, dealt problems feature target pertains single zone. sometimes targets pertain multiple zones. example, charge managing pest control set areas three different pest control methods implement given planning unit. () set traps given planning unit make 10 % habitat unit pest-free, (ii) set lot traps make 50 % habitat unit pest-free, (iii) drop baits given planning unit make 80 % planning unit pest-free. different actions different cost, low intensity trapping costing $100 per planning unit, high intensity trapping costing $300, baiting costing $200 (please note costs aren’t meant realistic). defining management actions costs, require solution yield 8 units pest free habitat per feature. ’s important note unlike previous examples, don’t targets feature zone, rather targets feature across multiple zones. words, don’t really care management actions implement, just want set actions meet targets minimum expenditure. can formulate solve problem using following code.","code":"# create planning unit data with costs pu4 <- c(   as.int(!is.na(sim_pu_raster)) * 100,   as.int(!is.na(sim_pu_raster)) * 300,   as.int(!is.na(sim_pu_raster)) * 200 ) names(pu4) <- c(\"few traps\", \"many traps\", \"baiting\")  # plot planning unit data plot(   pu4, nr = 1,   xlim = c(-0.1, 1.1), ylim = c(-0.1, 1.1), axes = FALSE ) # create targets t4 <- tibble(   feature = names(sim_features),   zone = list(names(pu4))[rep(1, 5)],   target = rep(8, 5),   type = rep(\"absolute\", 5) )  # print targets print(t4) ## # A tibble: 5 × 4 ##   feature   zone      target type     ##   <chr>     <list>     <dbl> <chr>    ## 1 feature_1 <chr [3]>      8 absolute ## 2 feature_2 <chr [3]>      8 absolute ## 3 feature_3 <chr [3]>      8 absolute ## 4 feature_4 <chr [3]>      8 absolute ## 5 feature_5 <chr [3]>      8 absolute # create problem p4 <-   problem(     pu4,     zones(       sim_features * 0.1,       sim_features * 0.5,       sim_features * 0.8,       zone_names = names(pu4),       feature_names = names(sim_features)     )   ) %>%   add_min_set_objective() %>%   add_manual_targets(t4) %>%   add_binary_decisions()  # print problem print(p4) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•zones:       \"few traps\", \"many traps\", and \"baiting\" (3 total) ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (100 total) ## │ ├•costs:      continuous values (between 0 and 300) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties:   none specified ## │├•targets:     absolute targets (between 8 and 8) ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # solve problem s4 <- solve(p4) ## Gurobi Optimizer version 10.0.2 build v10.0.2rc0 (linux64) ##  ## CPU model: 11th Gen Intel(R) Core(TM) i7-1185G7 @ 3.00GHz, instruction set [SSE2|AVX|AVX2|AVX512] ## Thread count: 4 physical cores, 8 logical processors, using up to 1 threads ##  ## Optimize a model with 105 rows, 300 columns and 1800 nonzeros ## Model fingerprint: 0xba527df5 ## Variable types: 0 continuous, 300 integer (300 binary) ## Coefficient statistics: ##   Matrix range     [2e-02, 1e+00] ##   Objective range  [1e+02, 3e+02] ##   Bounds range     [1e+00, 1e+00] ##   RHS range        [1e+00, 8e+00] ## Found heuristic solution: objective 9400.0000000 ## Presolve removed 14 rows and 120 columns ## Presolve time: 0.00s ## Presolved: 91 rows, 180 columns, 360 nonzeros ## Found heuristic solution: objective 4700.0000000 ## Variable types: 0 continuous, 180 integer (180 binary) ## Root relaxation presolved: 91 rows, 180 columns, 360 nonzeros ##  ##  ## Root relaxation: objective 3.663237e+03, 1 iterations, 0.00 seconds (0.00 work units) ##  ##     Nodes    |    Current Node    |     Objective Bounds      |     Work ##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time ##  ##      0     0 3663.23656    0    1 4700.00000 3663.23656  22.1%     -    0s ## H    0     0                    3800.0000000 3663.23656  3.60%     -    0s ##  ## Explored 1 nodes (1 simplex iterations) in 0.00 seconds (0.00 work units) ## Thread count was 1 (of 8 available processors) ##  ## Solution count 3: 3800 4700 9400  ##  ## Optimal solution found (tolerance 1.00e-01) ## Best objective 3.800000000000e+03, best bound 3.700000000000e+03, gap 2.6316% # calculate feature representation r4 <- eval_feature_representation_summary(p4, s4) print(r4) ## # A tibble: 20 × 5 ##    summary    feature   total_amount absolute_held relative_held ##    <chr>      <chr>            <dbl>         <dbl>         <dbl> ##  1 overall    feature_1       117.           18.3          0.157 ##  2 overall    feature_2        43.7           8.19         0.187 ##  3 overall    feature_3       101.           15.2          0.151 ##  4 overall    feature_4        59.7          11.6          0.194 ##  5 overall    feature_5        79.4          12.7          0.161 ##  6 few traps  feature_1         8.33          0            0     ##  7 few traps  feature_2         3.12          0            0     ##  8 few traps  feature_3         7.20          0            0     ##  9 few traps  feature_4         4.27          0            0     ## 10 few traps  feature_5         5.67          0            0     ## 11 many traps feature_1        41.6           0            0     ## 12 many traps feature_2        15.6           0            0     ## 13 many traps feature_3        36.0           0            0     ## 14 many traps feature_4        21.3           0            0     ## 15 many traps feature_5        28.4           0            0     ## 16 baiting    feature_1        66.6          18.3          0.275 ## 17 baiting    feature_2        25.0           8.19         0.328 ## 18 baiting    feature_3        57.6          15.2          0.264 ## 19 baiting    feature_4        34.1          11.6          0.340 ## 20 baiting    feature_5        45.4          12.7          0.281 # plot solution plot(category_layer(s4), main = \"solution\", axes = FALSE)"},{"path":"https://prioritizr.net/articles/management_zones_tutorial.html","id":"multiple-zones-with-extra-constraints","dir":"Articles","previous_headings":"Usage","what":"Multiple zones with extra constraints","title":"Management zones tutorial","text":"looks like baiting way go! Except might recall can’t use baits planning units contain native species susceptible baits. now need specify planning units assigned third zone (baiting) obtain useful solution.","code":"# create data.frame to specify that we cannot bait in the first 80 units l5 <- tibble(pu = seq(1, 80), zone = \"baiting\", status = 0)  # preview locked data head(l5) ## # A tibble: 6 × 3 ##      pu zone    status ##   <int> <chr>    <dbl> ## 1     1 baiting      0 ## 2     2 baiting      0 ## 3     3 baiting      0 ## 4     4 baiting      0 ## 5     5 baiting      0 ## 6     6 baiting      0 # create problem p5 <-   problem(     pu4,     zones(       sim_features * 0.1,       sim_features * 0.5,       sim_features * 0.8,       zone_names = names(pu4),       feature_names = names(sim_features)     )   ) %>%   add_min_set_objective() %>%   add_manual_targets(t4) %>%   add_manual_locked_constraints(l5) %>%   add_binary_decisions()  # print problem print(p5) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•zones:       \"few traps\", \"many traps\", and \"baiting\" (3 total) ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (100 total) ## │ ├•costs:      continuous values (between 0 and 300) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties:   none specified ## │├•targets:     absolute targets (between 8 and 8) ## │├•constraints: ## ││└•1:          manual locked constraints (80 planning units) ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # solve problem s5 <- solve(p5) ## Gurobi Optimizer version 10.0.2 build v10.0.2rc0 (linux64) ##  ## CPU model: 11th Gen Intel(R) Core(TM) i7-1185G7 @ 3.00GHz, instruction set [SSE2|AVX|AVX2|AVX512] ## Thread count: 4 physical cores, 8 logical processors, using up to 1 threads ##  ## Optimize a model with 105 rows, 300 columns and 1800 nonzeros ## Model fingerprint: 0x0d87ce25 ## Variable types: 0 continuous, 300 integer (300 binary) ## Coefficient statistics: ##   Matrix range     [2e-02, 1e+00] ##   Objective range  [1e+02, 3e+02] ##   Bounds range     [1e+00, 1e+00] ##   RHS range        [1e+00, 8e+00] ## Found heuristic solution: objective 13600.000000 ## Presolve removed 14 rows and 120 columns ## Presolve time: 0.00s ## Presolved: 91 rows, 180 columns, 360 nonzeros ## Found heuristic solution: objective 9600.0000000 ## Variable types: 0 continuous, 180 integer (180 binary) ## Root relaxation presolved: 91 rows, 180 columns, 360 nonzeros ##  ##  ## Root relaxation: objective 6.938068e+03, 1 iterations, 0.00 seconds (0.00 work units) ##  ##     Nodes    |    Current Node    |     Objective Bounds      |     Work ##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time ##  ##      0     0 6938.06815    0    1 9600.00000 6938.06815  27.7%     -    0s ## H    0     0                    7000.0000000 6938.06815  0.88%     -    0s ##      0     0 6938.06815    0    1 7000.00000 6938.06815  0.88%     -    0s ##  ## Explored 1 nodes (1 simplex iterations) in 0.00 seconds (0.00 work units) ## Thread count was 1 (of 8 available processors) ##  ## Solution count 3: 7000 9600 13600  ##  ## Optimal solution found (tolerance 1.00e-01) ## Best objective 7.000000000000e+03, best bound 7.000000000000e+03, gap 0.0000% # calculate feature representation r5 <- eval_feature_representation_summary(p5, s5) print(r5) ## # A tibble: 20 × 5 ##    summary    feature   total_amount absolute_held relative_held ##    <chr>      <chr>            <dbl>         <dbl>         <dbl> ##  1 overall    feature_1       117.           21.8          0.187 ##  2 overall    feature_2        43.7           8.04         0.184 ##  3 overall    feature_3       101.           17.7          0.176 ##  4 overall    feature_4        59.7          10.9          0.182 ##  5 overall    feature_5        79.4          15.2          0.192 ##  6 few traps  feature_1         8.33          0            0     ##  7 few traps  feature_2         3.12          0            0     ##  8 few traps  feature_3         7.20          0            0     ##  9 few traps  feature_4         4.27          0            0     ## 10 few traps  feature_5         5.67          0            0     ## 11 many traps feature_1        41.6           7.40         0.178 ## 12 many traps feature_2        15.6           3.42         0.219 ## 13 many traps feature_3        36.0           6.00         0.167 ## 14 many traps feature_4        21.3           4.84         0.227 ## 15 many traps feature_5        28.4           5.26         0.186 ## 16 baiting    feature_1        66.6          14.4          0.217 ## 17 baiting    feature_2        25.0           4.62         0.185 ## 18 baiting    feature_3        57.6          11.7          0.203 ## 19 baiting    feature_4        34.1           6.05         0.177 ## 20 baiting    feature_5        45.4           9.98         0.220 # plot solution plot(category_layer(s5), main = \"solution\", axes = FALSE)"},{"path":"https://prioritizr.net/articles/management_zones_tutorial.html","id":"multiple-zones-with-fragmentation-penalties","dir":"Articles","previous_headings":"Usage","what":"Multiple zones with fragmentation penalties","title":"Management zones tutorial","text":"now best strategy seems combination high intensity trapping baiting. can also see solution fairly fragmented, can add penalties cluster managed planning units together. add penalties cluster planning units allocated two trapping zones together, penalties cluster planning units allocated baiting zone together. also set overall penalty factor 640 strongly penalize fragmented solutions.  Finally, appears might viable solution made-conservation problem.","code":"# create matrix that describes boundary penalties between planning units # allocated to different zones z6 <- diag(3) z6[1, 2] <- 1 z6[2, 1] <- 1 colnames(z6) <- c(\"few traps\", \"many traps\", \"baiting\") rownames(z6) <- colnames(z6)  # print matrix print(z6) ##            few traps many traps baiting ## few traps          1          1       0 ## many traps         1          1       0 ## baiting            0          0       1 # create problem p6 <-   problem(     pu4,     zones(       sim_features * 0.1,       sim_features * 0.5,       sim_features * 0.8,       zone_names = names(pu4),       feature_names = names(sim_features)     )   ) %>%   add_min_set_objective() %>%   add_manual_targets(t4) %>%   add_manual_locked_constraints(l5) %>%   add_boundary_penalties(penalty = 640, zones = z6) %>%   add_binary_decisions()  # print problem print(p6) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•zones:       \"few traps\", \"many traps\", and \"baiting\" (3 total) ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (100 total) ## │ ├•costs:      continuous values (between 0 and 300) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties: ## ││└•1:          boundary penalties (`penalty` = 640, `edge_factor` = 0.5, 0.5, and 0.5, …) ## │├•targets:     absolute targets (between 8 and 8) ## │├•constraints: ## ││└•1:          manual locked constraints (80 planning units) ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # solve problem s6 <- solve(p6) ## Gurobi Optimizer version 10.0.2 build v10.0.2rc0 (linux64) ##  ## CPU model: 11th Gen Intel(R) Core(TM) i7-1185G7 @ 3.00GHz, instruction set [SSE2|AVX|AVX2|AVX512] ## Thread count: 4 physical cores, 8 logical processors, using up to 1 threads ##  ## Optimize a model with 1905 rows, 1200 columns and 5400 nonzeros ## Model fingerprint: 0xcf2ec927 ## Variable types: 0 continuous, 1200 integer (1200 binary) ## Coefficient statistics: ##   Matrix range     [2e-02, 1e+00] ##   Objective range  [1e+02, 6e+02] ##   Bounds range     [1e+00, 1e+00] ##   RHS range        [1e+00, 8e+00] ## Found heuristic solution: objective 20096.000000 ## Presolve removed 1028 rows and 232 columns ## Presolve time: 0.01s ## Presolved: 877 rows, 968 columns, 2712 nonzeros ## Variable types: 0 continuous, 968 integer (968 binary) ## Found heuristic solution: objective 19632.000000 ## Root relaxation presolved: 877 rows, 968 columns, 2712 nonzeros ##  ##  ## Root relaxation: objective 1.005410e+04, 568 iterations, 0.01 seconds (0.01 work units) ##  ##     Nodes    |    Current Node    |     Objective Bounds      |     Work ##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time ##  ##      0     0 10054.0986    0   57 19632.0000 10054.0986  48.8%     -    0s ## H    0     0                    11300.000000 10054.0986  11.0%     -    0s ## H    0     0                    11140.000000 10054.0986  9.75%     -    0s ##  ## Explored 1 nodes (823 simplex iterations) in 0.03 seconds (0.04 work units) ## Thread count was 1 (of 8 available processors) ##  ## Solution count 4: 11140 11300 19632 20096  ##  ## Optimal solution found (tolerance 1.00e-01) ## Best objective 1.114000000000e+04, best bound 1.005600000000e+04, gap 9.7307% # calculate feature representation r6 <- eval_feature_representation_summary(p6, s6) print(r6) ## # A tibble: 20 × 5 ##    summary    feature   total_amount absolute_held relative_held ##    <chr>      <chr>            <dbl>         <dbl>         <dbl> ##  1 overall    feature_1       117.           22.5          0.193 ##  2 overall    feature_2        43.7           8.11         0.186 ##  3 overall    feature_3       101.           18.0          0.178 ##  4 overall    feature_4        59.7          11.3          0.190 ##  5 overall    feature_5        79.4          15.7          0.198 ##  6 few traps  feature_1         8.33          0            0     ##  7 few traps  feature_2         3.12          0            0     ##  8 few traps  feature_3         7.20          0            0     ##  9 few traps  feature_4         4.27          0            0     ## 10 few traps  feature_5         5.67          0            0     ## 11 many traps feature_1        41.6           8.00         0.192 ## 12 many traps feature_2        15.6           3.49         0.224 ## 13 many traps feature_3        36.0           6.24         0.174 ## 14 many traps feature_4        21.3           5.28         0.247 ## 15 many traps feature_5        28.4           5.72         0.202 ## 16 baiting    feature_1        66.6          14.4          0.217 ## 17 baiting    feature_2        25.0           4.62         0.185 ## 18 baiting    feature_3        57.6          11.7          0.203 ## 19 baiting    feature_4        34.1           6.05         0.177 ## 20 baiting    feature_5        45.4           9.98         0.220 # plot solution plot(category_layer(s6), main = \"solution\", axes = FALSE)"},{"path":"https://prioritizr.net/articles/management_zones_tutorial.html","id":"multiple-zones-with-fragmentation-penalties-and-mandatory-allocations","dir":"Articles","previous_headings":"Usage","what":"Multiple zones with fragmentation penalties and mandatory allocations","title":"Management zones tutorial","text":"Finally, might interested conservation planning scenarios every single planning unit must allocated management zone. often case developing land-use plans every single planning unit needs allocated specific management zone. Though makes less sense , let’s see happens solution needed least one form control every single planning unit.","code":"# create matrix that describe boundary penalties between planning units # allocated to different zones p7 <-   problem(     pu4,     zones(       sim_features * 0.1,       sim_features * 0.5,       sim_features * 0.8,       zone_names = names(pu4),       feature_names = names(sim_features)     )   ) %>%   add_min_set_objective() %>%   add_manual_targets(t4) %>%   add_mandatory_allocation_constraints() %>%   add_manual_locked_constraints(l5) %>%   add_boundary_penalties(penalty = 640, zones = z6) %>%   add_binary_decisions()  # print problem print(p7) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•zones:       \"few traps\", \"many traps\", and \"baiting\" (3 total) ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (100 total) ## │ ├•costs:      continuous values (between 0 and 300) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties: ## ││└•1:          boundary penalties (`penalty` = 640, `edge_factor` = 0.5, 0.5, and 0.5, …) ## │├•targets:     absolute targets (between 8 and 8) ## │├•constraints: ## ││├•1:          mandatory allocation constraints ## ││└•2:          manual locked constraints (80 planning units) ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # solve problem s7 <- solve(p7) ## Gurobi Optimizer version 10.0.2 build v10.0.2rc0 (linux64) ##  ## CPU model: 11th Gen Intel(R) Core(TM) i7-1185G7 @ 3.00GHz, instruction set [SSE2|AVX|AVX2|AVX512] ## Thread count: 4 physical cores, 8 logical processors, using up to 1 threads ##  ## Optimize a model with 1905 rows, 1200 columns and 5400 nonzeros ## Model fingerprint: 0x3bb74472 ## Variable types: 0 continuous, 1200 integer (1200 binary) ## Coefficient statistics: ##   Matrix range     [2e-02, 1e+00] ##   Objective range  [1e+02, 6e+02] ##   Bounds range     [1e+00, 1e+00] ##   RHS range        [1e+00, 8e+00] ## Found heuristic solution: objective 19600.000000 ## Presolve removed 1120 rows and 324 columns ## Presolve time: 0.01s ## Presolved: 785 rows, 876 columns, 2448 nonzeros ## Variable types: 0 continuous, 876 integer (876 binary) ## Found heuristic solution: objective 18988.000000 ## Root relaxation presolved: 785 rows, 876 columns, 2448 nonzeros ##  ##  ## Root relaxation: objective 1.323093e+04, 265 iterations, 0.00 seconds (0.00 work units) ##  ##     Nodes    |    Current Node    |     Objective Bounds      |     Work ##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time ##  ##      0     0 13230.9255    0   95 18988.0000 13230.9255  30.3%     -    0s ## H    0     0                    13260.000000 13230.9255  0.22%     -    0s ##  ## Explored 1 nodes (426 simplex iterations) in 0.02 seconds (0.03 work units) ## Thread count was 1 (of 8 available processors) ##  ## Solution count 3: 13260 18988 19600  ##  ## Optimal solution found (tolerance 1.00e-01) ## Best objective 1.326000000000e+04, best bound 1.323200000000e+04, gap 0.2112% # calculate feature representation r7 <- eval_feature_representation_summary(p7, s7) print(r7) ## # A tibble: 20 × 5 ##    summary    feature   total_amount absolute_held relative_held ##    <chr>      <chr>            <dbl>         <dbl>         <dbl> ##  1 overall    feature_1       117.           23.4         0.201  ##  2 overall    feature_2        43.7           8.04        0.184  ##  3 overall    feature_3       101.           19.4         0.192  ##  4 overall    feature_4        59.7          10.9         0.182  ##  5 overall    feature_5        79.4          16.1         0.203  ##  6 few traps  feature_1         8.33          5.92        0.711  ##  7 few traps  feature_2         3.12          2.33        0.745  ##  8 few traps  feature_3         7.20          5.25        0.730  ##  9 few traps  feature_4         4.27          3.18        0.745  ## 10 few traps  feature_5         5.67          4.00        0.706  ## 11 many traps feature_1        41.6           3.02        0.0725 ## 12 many traps feature_2        15.6           1.09        0.0700 ## 13 many traps feature_3        36.0           2.41        0.0670 ## 14 many traps feature_4        21.3           1.66        0.0779 ## 15 many traps feature_5        28.4           2.11        0.0743 ## 16 baiting    feature_1        66.6          14.4         0.217  ## 17 baiting    feature_2        25.0           4.62        0.185  ## 18 baiting    feature_3        57.6          11.7         0.203  ## 19 baiting    feature_4        34.1           6.05        0.177  ## 20 baiting    feature_5        45.4           9.98        0.220 # plot solution plot(category_layer(s7), main = \"solution\", axes = FALSE)"},{"path":"https://prioritizr.net/articles/management_zones_tutorial.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Management zones tutorial","text":"Hopefully, vignette provided informative introduction building solving problems multiple zones. Although examined different functions , almost every single function modifying conservation planning problems compatible problems contain zones. ’s worth noting working multiple zones lot trickier working single zone, recommend playing around code Examples sections package documentation help understand functions work applied multiple zones.","code":""},{"path":[]},{"path":"https://prioritizr.net/articles/package_overview.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Package overview","text":"prioritizr R package uses mixed integer linear programming (MILP) techniques provide flexible interface building solving conservation planning problems (Rodrigues et al. 2000; Billionnet 2013). supports broad range objectives, constraints, penalties can used custom-tailor conservation planning problems specific needs conservation planning exercise. built, conservation planning problems can solved using variety commercial open-source exact algorithm solvers. contrast algorithms conventionally used solve conservation problems, heuristics simulated annealing (Ball et al. 2009), exact algorithms used guaranteed find optimal solutions. Furthermore, conservation problems can constructed optimize spatial allocation different management zones (actions), meaning conservation practitioners can identify solutions benefit multiple stakeholders. Finally, package functionality read input data formatted Marxan conservation planning program (Ball et al. 2009), find much cheaper solutions much shorter period time Marxan (Beyer et al. 2016).","code":""},{"path":"https://prioritizr.net/articles/package_overview.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Package overview","text":"Systematic conservation planning rigorous, repeatable, structured approach designing new protected areas efficiently meet conservation objectives (Margules & Pressey 2000). Historically, conservation decision-making often evaluated parcels opportunistically became available purchase, donation, threat. Although purchasing areas may improve status quo, decisions may substantially enhance long-term persistence target species communities. Faced realization, conservation planners began using decision support tools help simulate alternative reserve designs range different biodiversity management goals , ultimately, guide protected area acquisitions management actions. Due systematic, evidence-based nature tools, conservation prioritization can help contribute transparent, inclusive, defensible decision making process. conservation planning exercise typically starts defining study area. study area encompass areas relevant decision maker hypothesis tested. extent study area encompass important localities (e.g., Stigner et al. 2016), single state (e.g., Kirkpatrick 1983), entire country (Fuller et al. 2010), entire planet (Butchart et al. 2015). Next, study area divided set discrete areas termed planning units. planning unit represents discrete locality study area can managed independently areas. general idea combination planning units can selected conservation actions (e.g., protected area establishment, habitat restoration). Planning units often created square hexagon cells sized according scale conservation actions, resolution data underpin planning exercise (see Klein et al. 2009). Cost data (surrogate thereof) needed inform prioritization process. Specifically, cost data describe relative expenditure associated managing planning unit conservation. example, goal conservation planning exercise identify priority areas expanding local protected area system, cost data represent physical cost purchasing land. Alternatively, data available, surrogate data often used instead (e.g., human population density, opportunity cost foregone commercial activities, planning unit size). Conservation planning exercises also require data biodiversity elements conservation interest (termed conservation features). features species (e.g., Neofelis nebulosa, Clouded Leopard), populations, habitats (e.g., mangroves cloud forest). identifying set relevant conservation features conservation planning exercise, spatially explicit data need obtained every feature describe spatial distribution (e.g., habitat suitability data, probability occurrence data, presence/absence data). important ensure conservation features adequately covered (represented) prioritizations. assembling data, next step define conservation planning problem. prioritizr R package designed help build solve conservation planning problems. Specifically, prioritizations generated formulating mathematical optimization problem solving generate solution. mathematical optimization problems formulated using planning unit data, cost data, feature data, information related overarching aim prioritization process. general, goal optimization problem minimize (maximize) objective function calculated using set decision variables, subject series constraints ensure solution exhibits specific properties. objective function describes quantity trying minimize (e.g., cost solution) maximize (e.g., number features conserved). decision variables describe entities can control, indicate planning units selected conservation management . constraints can thought rules decision variables need follow. example, commonly used constraint specifying solution must exceed certain budget. wide variety approaches developed solving optimization problems. Reserve design problems frequently solved using simulated annealing (Kirkpatrick et al. 1983) heuristics (Nicholls & Margules 1993; Moilanen 2007). methods conceptually simple can applied wide variety optimization problems. However, scale well large complex problems (Beyer et al. 2016). Additionally, methods tell close given solution optimal solution. prioritizr package uses exact algorithms efficiently solve conservation planning problems within pre-specified optimality gap. words, can specify need optimal solution (.e., gap 0%) algorithms , given enough time, find solution meets criteria. past, exact algorithms slow conservation planning exercises (Pressey et al. 1996). However, improvements last decade mean now much faster (Achterberg & Wunderling 2013; Beyer et al. 2016). package, optimization problems expressed using integer linear programming (ILP) can solved using (linear) exact algorithm solvers. general form integer programming problem can expressed matrix notation using following equation. \\[\\text{Minimize} \\space \\boldsymbol{c}^\\text{T} \\boldsymbol{x} \\space \\space \\text{subject } \\space \\boldsymbol{x} \\space \\Box \\space \\boldsymbol{b}\\] \\(x\\) vector decision variables, \\(c\\) \\(b\\) vectors known coefficients, \\(\\) constraint matrix. final term specifies series structural constants \\(\\Box\\) symbol used indicate relational operators constraints can either \\(\\geq\\), \\(=\\), \\(\\leq\\). context conservation planning problem, \\(c\\) used represent planning unit costs, \\(\\) used store data showing presence / absence (amount) feature planning unit, \\(b\\) used represent minimum amount habitat required species solution, \\(\\Box\\) set \\(\\geq\\) symbols indicate total amount feature solution must exceed quantities \\(b\\). many ways formulating reserve selection problem (Rodrigues et al. 2000).","code":""},{"path":"https://prioritizr.net/articles/package_overview.html","id":"a-grammar-for-conservation-planning","dir":"Articles","previous_headings":"","what":"A grammar for conservation planning","title":"Package overview","text":"prioritizr R package uses grammar describe elements conservation planning. means functions organized verbs relate specific concepts. example, functions used specify primary objective optimization end _objective suffix (e.g., add_min_set_objective() add_min_shortfall_objective()). combining multiple functions together, can used formulate complete conservation planning problem. Specifically, verbs formulating problems described . Create new conservation planning problem specifying planning units, features, management zones conservation interest. Add primary objective conservation planning problem (e.g., minimize overall cost). Add penalties conservation planning problem penalize solutions according specific metric (e.g., connectivity). Add targets conservation planning problem specify much feature ideally represented solutions. Add constraints conservation planning problem ensure solutions exhibit specific properties (e.g., select specific planning units protection). Add decisions conservation planning problem specify nature decisions problem (e.g., binary decisions indicate planning units selected selected management). Add portfolio conservation planning problem specify methodological approach generating multiple solutions (e.g., generate multiple solutions finding 100 solutions within 10% optimality). Add solver conservation problem specify optimization software (e.g., Gurobi) generating solutions customize optimization settings (e.g., generate optimal solution). building conservation planning problem, can solved generate prioritization (using solve() function). also verbs available help evaluate interpret solutions. verbs described . Evaluate performance computing summary statistics (e.g., overall cost, feature representation, total boundary length). Evaluate relative importance planning units selected solution (e.g., based irreplaceability).","code":""},{"path":"https://prioritizr.net/articles/package_overview.html","id":"workflow","dir":"Articles","previous_headings":"","what":"Workflow","title":"Package overview","text":"general workflow using prioritizr R package starts creating new conservation planning problem() object using data. Specifically, problem() object constructed using data specify planning units, biodiversity features, management zones (applicable), costs. creating new problem() object, can customized—adding objectives, penalties, constraints, information—build precise representation conservation planning problem required, solved obtain solution. conservation planning problems require objective. objective specifies property used compare different feasible solutions. Simply put, objective property solution maximized minimized optimization process. instance, minimum set objective (specified using add_min_set_objective()), seeking minimize cost solution (similar Marxan). hand, minimum shortfall objective (specified using add_min_shortfall_objective()), seeking minimize average target shortfall features represented solution, subject budget. Many objectives require representation targets (e.g., minimum set objective). targets specialized set constraints relate total quantity feature secured solution (e.g., amount suitable habitat number individuals). case minimum set objective ( add_min_set_objective()), used ensure solutions secure sufficient quantity feature, objectives, maximum features objective ( add_max_features_objective()) used assess whether feature adequately conserved candidate solution. Targets can expressed numerically total amount required given feature (using add_absolute_targets()), proportion total amount found planning units (using add_relative_targets()). Note objectives require targets, warning thrown attempt made add targets problem objective use . Constraints penalties can added conservation planning problem ensure solutions exhibit specific property penalize solutions don’t exhibit specific property (respectively). difference constraints penalties, strictly speaking, constraints used rule potential solutions don’t exhibit specific property. instance, constraints can used ensure specific planning units selected solution prioritization (using add_locked_in_constraints()) selected solution prioritization (using add_locked_out_constraints()). hand, penalties combined objective problem, penalty factor, overall objective problem becomes minimize (maximize) primary objective function penalty function. example, penalties can added problem penalize solutions excessively fragmented (using add_boundary_penalties()). penalties penalty argument specifies relative importance spatially clustered solutions. argument penalty high, solutions less fragmented valued highly – even cost – argument penalty low, solutions fragmented valued less highly. building conservation problem, can solved obtain solution (portfolio solutions desired). solution returned format planning unit data used construct problem. instance, means raster data used initialize problem, solution also output raster format. can helpful comes interpreting visualizing solutions means solution data first merged spatial data can plotted map.","code":""},{"path":"https://prioritizr.net/articles/package_overview.html","id":"usage","dir":"Articles","previous_headings":"","what":"Usage","title":"Package overview","text":"provide introduction using prioritizr R package build solve conservation planning problem. Please note discuss conservation planning multiple zones vignette, information working multiple management zones please see Management zones tutorial. First, load prioritizr package.","code":"# load package library(prioritizr)"},{"path":"https://prioritizr.net/articles/package_overview.html","id":"data","dir":"Articles","previous_headings":"Usage","what":"Data","title":"Package overview","text":"Now load built-data sets distributed prioritizr R package. package contains several different planning unit data sets. provide comprehensive overview different ways can initialize conservation planning problem, load . First, load raster planning unit data (sim_pu_raster). , planning units represented single-layer raster object (.e., terra::rast() object) pixel corresponds spatial extent panning unit. pixel values correspond acquisition costs planning unit.  Secondly, load one spatial vector planning unit data sets (sim_pu_polygons). , polygon (.e., feature using ArcGIS terminology) corresponds different planning unit. data set attribute table contains additional information polygon. Namely, cost field (column) attribute table contains acquisition cost planning unit.  Thirdly, load planning unit data stored tabular format (.e., data.frame format). familiar Marxan dealing large conservation planning problems (> 10 million planning units), may useful work data format contain spatial information reduce computational burden. using tabular data initialize conservation planning problems, data must follow conventions used Marxan. Specifically, row planning unit table must correspond different planning unit. table must also “id” column provide unique integer identifier planning unit, must also column indicates cost planning unit. information, please see official Marxan documentation. Finally, load data showing spatial distribution conservation features. conservation features (sim_features) represented multi-layer raster object (.e., terra::rast() object), layer corresponds different feature. pixel values layer correspond amount suitable habitat available given planning unit. Note planning unit feature data exactly spatial properties (.e., resolution, extent, coordinate reference system) pixels line perfectly.","code":"# load raster planning unit data sim_pu_raster <- get_sim_pu_raster()  # print data print(sim_pu_raster) ## class       : SpatRaster  ## dimensions  : 10, 10, 1  (nrow, ncol, nlyr) ## resolution  : 0.1, 0.1  (x, y) ## extent      : 0, 1, 0, 1  (xmin, xmax, ymin, ymax) ## coord. ref. : Undefined Cartesian SRS  ## source      : sim_pu_raster.tif  ## name        :    layer  ## min value   : 190.1328  ## max value   : 215.8638 # plot data plot(   sim_pu_raster, main = \"Planning unit costs\",   xlim = c(-0.1, 1.1), ylim = c(-0.1, 1.1), axes = FALSE ) # load polygon planning unit data sim_pu_polygons <- get_sim_pu_polygons()  # print data print(sim_pu_polygons) ## Simple feature collection with 90 features and 3 fields ## Geometry type: POLYGON ## Dimension:     XY ## Bounding box:  xmin: 0 ymin: 0 xmax: 1 ymax: 1 ## Projected CRS: Undefined Cartesian SRS ## # A tibble: 90 × 4 ##     cost locked_in locked_out                                      geom ##  * <dbl> <lgl>     <lgl>                                  <POLYGON [m]> ##  1  216. FALSE     FALSE            ((0 1, 0.1 1, 0.1 0.9, 0 0.9, 0 1)) ##  2  213. FALSE     FALSE      ((0.1 1, 0.2 1, 0.2 0.9, 0.1 0.9, 0.1 1)) ##  3  207. FALSE     FALSE      ((0.2 1, 0.3 1, 0.3 0.9, 0.2 0.9, 0.2 1)) ##  4  209. FALSE     TRUE       ((0.3 1, 0.4 1, 0.4 0.9, 0.3 0.9, 0.3 1)) ##  5  214. FALSE     FALSE      ((0.4 1, 0.5 1, 0.5 0.9, 0.4 0.9, 0.4 1)) ##  6  214. FALSE     FALSE      ((0.5 1, 0.6 1, 0.6 0.9, 0.5 0.9, 0.5 1)) ##  7  210. FALSE     FALSE      ((0.6 1, 0.7 1, 0.7 0.9, 0.6 0.9, 0.6 1)) ##  8  211. FALSE     TRUE       ((0.7 1, 0.8 1, 0.8 0.9, 0.7 0.9, 0.7 1)) ##  9  210. FALSE     FALSE      ((0.8 1, 0.9 1, 0.9 0.9, 0.8 0.9, 0.8 1)) ## 10  204. FALSE     FALSE          ((0.9 1, 1 1, 1 0.9, 0.9 0.9, 0.9 1)) ## # ℹ 80 more rows # plot the planning units, and color them according to cost values plot(sim_pu_polygons[, \"cost\"]) # specify file path for planning unit data pu_path <- system.file(\"extdata/marxan/input/pu.dat\", package = \"prioritizr\")  # load in the tabular planning unit data # note that we use the data.table::fread function, as opposed to the read.csv # function, because it is much faster pu_dat <- data.table::fread(pu_path, data.table = FALSE)  # preview first six rows of the tabular planning unit data # note that it has some extra columns other than id and cost as per the # Marxan format head(pu_dat) ##   id       cost status    xloc     yloc ## 1  3      0.000      0 1116623 -4493479 ## 2 30   7527.275      3 1110623 -4496943 ## 3 56  37349.075      0 1092623 -4500408 ## 4 58  16959.021      0 1116623 -4500408 ## 5 84  34220.256      0 1098623 -4503872 ## 6 85 178907.584      0 1110623 -4503872 # load feature data sim_features <- get_sim_features()  # plot the distribution of suitable habitat for each feature plot(   sim_features, nr = 2,   axes = FALSE, xlim = c(-0.1, 1.1), ylim = c(-0.1, 1.1) )"},{"path":"https://prioritizr.net/articles/package_overview.html","id":"initialize-a-problem","dir":"Articles","previous_headings":"Usage","what":"Initialize a problem","title":"Package overview","text":"loaded planning unit feature data, now try initializing conservation planning problems. lot different ways initialize conservation planning problem, just showcase commonly used methods. exhaustive description ways can initialize conservation problem, see help file problem() function. First , initialize conservation planning problem using raster data. Generally, recommend initializing problems using raster data possible. problem() function needs calculate amount feature planning unit, providing planning unit feature data raster format spatial resolution, extents, coordinate systems, means problem() function need geoprocessing behind scenes. sometimes can’t use raster planning unit data, planning units aren’t equal-sized grid cells. , example showing can initialize conservation planning problem using planning units formatted spatial vector data. Note reduce run-time pre-computing amount feature planning unit storing data attribute table (e.g., performing zonal statistics R ESRI ArcGIS), passing names columns argument problem() function (see Examples section problem() details). can also initialize conservation planning problem using tabular planning unit data (.e., data.frame format). Since tabular planning unit data contain spatial information, also provide feature data tabular format (.e., data.frame format) data showing amount feature planning unit tabular format (.e., data.frame format). feature data must “id” column containing unique integer identifier feature, planning unit feature data must contain following three columns: pu corresponding planning unit identifiers, species corresponding feature identifiers, amount showing amount given feature given planning unit. information initializing problems, please see help page problem() function (can open entering code: ?problem). Now initialized conservation planning problem, show can customize suit exact needs conservation planning scenario. Although initialized conservation planning problems using several different methods, moving forward, use raster-based planning unit data keep things simple.","code":"# create problem p1 <- problem(sim_pu_raster, sim_features)  # print problem print(p1) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   none specified ## │├•penalties:   none specified ## │├•targets:     none specified ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # print number of planning units number_of_planning_units(p1) ## [1] 90 # print number of features number_of_features(p1) ## [1] 5 # create problem with spatial vector data # note that we have to specify which column in the attribute table contains # the cost data p2 <- problem(sim_pu_polygons, sim_features, cost_column = \"cost\")  # print problem print(p2) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <sftbl_dftbldata.frame> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   none specified ## │├•penalties:   none specified ## │├•targets:     none specified ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # set file path for feature data spec_path <- system.file(   \"extdata/marxan/input/spec.dat\", package = \"prioritizr\" )  # load in feature data spec_dat <- data.table::fread(spec_path, data.table = FALSE)  # print first six rows of the data # note that it contains extra columns head(spec_dat) ##   id prop spf   name ## 1 10  0.3   1  bird1 ## 2 11  0.3   1  nvis2 ## 3 12  0.3   1  nvis8 ## 4 13  0.3   1  nvis9 ## 5 14  0.3   1 nvis14 ## 6 15  0.3   1 nvis20 # set file path for planning unit vs. feature data puvspr_path <- system.file(   \"extdata/marxan/input/puvspr.dat\", package = \"prioritizr\" )  # load in planning unit vs feature data puvspr_dat <- data.table::fread(puvspr_path, data.table = FALSE)  # print first six rows of the data head(puvspr_dat) ##   species  pu     amount ## 1      26  56 120.344884 ## 2      26  58  45.167010 ## 3      26  84  68.047375 ## 4      26  85   9.735624 ## 5      26  86   7.803476 ## 6      26 111 478.327417 # create problem p3 <- problem(pu_dat, spec_dat, cost_column = \"cost\", rij = puvspr_dat)  # print problem print(p3) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"bird1\", \"nvis2\", \"nvis8\", \"nvis9\", \"nvis14\", \"nvis20\" , … (17 total) ## │└•planning units: ## │ ├•data:       <data.frame> (1751 total) ## │ ├•costs:      continuous values (between 0 and 415692.1938) ## │ ├•extent:     NA ## │ └•CRS:        NA ## ├•formulation ## │├•objective:   none specified ## │├•penalties:   none specified ## │├•targets:     none specified ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation."},{"path":"https://prioritizr.net/articles/package_overview.html","id":"add-an-objective","dir":"Articles","previous_headings":"Usage","what":"Add an objective","title":"Package overview","text":"next step add primary objective problem. problem objective used specify primary goal problem (.e., quantity maximized minimized). conservation planning problems involve minimizing maximizing kind objective. instance, might require solution conserves enough habitat species minimizing overall cost reserve network. Alternatively, might require solution maximizes number conserved species ensuring cost reserve network exceed budget. Please note objectives added way regardless type data used initialize problem. following objectives available. Minimum set objective: Minimize cost solution whilst ensuring targets met (Rodrigues et al. 2000). objective similar used Marxan (Ball et al. 2009). example, can add minimum set objective problem using following code. Maximum cover objective: Represent least one instance many features possible within given budget (Church et al. 1996). Maximum features objective: Fulfill many targets possible ensuring cost solution exceed budget (inspired Cabeza & Moilanen 2001). object similar maximum cover objective except option later specifying targets feature. practice, objective useful maximum cover objective features often require certain amount area persist simply capturing single instance habitat feature generally unlikely enhance long-term persistence. Minimum shortfall objective: Minimize overall (weighted sum) shortfall many targets possible ensuring cost solution exceed budget. practice, objective useful large amount left-budget using maximum feature representation objective remaining funds need allocated places enhance representation features unmet targets. Minimum largest shortfall objective: Minimize largest (maximum) shortfall ensuring cost solution exceed budget. practice, objective useful minimum shortfall objective returns solutions focus much representing small number features (e.g., occur much cheaper planning units), solutions needed spread conservation effort evenly among features—even means features (relatively) poor representation. Maximum phylogenetic diversity objective: Maximize phylogenetic diversity features represented solution subject budget (inspired Faith 1992; Rodrigues & Gaston 2002). objective similar maximum features objective except emphasis placed protecting features associated diverse range evolutionary histories. package contains simulated phylogeny can used simulated feature data (sim_phylogny). Maximum phylogenetic endemism objective: Maximize phylogenetic endemism features represented solution subject budget (inspired Faith 1992; Rodrigues & Gaston 2002; Rosauer et al. 2009). objective similar maximum phylogenetic diversity except emphasis placed conserving features associated geographically restricted periods evolutionary history rather diverse range evolutionary histories. Maximum utility objective: Secure much features possible without exceeding budget. objective functionally equivalent selecting planning units greatest amounts feature (e.g., species richness). Generally, don’t encourage use objective rarely identify complementary solutions–solutions adequately conserve range different features—except perhaps explore trade-offs provide baseline solution compare solutions.","code":"# create a new problem that has the minimum set objective p3 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective()  # print problem print(p3) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties:   none specified ## │├•targets:     none specified ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # create a new problem that has the maximum coverage objective and a budget # of 5000 p4 <-   problem(sim_pu_raster, sim_features) %>%   add_max_cover_objective(5000)  # print problem print(p4) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   maximum coverage objective (`budget` = 5000) ## │├•penalties:   none specified ## │├•targets:     none specified ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # create a new problem that has the maximum features objective and a budget # of 5000 p5 <-   problem(sim_pu_raster, sim_features) %>%   add_max_features_objective(budget = 5000)  # print problem print(p5) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   maximum representation objective (`budget` = 5000) ## │├•penalties:   none specified ## │├•targets:     none specified ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # create a new problem that has the minimum shortfall objective and a budget # of 5000 p6 <-   problem(sim_pu_raster, sim_features) %>%   add_min_shortfall_objective(budget = 5000)  # print problem print(p6) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum shortfall objective (`budget` = 5000) ## │├•penalties:   none specified ## │├•targets:     none specified ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # create a new problem that has the minimum largest shortfall objective and a # budget of 5000 p7 <-   problem(sim_pu_raster, sim_features) %>%   add_min_largest_shortfall_objective(budget = 5000)  # print problem print(p7) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum largest shortfall objective (`budget` = 5000) ## │├•penalties:   none specified ## │├•targets:     none specified ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # load simulated phylogeny data sim_phylogeny <- get_sim_phylogeny()  # create a new problem that has the maximum phylogenetic diversity # objective and a budget of 5000 p8 <-   problem(sim_pu_raster, sim_features) %>%   add_max_phylo_div_objective(budget = 5000, tree = sim_phylogeny)  # print problem print(p8) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   phylogenetic diversity objective (`budget` = 5000, `tree` = phylogenetic tree (branch lengths between 0.041 and 1.4211)) ## │├•penalties:   none specified ## │├•targets:     none specified ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # load simulated phylogeny data sim_phylogeny <- get_sim_phylogeny()  # create a new problem that has the maximum phylogenetic diversity # objective and a budget of 5000 p9 <-   problem(sim_pu_raster, sim_features) %>%   add_max_phylo_end_objective(budget = 5000, tree = sim_phylogeny)  # print problem print(p9) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   phylogenetic endemism objective (`budget` = 5000, `tree` = phylogenetic tree (branch lengths between 0.041 and 1.4211)) ## │├•penalties:   none specified ## │├•targets:     none specified ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # create a new problem that has the maximum utility objective and a budget # of 5000 p10 <-   problem(sim_pu_raster, sim_features) %>%   add_max_utility_objective(budget = 5000)  # print problem print(p10) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   maximum utility objective (`budget` = 5000) ## │├•penalties:   none specified ## │├•targets:     none specified ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation."},{"path":"https://prioritizr.net/articles/package_overview.html","id":"add-targets","dir":"Articles","previous_headings":"Usage","what":"Add targets","title":"Package overview","text":"conservation planning problems require targets. Targets used specify minimum amount proportion feature’s distribution needs protected solution. example, may want develop reserve network secure 20% distribution feature minimal cost. following methods available specifying targets. Absolute targets: Targets expressed total amount feature study area need secured. example, binary feature data showed absence presence suitable habitat across study area, set absolute target 5 mean require 5 planning units suitable habitat solution. Relative targets: Targets set proportion (0 1) total amount feature study area. example, binary feature data feature occupied total 20 planning units study area, set relative target 0.5 (.e., 50%) specify solution must secure 10 planning units feature. alternatively specify absolute target 10 achieve result, sometimes proportions easier work . Log-linear targets: Targets expressed using scaling factors log-linear interpolation. method specifying targets commonly used global prioritization analyses (Rodrigues et al. 2004). Manual targets: Targets manually specified. really recommended advanced users problems involve multiple management zones. See Management zones tutorial information targets. functions specifying objective problem, try adding multiple targets problem, recently added set targets used.","code":"# create a problem with targets which specify that the solution must conserve # a sum total of 3 units of suitable habitat for each feature p11 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_absolute_targets(3)  # print problem print(p11) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties:   none specified ## │├•targets:     absolute targets (between 3 and 3) ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # create a problem with the minimum set objective and relative targets of 10 % # for each feature p12 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1)  # print problem print(p12) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties:   none specified ## │├•targets:     relative targets (between 0.1 and 0.1) ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # create a problem with targets which specify that we need 10 % of the habitat # for the first feature, 15 % for the second feature, 20 % for the third feature # 25 % for the fourth feature and 30 % of the habitat for the fifth feature targets <- c(0.1, 0.15, 0.2, 0.25, 0.3) p13 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(targets)  # print problem print(p13) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties:   none specified ## │├•targets:     relative targets (between 0.1 and 0.3) ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # create problem with added log-linear targets p14 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_loglinear_targets(10, 0.9, 100, 0.2)  # print problem print(p14) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties:   none specified ## │├•targets:     absolute targets (between 17.2905 and 21.5906) ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation."},{"path":"https://prioritizr.net/articles/package_overview.html","id":"add-constraints","dir":"Articles","previous_headings":"Usage","what":"Add constraints","title":"Package overview","text":"constraint can added conservation planning problem ensure solutions exhibit specific property. example, can used make sure solutions select specific planning unit selected planning units solution follow certain configuration. following constraints available. Locked constraints: Add constraints ensure certain planning units prioritized solution. example, may desirable lock planning units inside existing protected areas solution fills gaps existing reserve network. Locked constraints: Add constraints ensure certain planning units prioritized solution. example, may useful lock planning units degraded suitable conserving species. Neighbor constraints: Add constraints conservation problem ensure selected planning units least certain number neighbors. Contiguity constraints: Add constraints conservation problem ensure selected planning units spatially connected form spatially contiguous unit. Feature contiguity constraints: Add constraints ensure feature represented contiguous unit dispersible habitat. constraints advanced version implemented add_contiguity_constraints function, ensure feature represented contiguous unit entire solution form contiguous unit. Linear constraints: Add constraints ensure selected planning units meet certain criteria. example, can used add multiple budgets, limit number planning units selected different administrative areas within study region (e.g., different countries). Mandatory allocation constraints: Add constraints ensure every planning unit allocated management zone solution. Please note function can used problems contain multiple zones. information problems multiple zones example using function, see Management zones tutorial. particular, add_locked_in_constraints add_locked_out_constraints functions incredibly useful real-world conservation planning exercises, ’s worth pointing several ways can specify planning units locked solutions. use raster planning unit data, can also use raster data specify planning units locked locked .  planning unit data spatial vector format (similar sim_pu_polygons data) tabular format (similar pu_dat), can use field names data refer planning units locked / . example, sim_pu_polygons object TRUE / FALSE values “locked_in” field indicate planning units selected solution. use data field specify planning units TRUE values locked using following methods.","code":"# create problem with constraints which specify that the first planning unit # must be selected in the solution p15 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_locked_in_constraints(1)  # print problem print(p15) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties:   none specified ## │├•targets:     relative targets (between 0.1 and 0.1) ## │├•constraints: ## ││└•1:          locked in constraints (1 planning units) ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # create problem with constraints which specify that the second planning unit # must not be selected in the solution p16 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_locked_out_constraints(2)  # print problem print(p16) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties:   none specified ## │├•targets:     relative targets (between 0.1 and 0.1) ## │├•constraints: ## ││└•1:          locked out constraints (1 planning units) ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # create problem with constraints which specify that all selected planning units # in the solution must have at least 1 neighbor p17 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_neighbor_constraints(1)  # print problem print(p17) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties:   none specified ## │├•targets:     relative targets (between 0.1 and 0.1) ## │├•constraints: ## ││└•1:          neighbor constraints (`k` = 1, `clamp` = TRUE, …) ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # create problem with constraints which specify that all selected planning units # in the solution must form a single contiguous unit p18 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_contiguity_constraints()  # print problem print(p18) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties:   none specified ## │├•targets:     relative targets (between 0.1 and 0.1) ## │├•constraints: ## ││└•1:          contiguity constraints ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # create problem with constraints which specify that the planning units used # to conserve each feature must form a contiguous unit p19 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_feature_contiguity_constraints()  # print problem print(p19) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties:   none specified ## │├•targets:     relative targets (between 0.1 and 0.1) ## │├•constraints: ## ││└•1:          feature contiguity constraints ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # create problem with constraints which specify that the sum of # values in sim_features[[1]] among selected planning units must not exceed a # threshold value of 190. p20 <-   problem(sim_pu_raster, sim_features) %>%   add_min_shortfall_objective(budget = 1800) %>%   add_relative_targets(0.1) %>%   add_linear_constraints(190, \"<=\", sim_features[[1]])  # print problem print(p20) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum shortfall objective (`budget` = 1800) ## │├•penalties:   none specified ## │├•targets:     relative targets (between 0.1 and 0.1) ## │├•constraints: ## ││└•1:          linear constraints (`threshold` = 190, `sense` = \"<=\" (1 total), …) ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # load data to lock in or lock out planning units sim_locked_in_raster <- get_sim_locked_in_raster() sim_locked_out_raster <- get_sim_locked_out_raster()  # plot the locked data plot(   c(sim_locked_in_raster, sim_locked_out_raster),   xlim = c(-0.1, 1.1), ylim = c(-0.1, 1.1),   axes = FALSE, main = c(\"Locked in\", \"Locked out\") )  # create a problem using raster planning unit data and use the locked raster # data to lock in some planning units and lock out some other planning units p21 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_locked_in_constraints(sim_locked_in_raster) %>%   add_locked_out_constraints(sim_locked_out_raster)  # print problem print(p21) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties:   none specified ## │├•targets:     relative targets (between 0.1 and 0.1) ## │├•constraints: ## ││├•1:          locked in constraints (10 planning units) ## ││└•2:          locked out constraints (10 planning units) ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # preview sim_pu_polygons object print(sim_pu_polygons) ## Simple feature collection with 90 features and 3 fields ## Geometry type: POLYGON ## Dimension:     XY ## Bounding box:  xmin: 0 ymin: 0 xmax: 1 ymax: 1 ## Projected CRS: Undefined Cartesian SRS ## # A tibble: 90 × 4 ##     cost locked_in locked_out                                      geom ##  * <dbl> <lgl>     <lgl>                                  <POLYGON [m]> ##  1  216. FALSE     FALSE            ((0 1, 0.1 1, 0.1 0.9, 0 0.9, 0 1)) ##  2  213. FALSE     FALSE      ((0.1 1, 0.2 1, 0.2 0.9, 0.1 0.9, 0.1 1)) ##  3  207. FALSE     FALSE      ((0.2 1, 0.3 1, 0.3 0.9, 0.2 0.9, 0.2 1)) ##  4  209. FALSE     TRUE       ((0.3 1, 0.4 1, 0.4 0.9, 0.3 0.9, 0.3 1)) ##  5  214. FALSE     FALSE      ((0.4 1, 0.5 1, 0.5 0.9, 0.4 0.9, 0.4 1)) ##  6  214. FALSE     FALSE      ((0.5 1, 0.6 1, 0.6 0.9, 0.5 0.9, 0.5 1)) ##  7  210. FALSE     FALSE      ((0.6 1, 0.7 1, 0.7 0.9, 0.6 0.9, 0.6 1)) ##  8  211. FALSE     TRUE       ((0.7 1, 0.8 1, 0.8 0.9, 0.7 0.9, 0.7 1)) ##  9  210. FALSE     FALSE      ((0.8 1, 0.9 1, 0.9 0.9, 0.8 0.9, 0.8 1)) ## 10  204. FALSE     FALSE          ((0.9 1, 1 1, 1 0.9, 0.9 0.9, 0.9 1)) ## # ℹ 80 more rows # specify locked in data using the field name p22 <-   problem(sim_pu_polygons, sim_features, cost_column = \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_locked_in_constraints(\"locked_in\")  # print problem print(p22) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <sftbl_dftbldata.frame> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties:   none specified ## │├•targets:     relative targets (between 0.1 and 0.1) ## │├•constraints: ## ││└•1:          locked in constraints (10 planning units) ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # specify locked in data using the values in the field p23 <-   problem(sim_pu_polygons, sim_features, cost_column = \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_locked_in_constraints(which(sim_pu_polygons$locked_in))  # print problem print(p23) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <sftbl_dftbldata.frame> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties:   none specified ## │├•targets:     relative targets (between 0.1 and 0.1) ## │├•constraints: ## ││└•1:          locked in constraints (10 planning units) ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation."},{"path":"https://prioritizr.net/articles/package_overview.html","id":"add-penalties","dir":"Articles","previous_headings":"Usage","what":"Add penalties","title":"Package overview","text":"can also add penalties problem favor penalize solutions according secondary objective. Unlike constraint functions, functions add extra information objective function optimization function penalize solutions exhibit specific characteristics. example, penalties can added problem avoid highly fragmented solutions expense accepting slightly expensive solutions. penalty functions penalty argument controls relative importance secondary penalty function compared primary objective function. worth noting incredibly low incredibly high penalty values – relative main objective function – can cause problems take long time solve, trying range different penalty values can helpful limit solver run set period time. following penalties available. Boundary penalties: Add penalties penalize solutions excessively fragmented. penalties similar used Marxan (Ball et al. 2009; Beyer et al. 2016). Connectivity penalties: Add penalties favor solutions select combinations planning units high connectivity . function used symmetric connectivities among planning units (based Önal & Briers 2002). Asymmetric connectivity penalties: Add penalties penalize solutions select planning units share high connectivity values planning units selected solution. function used asymmetric connectivities among planning units (based Beger et al. 2010). Linear penalties: Add penalties penalize solutions select planning units according certain variable (e.g., anthropogenic pressure).","code":"# create problem with penalties that penalize fragmented solutions with a # penalty factor of 0.01 p24 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_boundary_penalties(penalty = 0.01)  # print problem print(p24) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties: ## ││└•1:          boundary penalties (`penalty` = 0.01, `edge_factor` = 0.5, …) ## │├•targets:     relative targets (between 0.1 and 0.1) ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # create problem with penalties for symmetric connectivity, # here we will use only the first four layers in # sim_features for the features and we will use the fifth layer in sim_features # to represent the connectivity data, where the connectivity_matrix function # will create a matrix showing the average strength of connectivity between # adjacent planning units using the data in the fifth layer of sim_features p25 <-   problem(sim_pu_raster, sim_features[[1:4]]) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_connectivity_penalties(     penalty = 5,     data = connectivity_matrix(sim_pu_raster, sim_features[[5]])   )  # print problem print(p25) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", and \"feature_4\" (4 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties: ## ││└•1:          connectivity penalties (`penalty` = 5, …) ## │├•targets:     relative targets (between 0.1 and 0.1) ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # create a matrix containing asymmetric connectivity data, asym_con_matrix <- matrix(   runif(ncell(sim_pu_raster)^2),   nrow = ncell(sim_pu_raster),   ncol = ncell(sim_pu_raster) )  # create problem with penalties for asymmetric connectivity p26 <-   problem(sim_pu_raster, sim_features[[1:4]]) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_asym_connectivity_penalties(penalty = 5, data = asym_con_matrix)  # print problem print(p26) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", and \"feature_4\" (4 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties: ## ││└•1:          asymmetric connectivity penalties (`penalty` = 5, …) ## │├•targets:     relative targets (between 0.1 and 0.1) ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # create data for penalizing planning units pen_raster <- simulate_cost(sim_pu_raster)  # create problem with penalties that penalize solutions that select # planning units with high values in the pen_raster object, # here we will use a penalty value of 5 to indicate the trade-off (scaling) # between the penalty values (in the sim_pu_raster) and the main objective # (i.e., the cost of the solution) p27 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_linear_penalties(penalty = 5, data = pen_raster)  # print problem print(p27) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties: ## ││└•1:          linear penalties (`penalty` = 5, …) ## │├•targets:     relative targets (between 0.1 and 0.1) ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation."},{"path":"https://prioritizr.net/articles/package_overview.html","id":"add-the-decision-types","dir":"Articles","previous_headings":"Usage","what":"Add the decision types","title":"Package overview","text":"Conservation planning problems involve making decisions planning units managed. decisions associated management actions (e.g., turning planning unit protected area). type decision describes action applied planning units. instance, default decision-type binary decision type, meaning either selecting selecting planning units management. following decision types available. Binary decisions: Add binary decision conservation planning problem. classic decision either prioritizing prioritizing planning unit. Typically, decision assumed action buying planning unit include protected area network. decision added problem object, decision class used default. Proportion decisions: Add proportion decision problem. relaxed decision part planning unit can prioritized, opposed default entire planning unit. Typically, decision assumed action buying fraction planning unit include protected area network. Generally, problems can solved much faster proportion-type decisions binary-type decisions, can useful commercial solvers available. Semi-continuous decisions: Add semi-continuous decision problem. decision similar proportion decisions except upper bound parameter. default, decision can range prioritizing none (0%) (100%) planning unit. However, upper bound can specified ensure fraction (e.g., 80%) planning unit can purchased. type decision may useful practical conserve entire area indicated planning unit.","code":"# add binary decisions to a problem p28 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions()  # print problem print(p28) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties:   none specified ## │├•targets:     relative targets (between 0.1 and 0.1) ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # add proportion decisions to a problem p29 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_proportion_decisions()  # print problem print(p29) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties:   none specified ## │├•targets:     relative targets (between 0.1 and 0.1) ## │├•constraints: none specified ## │└•decisions:   proportion decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # add semi-continuous decisions to a problem, where we can only manage at most # 50 % of the area encompassed by a planning unit p30 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_semicontinuous_decisions(0.5)  # print problem print(p30) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties:   none specified ## │├•targets:     relative targets (between 0.1 and 0.1) ## │├•constraints: none specified ## │└•decisions:   semicontinuous decision (`upper_limit` = 0.5) ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation."},{"path":"https://prioritizr.net/articles/package_overview.html","id":"add-a-solver","dir":"Articles","previous_headings":"Usage","what":"Add a solver","title":"Package overview","text":"Next, specifying mathematical formulation underpins conservation planning problem, can specify problem solved. specify information, prioritizr R package automatically use best solver currently installed system reasonable defaults. strongly recommend installing Gurobi software suite gurobi R package solve problems, information topic please refer Gurobi Installation Guide. following solvers available. Gurobi solver: Gurobi state art commercial optimization software. far fastest solvers can used solve conservation problems. However, freely available. said, special licenses available academics cost. IBM CPLEX solver: IBM CPLEX commercial optimization software. faster open source solvers available generating prioritizations (see ), however, freely available. Similar Gurobi software, special licenses available academics cost. CBC solver: CBC open-source mixed integer programming solver part Computational Infrastructure Operations Research (COIN-) project. solver seems much better performance open-source solvers (.e., add_rsymphony_solver(), add_lpsymphony_solver()) (see Solver benchmarks vignette details). , strongly recommended use solver Gurobi IBM CPLEX solvers available. solver requires rcbc R package, currently available GitHub. HiGHS solver: HiGHS open source optimization software. Although solver can comparable performance CBC solver (.e., add_cbc_solver()) particular problems generally faster SYMPHONY based solvers (.e., add_rsymphony_solver(), add_lpsymphony_solver()), can sometimes take much longer CBC solver particular problems. solver recommended add_gurobi_solver(), add_cplex_solver(), add_cbc_solver() used. lpsymphony solver: SYMPHONY open-source integer programming solver also part COIN-project. solver uses lpsymphony R package (available Bioconductor) interface SYMPHONY software. Rsymphony solver: solver provides different interface SYMPHONY software. uses Rsymphony R package available Comprehensive R Archive Network (CRAN). solver generally slower solvers, use parallel processing.","code":"# create a problem and specify that Gurobi should be used to solve the problem # and specify an optimality gap of zero to obtain the optimal solution p31 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_gurobi_solver(gap = 0)  # print problem print(p31) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties:   none specified ## │├•targets:     relative targets (between 0.1 and 0.1) ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # create a problem and specify that IBM CPLEX should be used to solve the # problem and specify an optimality gap of zero to obtain the optimal solution p32 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_cplex_solver(gap = 0)  # print problem print(p32) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties:   none specified ## │├•targets:     relative targets (between 0.1 and 0.1) ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      cplex solver (`gap` = 0, `time_limit` = 2147483647, …) ## # ℹ Use `summary(...)` to see complete formulation. # create a problem and specify that CBC should be used to solve the # problem and specify an optimality gap of zero to obtain the optimal solution p33 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_cbc_solver(gap = 0)  # print problem print(p33) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties:   none specified ## │├•targets:     relative targets (between 0.1 and 0.1) ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      cbc solver (`gap` = 0, `time_limit` = 2147483647, `first_feasible` = FALSE, `start` = NULL, …) ## # ℹ Use `summary(...)` to see complete formulation. # create a problem and specify that HiGHS should be used to solve the # problem and specify an optimality gap of zero to obtain the optimal solution p34 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_highs_solver(gap = 0)  # print problem print(p34) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties:   none specified ## │├•targets:     relative targets (between 0.1 and 0.1) ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      highs solver (`gap` = 0, `time_limit` = 2147483647, …) ## # ℹ Use `summary(...)` to see complete formulation. # create a problem and specify that lpsymphony should be used to solve the # problem and specify an optimality gap of zero to obtain the optimal solution p35 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_lpsymphony_solver(gap = 0)  # print problem print(p35) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties:   none specified ## │├•targets:     relative targets (between 0.1 and 0.1) ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      lpsymphony (`gap` = 0, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # create a problem and specify that Rsymphony should be used to solve the # problem and specify an optimality gap of zero to obtain the optimal solution p36 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_rsymphony_solver(gap = 0)  # print problem print(p36) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties:   none specified ## │├•targets:     relative targets (between 0.1 and 0.1) ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      rsymphony solver (`gap` = 0, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation."},{"path":"https://prioritizr.net/articles/package_overview.html","id":"add-a-portfolio","dir":"Articles","previous_headings":"Usage","what":"Add a portfolio","title":"Package overview","text":"Many conservation planning exercises require portfolio solutions. example, real-world exercises can involve presenting decision makers range near-optimal decisions. Additionally, number times different planning units selected different solutions can provide insight relative importance. following portfolio methods available. Gap portfolio: Generate portfolio solutions finding certain number solutions within pre-specified optimality gap. method especially useful generating multiple solutions can used calculate selection frequencies (similar Marxan). Note method requires Gurobi optimization software used generate solutions. Top portfolio: Generate portfolio solutions finding pre-specified number solutions closest optimality (.e top solutions). Note method requires Gurobi optimization software used generate solutions. Extra portfolio: Generate portfolio solutions storing feasible solutions found optimization process. Note method requires Gurobi optimization software used generate solutions. Cuts portfolio: Generate portfolio distinct solutions within pre-specified optimality gap. method recommended Gurobi optimization solver available. Shuffle portfolio: Generate portfolio solutions randomly reordering data prior attempting solve problem. Gurobi optimization solver available, method fastest method generating set number solutions within specified distance optimality.","code":"# create a problem and specify that a portfolio should be created by # finding five solutions within 10% of optimality p37 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_gap_portfolio(number_solutions = 5, pool_gap = 0.2)  # print problem print(p37) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties:   none specified ## │├•targets:     relative targets (between 0.1 and 0.1) ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   gap portfolio (`number_solutions` = 5, `pool_gap` = 0.2) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # create a problem and specify that a portfolio should be created using # the top five solutions p38 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_top_portfolio(number_solutions = 5)  # print problem print(p38) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties:   none specified ## │├•targets:     relative targets (between 0.1 and 0.1) ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   top portfolio (`number_solutions` = 5) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # create a problem and specify that a portfolio should be created using # extra solutions found while solving the problem p39 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_extra_portfolio()  # print problem print(p39) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties:   none specified ## │├•targets:     relative targets (between 0.1 and 0.1) ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   extra portfolio ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # create a problem and specify that a portfolio containing 10 solutions # should be created using using Bender's cuts p40 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_cuts_portfolio(number_solutions = 10)  # print problem print(p40) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties:   none specified ## │├•targets:     relative targets (between 0.1 and 0.1) ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   cuts portfolio (`number_solutions` = 10) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # create a problem and specify a portfolio should be created that contains # 10 solutions and that any duplicate solutions should not be removed p41 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_shuffle_portfolio(number_solutions = 10, remove_duplicates = FALSE)  # print problem print(p41) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties:   none specified ## │├•targets:     relative targets (between 0.1 and 0.1) ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 10, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation."},{"path":"https://prioritizr.net/articles/package_overview.html","id":"solve-the-problem","dir":"Articles","previous_headings":"Usage","what":"Solve the problem","title":"Package overview","text":"formulating conservation planning problem specifying problem solved, can use solve() function obtain solution. Note solver typically print information describing size problem report progress searching suitable solution.  can plot solution planning unit input data spatially referenced raster format. output format always match planning unit data used initialize problem. example, solution problem planning units spatial vector (shapefile) format also spatial vector format. Similarly, planning units tabular format (.e., data.frame), solution also returned tabular format. can also extract attributes solution describe quality solution optimization process.","code":"# formulate the problem p42 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_boundary_penalties(penalty = 500, edge_factor = 0.5) %>%   add_binary_decisions()  # print problem print(p42) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (90 total) ## │ ├•costs:      continuous values (between 190.1328 and 215.8638) ## │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) ## │ └•CRS:        Undefined Cartesian SRS (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties: ## ││└•1:          boundary penalties (`penalty` = 500, `edge_factor` = 0.5, …) ## │├•targets:     relative targets (between 0.1 and 0.1) ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # solve the problem (using the default solver) s42 <- solve(p42) ## Gurobi Optimizer version 10.0.2 build v10.0.2rc0 (linux64) ##  ## CPU model: 11th Gen Intel(R) Core(TM) i7-1185G7 @ 3.00GHz, instruction set [SSE2|AVX|AVX2|AVX512] ## Thread count: 4 physical cores, 8 logical processors, using up to 1 threads ##  ## Optimize a model with 293 rows, 234 columns and 1026 nonzeros ## Model fingerprint: 0xb4b90756 ## Variable types: 0 continuous, 234 integer (234 binary) ## Coefficient statistics: ##   Matrix range     [2e-01, 1e+00] ##   Objective range  [1e+02, 4e+02] ##   Bounds range     [1e+00, 1e+00] ##   RHS range        [3e+00, 8e+00] ## Found heuristic solution: objective 20287.197006 ## Found heuristic solution: objective 3087.9617767 ## Presolve time: 0.00s ## Presolved: 293 rows, 234 columns, 1026 nonzeros ## Variable types: 0 continuous, 234 integer (234 binary) ## Root relaxation presolved: 293 rows, 234 columns, 1026 nonzeros ##  ##  ## Root relaxation: objective 2.265862e+03, 228 iterations, 0.00 seconds (0.00 work units) ##  ##     Nodes    |    Current Node    |     Objective Bounds      |     Work ##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time ##  ##      0     0 2265.86242    0  234 3087.96178 2265.86242  26.6%     -    0s ##      0     0 2328.27423    0  232 3087.96178 2328.27423  24.6%     -    0s ##      0     0 2357.91894    0  229 3087.96178 2357.91894  23.6%     -    0s ##      0     0 2379.43275    0  197 3087.96178 2379.43275  22.9%     -    0s ##      0     0 2379.43275    0  197 3087.96178 2379.43275  22.9%     -    0s ## H    0     0                    2846.1551056 2379.43275  16.4%     -    0s ## H    0     0                    2814.4777374 2379.43275  15.5%     -    0s ##      0     2 2379.78730    0  197 2814.47774 2379.78730  15.4%     -    0s ## H   59    37                    2668.5003204 2385.59825  10.6%  14.7    0s ## H   81    42                    2604.7425995 2386.83630  8.37%  15.8    0s ##  ## Cutting planes: ##   Gomory: 3 ##  ## Explored 82 nodes (1685 simplex iterations) in 0.10 seconds (0.12 work units) ## Thread count was 1 (of 8 available processors) ##  ## Solution count 6: 2604.74 2668.5 2814.48 ... 20287.2 ##  ## Optimal solution found (tolerance 1.00e-01) ## Best objective 2.604742599487e+03, best bound 2.386836298527e+03, gap 8.3658% # plot solution plot(   s42, col = c(\"grey90\", \"darkgreen\"), main = \"Solution\",   xlim = c(-0.1, 1.1), ylim = c(-0.1, 1.1), axes = FALSE ) # extract the objective (numerical value being minimized or maximized) print(attr(s42, \"objective\")) ## solution_1  ##   2604.743 # extract time spent solving solution print(attr(s42, \"runtime\")) ## solution_1  ##       0.12 # extract state message from the solver that describes why this specific # solution was returned print(attr(s42, \"status\")) ## solution_1  ##  \"OPTIMAL\""},{"path":"https://prioritizr.net/articles/package_overview.html","id":"evaluate-the-solution","dir":"Articles","previous_headings":"","what":"Evaluate the solution","title":"Package overview","text":"Conservation planning involves making trade-offs different criteria (e.g., overall cost, feature representation, connectivity). obtaining solution conservation planning problem, important evaluate help understand trade-offs made prioritization. also useful compare different solutions .","code":""},{"path":"https://prioritizr.net/articles/package_overview.html","id":"evaluating-performance","dir":"Articles","previous_headings":"Evaluate the solution","what":"Evaluating performance","title":"Package overview","text":"Summary statistics can computed evaluate overall performance solution based certain criteria. following summaries can computed. following functions available summarize solution: Number summary: Calculate number planning units selected solution. Cost summary: Calculate total cost solution. Feature representation summary: Calculate well features represented solution. function can used type problem. Target coverage summary: Calculate well representation targets met solution. function can used problems contain targets. Boundary summary: Calculate total exposed boundary length (perimeter) associated solution. Connectivity summary: Calculate connectivity solution using symmetric connectivity data. Asymmetric connectivity summary: Calculate connectivity solution using asymmetric connectivity data.","code":"# calculate statistic eval_n_summary(p42, s42) ## # A tibble: 1 × 2 ##   summary     n ##   <chr>   <dbl> ## 1 overall    10 # calculate statistic eval_cost_summary(p42, s42) ## # A tibble: 1 × 2 ##   summary  cost ##   <chr>   <dbl> ## 1 overall 2005. # calculate statistics eval_feature_representation_summary(p42, s42) ## # A tibble: 5 × 5 ##   summary feature   total_amount absolute_held relative_held ##   <chr>   <chr>            <dbl>         <dbl>         <dbl> ## 1 overall feature_1         83.3          8.95         0.107 ## 2 overall feature_2         31.2          3.22         0.103 ## 3 overall feature_3         72.0          7.59         0.106 ## 4 overall feature_4         42.7          4.34         0.102 ## 5 overall feature_5         56.7          5.89         0.104 # calculate statistics eval_target_coverage_summary(p42, s42) ## # A tibble: 5 × 9 ##   feature   met   total_amount absolute_target absolute_held absolute_shortfall ##   <chr>     <lgl>        <dbl>           <dbl>         <dbl>              <dbl> ## 1 feature_1 TRUE          83.3            8.33          8.95                  0 ## 2 feature_2 TRUE          31.2            3.12          3.22                  0 ## 3 feature_3 TRUE          72.0            7.20          7.59                  0 ## 4 feature_4 TRUE          42.7            4.27          4.34                  0 ## 5 feature_5 TRUE          56.7            5.67          5.89                  0 ## # ℹ 3 more variables: relative_target <dbl>, relative_held <dbl>, ## #   relative_shortfall <dbl> # calculate statistic eval_boundary_summary(p42, s42) ## # A tibble: 1 × 2 ##   summary boundary ##   <chr>      <dbl> ## 1 overall      1.2 # create symmetric connectivity data # here we parametrize connectivity based on which planning units are # adjacent to each other cm <- adjacency_matrix(sim_pu_raster)  # calculate statistic eval_connectivity_summary(p42, s42, data = cm) ## # A tibble: 1 × 2 ##   summary connectivity ##   <chr>          <dbl> ## 1 overall           22 # create asymmetric connectivity data # here we parametrize connectivity by randomly simulating values acm <- matrix(runif(ncell(sim_pu_raster) ^ 2), ncol = ncell(sim_pu_raster))  # calculate statistic eval_asym_connectivity_summary(p42, s42, data = acm) ## # A tibble: 1 × 2 ##   summary asym_connectivity ##   <chr>               <dbl> ## 1 overall              48.0"},{"path":"https://prioritizr.net/articles/package_overview.html","id":"evaluating-relative-importance","dir":"Articles","previous_headings":"Evaluate the solution","what":"Evaluating relative importance","title":"Package overview","text":"Conservation plans can take long time implement. Since funding availability habitat quality can decline time, critical important places prioritization scheduled management early possible. instance, planning units solution might contain many rare species occur planning units. Alternatively, planning units might offer especially high return investment reduces costs considerably. consequence, conservation planners often need information planning units selected prioritization important overall success prioritization. achieve , conservation planners can use importance scores planning unit selected solution. Let’s generate prioritization can compare different importance methods.  following methods available computing importance scores. Replacement cost: Evaluate importance using replacement cost method (Cabeza & Moilanen 2006). method quantifies importance given planning unit decrease performance solution (based objective function) planning unit acquired (e.g., terms additional costs required meet feature targets). advantages method () accounts costs planning units, (ii) can applied multiple management zones, (iii) can applied objective function, (iv) can identify truly irreplaceable planning units (denoted infinite values). However, key disadvantage method, can take infeasible amount time complete large complex problems. * Ferrier method: Evaluate importance computing irreplaceability scores following Ferrier et al. (r-34?). advantages method () can computed relatively quickly moderate large-sized problems, (ii) calculates score feature within planning unit provide insight certain planning units important others. disadvantage method can applied conservation problems use targets single zone (.e., similar Marxan-type problems). * Rarity weighted richness: Evaluate importance computing rarity weighted richness scores (Williams et al. 1996). advantage method can computed quickly large problems. key disadvantage approach merely describes spatial patterns biodiversity, consider goals underpin conservation planning exercise. instance, account planning costs, management zones, objective functions, feature representation targets.  general, recommend using replacement cost scores small moderate sized problems (e.g., less 30,000 planning units) feasible . can take long time compute replacement cost scores, simply feasible compute scores particularly large problems. moderate large sized problems (e.g., 30,000 planning units), recommend using Ferrier method. explicitly accounts representation targets, unlike rarity weighted richness scores. almost never recommend using rarity weighted richness scores. consider criteria needed inform conservation decision making (Brown et al. 2015).","code":"# formulate the problem p43 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions()  # solve the problem s43 <- solve(p43) ## Gurobi Optimizer version 10.0.2 build v10.0.2rc0 (linux64) ##  ## CPU model: 11th Gen Intel(R) Core(TM) i7-1185G7 @ 3.00GHz, instruction set [SSE2|AVX|AVX2|AVX512] ## Thread count: 4 physical cores, 8 logical processors, using up to 1 threads ##  ## Optimize a model with 5 rows, 90 columns and 450 nonzeros ## Model fingerprint: 0x4bb5d283 ## Variable types: 0 continuous, 90 integer (90 binary) ## Coefficient statistics: ##   Matrix range     [2e-01, 9e-01] ##   Objective range  [2e+02, 2e+02] ##   Bounds range     [1e+00, 1e+00] ##   RHS range        [3e+00, 8e+00] ## Found heuristic solution: objective 2337.9617767 ## Presolve time: 0.00s ## Presolved: 5 rows, 90 columns, 450 nonzeros ## Variable types: 0 continuous, 90 integer (90 binary) ## Found heuristic solution: objective 2332.1004028 ## Root relaxation presolved: 5 rows, 90 columns, 450 nonzeros ##  ##  ## Root relaxation: objective 1.931582e+03, 12 iterations, 0.00 seconds (0.00 work units) ##  ##     Nodes    |    Current Node    |     Objective Bounds      |     Work ##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time ##  ##      0     0 1931.58191    0    4 2332.10040 1931.58191  17.2%     -    0s ## H    0     0                    1987.3985291 1931.58191  2.81%     -    0s ##  ## Explored 1 nodes (12 simplex iterations) in 0.00 seconds (0.00 work units) ## Thread count was 1 (of 8 available processors) ##  ## Solution count 3: 1987.4 2332.1 2337.96  ##  ## Optimal solution found (tolerance 1.00e-01) ## Best objective 1.987398529053e+03, best bound 1.931581907658e+03, gap 2.8085% # plot solution plot(   s43, col = c(\"grey90\", \"darkgreen\"), main = \"Solution\",   xlim = c(-0.1, 1.1), ylim = c(-0.1, 1.1), axes = FALSE ) # calculate replacement cost scores and make the solver quiet rc43 <-   p43 %>%   add_default_solver(gap = 0, verbose = FALSE) %>%   eval_replacement_importance(s43)  # plot replacement cost scores plot(   rc43, main = \"Replacement cost scores\",   xlim = c(-0.1, 1.1), ylim = c(-0.1, 1.1), axes = FALSE ) # calculate Ferrier scores and extract total score fs43 <- eval_ferrier_importance(p43, s43)[[\"total\"]]  # plot Ferrier scores plot(   fs43, main = \"Ferrier scores\",   xlim = c(-0.1, 1.1), ylim = c(-0.1, 1.1), axes = FALSE ) # calculate rarity weighted richness scores rwr43 <- eval_rare_richness_importance(p43, s43)  # plot rarity weighted richness scores plot(   rwr43, main = \"Rarity weighted richness scores\",   xlim = c(-0.1, 1.1), ylim = c(-0.1, 1.1), axes = FALSE )"},{"path":"https://prioritizr.net/articles/package_overview.html","id":"marxan-problems","dir":"Articles","previous_headings":"","what":"Marxan problems","title":"Package overview","text":"Although encourage users build tailor conservation planning problems suit needs, sometimes just simply easier use something ’re already familiar . marxan_problem() function provided convenient wrapper building solving Marxan-style conservation problems. users already conservation planning data formatted use Marxan, function can also read Marxan data files solve Marxan-style problems using exact algorithm solvers. Please note problems built using marxan_problem() function still solved way problem initialized using problem() function, therefore still require installation one solver packages. short example showing marxan_problem() function can used read Marxan input files solve function can used solve problem. Alternatively, rather using Marxan input file construct problem, can manually read Marxan data files input marxan_problem() function. Conservation planning problems built using marxan_problem() function can also customized. example, change decision type mp2 involve selecting proportion planing unit (using add_proportion_decisions() function).","code":"# set file path for Marxan input file minput <- system.file(\"extdata/marxan/input.dat\", package = \"prioritizr\")  # read Marxan input file mp <- marxan_problem(minput)  # print problem print(mp) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"bird1\", \"nvis2\", \"nvis8\", \"nvis9\", \"nvis14\", \"nvis20\" , … (17 total) ## │└•planning units: ## │ ├•data:       <data.frame> (1751 total) ## │ ├•costs:      continuous values (between 0 and 415692.1938) ## │ ├•extent:     NA ## │ └•CRS:        NA ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties: ## ││└•1:          boundary penalties (`penalty` = 1, `edge_factor` = 1, …) ## │├•targets:     relative targets (between 0.3 and 0.3) ## │├•constraints: ## ││├•1:          locked in constraints (317 planning units) ## ││└•2:          locked out constraints (1 planning units) ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # solve the problem ms <- solve(mp) ## Gurobi Optimizer version 10.0.2 build v10.0.2rc0 (linux64) ##  ## CPU model: 11th Gen Intel(R) Core(TM) i7-1185G7 @ 3.00GHz, instruction set [SSE2|AVX|AVX2|AVX512] ## Thread count: 4 physical cores, 8 logical processors, using up to 1 threads ##  ## Optimize a model with 10075 rows, 6780 columns and 24778 nonzeros ## Model fingerprint: 0x8a2a8131 ## Variable types: 0 continuous, 6780 integer (6780 binary) ## Coefficient statistics: ##   Matrix range     [5e-05, 4e+03] ##   Objective range  [8e+03, 4e+05] ##   Bounds range     [1e+00, 1e+00] ##   RHS range        [5e+03, 3e+05] ## Found heuristic solution: objective 1.255825e+08 ## Presolve removed 4707 rows and 3103 columns ## Presolve time: 0.04s ## Presolved: 5368 rows, 3677 columns, 12704 nonzeros ## Variable types: 0 continuous, 3677 integer (3677 binary) ## Found heuristic solution: objective 1.065946e+08 ## Root relaxation presolved: 5368 rows, 3677 columns, 12704 nonzeros ##  ##  ## Root relaxation: objective 9.975843e+07, 652 iterations, 0.01 seconds (0.01 work units) ##  ##     Nodes    |    Current Node    |     Objective Bounds      |     Work ##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time ##  ##      0     0 9.9758e+07    0   43 1.0659e+08 9.9758e+07  6.41%     -    0s ##  ## Explored 1 nodes (652 simplex iterations) in 0.06 seconds (0.10 work units) ## Thread count was 1 (of 8 available processors) ##  ## Solution count 2: 1.06595e+08 1.25582e+08  ##  ## Optimal solution found (tolerance 1.00e-01) ## Best objective 1.065946314895e+08, best bound 9.975842517354e+07, gap 6.4133% # since the Marxan data was in a tabular format, the solution is also returned # in a tabular format, so we will print the first six rows of the table # containing the solution head(ms) ##   id       cost status    xloc     yloc locked_in locked_out solution_1 ## 1  3      0.000      0 1116623 -4493479     FALSE      FALSE          0 ## 2 30   7527.275      3 1110623 -4496943     FALSE       TRUE          0 ## 3 56  37349.075      0 1092623 -4500408     FALSE      FALSE          0 ## 4 58  16959.021      0 1116623 -4500408     FALSE      FALSE          0 ## 5 84  34220.256      0 1098623 -4503872     FALSE      FALSE          0 ## 6 85 178907.584      0 1110623 -4503872     FALSE      FALSE          0 # load data pu <-   system.file(\"extdata/marxan/input/pu.dat\", package = \"prioritizr\") %>%   read.table(sep = \",\", header = TRUE) features <-   system.file(\"extdata/marxan/input/spec.dat\", package = \"prioritizr\") %>%   read.table(sep = \",\", header = TRUE) bound <-   system.file(\"extdata/marxan/input/bound.dat\", package = \"prioritizr\") %>%   read.table(sep = \"\\t\", header = TRUE) rij <-   system.file(\"extdata/marxan/input/puvspr.dat\", package = \"prioritizr\") %>%   read.table(sep = \",\", header = TRUE)  # build Marxan problem using data.frame objects mp2 <- marxan_problem(   x = pu, spec = features, puvspr = rij, bound = bound, blm = 0 )  # print problem print(mp2) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"bird1\", \"nvis2\", \"nvis8\", \"nvis9\", \"nvis14\", \"nvis20\" , … (17 total) ## │└•planning units: ## │ ├•data:       <data.frame> (1751 total) ## │ ├•costs:      continuous values (between 0 and 415692.1938) ## │ ├•extent:     NA ## │ └•CRS:        NA ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties: ## ││└•1:          boundary penalties (`penalty` = 0, `edge_factor` = 1, …) ## │├•targets:     relative targets (between 0.3 and 0.3) ## │├•constraints: ## ││├•1:          locked in constraints (317 planning units) ## ││└•2:          locked out constraints (1 planning units) ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation."},{"path":"https://prioritizr.net/articles/package_overview.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Package overview","text":"Hopefully, vignette provided informative overview prioritizr R package. examples using package, please see vignettes. Perhaps, one best ways learn new piece software just try . Test , try breaking , make mistakes, learn . recommend trying build conservation planning problems resemble face work—using built-example data sets. way can quickly verify problems build actually mean think mean. instance, can try playing around targets see effect solutions, try playing around penalties see effect solutions. Finally, questions using package suggestions , please post issue package’s online coding repository.","code":""},{"path":[]},{"path":"https://prioritizr.net/articles/prioritizr.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Getting started","text":"aim tutorial provide short introduction prioritizr R package. also intended help conservation planners familiar Marxan decision support tool (Ball et al. 2009) start using package work.","code":""},{"path":"https://prioritizr.net/articles/prioritizr.html","id":"data","dir":"Articles","previous_headings":"","what":"Data","title":"Getting started","text":"Let’s load packages data used tutorial. Since tutorial uses data prioritizrdata R package, please ensure installed. data used tutorial obtained Introduction Marxan course Australian Government’s National Vegetation Information System. Let’s look planning unit data. tas_pu object contains planning units represented spatial polygons (.e., sf::st_sf() object). object three columns denote following information planning unit: unique identifier (id), unimproved land value (cost), current conservation status (locked_in). Planning units least half area overlapping existing protected areas denoted locked TRUE value, otherwise denoted value FALSE.   Now, let’s look conservation feature data. tas_features object describes spatial distribution features. Specifically, feature data multi-layer raster (.e., terra::rast() object). layer corresponds different vegetation community. Within layer, cells values denote presence (using value 1) absence (using value 0) vegetation community across study area.","code":"# load packages library(prioritizrdata) library(prioritizr) library(sf) library(terra) library(vegan) library(cluster)  # load planning unit data tas_pu <- get_tas_pu()  # load feature data tas_features <- get_tas_features() # print planning unit data print(tas_pu) ## Simple feature collection with 1130 features and 4 fields ## Geometry type: MULTIPOLYGON ## Dimension:     XY ## Bounding box:  xmin: 298809.6 ymin: 5167775 xmax: 613818.8 ymax: 5502544 ## Projected CRS: WGS 84 / UTM zone 55S ## # A tibble: 1,130 × 5 ##       id  cost locked_in locked_out                                         geom ##    <int> <dbl> <lgl>     <lgl>                                <MULTIPOLYGON [m]> ##  1     1 60.2  FALSE     TRUE       (((328497 5497704, 326783.8 5500050, 326775… ##  2     2 19.9  FALSE     FALSE      (((307121.6 5490487, 305344.4 5492917, 3053… ##  3     3 59.7  FALSE     TRUE       (((321726.1 5492382, 320111 5494593, 320127… ##  4     4 32.4  FALSE     FALSE      (((304314.5 5494324, 304342.2 5494287, 3043… ##  5     5 26.2  FALSE     FALSE      (((314958.5 5487057, 312336 5490646, 312339… ##  6     6 51.3  FALSE     FALSE      (((327904.3 5491218, 326594.6 5493012, 3284… ##  7     7 32.3  FALSE     FALSE      (((308194.1 5481729, 306601.2 5483908, 3066… ##  8     8 38.4  FALSE     FALSE      (((322792.7 5483624, 319965.3 5487497, 3199… ##  9     9  3.55 FALSE     FALSE      (((334896.6 5490731, 335610.4 5492490, 3357… ## 10    10  1.83 FALSE     FALSE      (((356377.1 5487952, 353903.1 5487635, 3538… ## # ℹ 1,120 more rows # plot map of planning unit costs plot(st_as_sf(tas_pu[, \"cost\"]), main = \"Planning unit costs\") # plot map of planning unit coverage by protected areas plot(st_as_sf(tas_pu[, \"locked_in\"]), main = \"Protected area coverage\") # print planning unit data print(tas_features) ## class       : SpatRaster  ## dimensions  : 398, 359, 33  (nrow, ncol, nlyr) ## resolution  : 1000, 1000  (x, y) ## extent      : 288801.7, 647801.7, 5142976, 5540976  (xmin, xmax, ymin, ymax) ## coord. ref. : WGS 84 / UTM zone 55S (EPSG:32755)  ## source      : tas_features.tif  ## names       : Banks~lands, Bould~marks, Calli~lands, Cool ~orest, Eucal~hyll), Eucal~torey, ...  ## min values  :           0,           0,           0,           0,           0,           0, ...  ## max values  :           1,           1,           1,           1,           1,           1, ... # plot map of the first four vegetation classes plot(tas_features[[1:4]])"},{"path":"https://prioritizr.net/articles/prioritizr.html","id":"problem-formulation","dir":"Articles","previous_headings":"","what":"Problem formulation","title":"Getting started","text":"Now formulate conservation planing problem. achieve , first specify objects contain planning unit feature data (using problem() function). Next, specify want use minimum set objective function (using add_min_set_objective() function). objective function indicates wish minimize total cost planning units selected prioritization. specify boundary penalties reduce spatial fragmentation resulting prioritization (using add_boundary_penalties() function; see Calibrating trade-offs vignette details calibrating penalty value). also specify representation targets ensure resulting prioritization provides adequate coverage vegetation community (using add_relative_targets() function). Specifically, specify targets ensure least 17% spatial extent vegetation community (based Aichi Target 11). Additionally, set constraints ensure planning units predominately covered existing protected areas selected prioritization (using add_locked_in_constraints() function). Finally, specify prioritization either select – select – planning units prioritization (using add_binary_decisions() function).","code":"# build problem p1 <-   problem(tas_pu, tas_features, cost_column = \"cost\") %>%   add_min_set_objective() %>%   add_boundary_penalties(penalty = 0.005) %>%   add_relative_targets(0.17) %>%   add_locked_in_constraints(\"locked_in\") %>%   add_binary_decisions()  # print problem print(p1) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"Banksia woodlands\" , … (33 total) ## │└•planning units: ## │ ├•data:       <sftbl_dftbldata.frame> (1130 total) ## │ ├•costs:      continuous values (between 0.1925 and 61.9273) ## │ ├•extent:     298809.5764, 5167774.5993, 613818.7743, 5502543.7119 (xmin, ymin, xmax, ymax) ## │ └•CRS:        WGS 84 / UTM zone 55S (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties: ## ││└•1:          boundary penalties (`penalty` = 0.005, `edge_factor` = 0.5, …) ## │├•targets:     relative targets (between 0.17 and 0.17) ## │├•constraints: ## ││└•1:          locked in constraints (257 planning units) ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation."},{"path":"https://prioritizr.net/articles/prioritizr.html","id":"prioritization","dir":"Articles","previous_headings":"","what":"Prioritization","title":"Getting started","text":"can now solve problem formulation (p1) generate prioritization (using solve() function). prioritizr R package supports range different exact algorithm solvers, including Gurobi, IBM CPLEX, CBC, HiGHS, Rsymphony, lpsymphony. Although benefits limitations associated different solvers, return similar results. Note need least one solver installed system generate prioritizations. Since specify solver building problem, prioritizr R package automatically select best available solver installed. recommend using Gurobi solver possible, used tutorial (see Gurobi Installation Guide vignette installation instructions). solving problem, prioritization stored solution_1 column s1 object.","code":"# solve problem s1 <- solve(p1) ## Gurobi Optimizer version 10.0.2 build v10.0.2rc0 (linux64) ##  ## CPU model: 11th Gen Intel(R) Core(TM) i7-1185G7 @ 3.00GHz, instruction set [SSE2|AVX|AVX2|AVX512] ## Thread count: 4 physical cores, 8 logical processors, using up to 1 threads ##  ## Optimize a model with 6329 rows, 4278 columns and 20749 nonzeros ## Model fingerprint: 0xf830e2c0 ## Variable types: 0 continuous, 4278 integer (4278 binary) ## Coefficient statistics: ##   Matrix range     [2e-06, 6e+01] ##   Objective range  [5e-01, 2e+02] ##   Bounds range     [1e+00, 1e+00] ##   RHS range        [2e-01, 2e+03] ## Found heuristic solution: objective 36789.525254 ## Found heuristic solution: objective 26818.653495 ## Presolve removed 1909 rows and 1249 columns ## Presolve time: 0.04s ## Presolved: 4420 rows, 3029 columns, 11081 nonzeros ## Found heuristic solution: objective 24077.930942 ## Variable types: 0 continuous, 3029 integer (3029 binary) ## Found heuristic solution: objective 22854.296392 ## Root relaxation presolve removed 8 rows and 6 columns ## Root relaxation presolved: 4412 rows, 3023 columns, 11060 nonzeros ##  ##  ## Root relaxation: objective 1.799626e+04, 1254 iterations, 0.04 seconds (0.09 work units) ##  ##     Nodes    |    Current Node    |     Objective Bounds      |     Work ##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time ##  ##      0     0 17996.2587    0 1115 22854.2964 17996.2587  21.3%     -    0s ## H    0     0                    21408.703461 17996.2587  15.9%     -    0s ## H    0     0                    21110.145782 17996.2587  14.8%     -    0s ##      0     0 18090.8922    0 1144 21110.1458 18090.8922  14.3%     -    0s ## H    0     0                    21076.240706 18090.8922  14.2%     -    0s ## H    0     0                    20161.670985 18090.8922  10.3%     -    0s ## H    0     0                    19444.233763 18090.8922  6.96%     -    0s ##  ## Cutting planes: ##   MIR: 2 ##   GUB cover: 1 ##   RLT: 1 ##  ## Explored 1 nodes (1377 simplex iterations) in 0.41 seconds (0.78 work units) ## Thread count was 1 (of 8 available processors) ##  ## Solution count 9: 19444.2 20161.7 21076.2 ... 36789.5 ##  ## Optimal solution found (tolerance 1.00e-01) ## Best objective 1.944423376255e+04, best bound 1.809089224740e+04, gap 6.9601% # plot map of prioritization plot(   st_as_sf(s1[, \"solution_1\"]), main = \"Prioritization\",   pal = c(\"grey90\", \"darkgreen\") )"},{"path":"https://prioritizr.net/articles/prioritizr.html","id":"feature-representation","dir":"Articles","previous_headings":"","what":"Feature representation","title":"Getting started","text":"Let’s examine well vegetation communities represented existing protected areas prioritization.   can see representation vegetation communities existing protected areas remarkably poor. example, many vegetation communities nearly zero coverage existing protected areas. words, almost entirely absent existing protected areas. can also see vegetation communities least 17% coverage prioritization – meaning meets representation targets features.","code":"# create column with existing protected areas tas_pu$pa <- round(tas_pu$locked_in)  # calculate feature representation statistics based on existing protected areas tc_pa <- eval_target_coverage_summary(p1, tas_pu[, \"pa\"]) print(tc_pa) ## # A tibble: 33 × 9 ##    feature   met   total_amount absolute_target absolute_held absolute_shortfall ##    <chr>     <lgl>        <dbl>           <dbl>         <dbl>              <dbl> ##  1 Banksia … TRUE          2.00           0.340         0.367              0     ##  2 Boulders… TRUE        140.            23.9          65.5                0     ##  3 Callitri… FALSE         6.00           1.02          0.487              0.533 ##  4 Cool tem… TRUE       7257.          1234.         2992.                 0     ##  5 Eucalypt… TRUE       5699.           969.         1398.                 0     ##  6 Eucalypt… FALSE      9180.          1561.         1030.               531.    ##  7 Eucalypt… TRUE         38.0            6.46         15.1                0     ##  8 Eucalypt… FALSE      1908.           324.          189.               135.    ##  9 Eucalypt… FALSE       388.            65.9          27.4               38.6   ## 10 Eucalypt… TRUE       6145.          1045.         1449.                 0     ## # ℹ 23 more rows ## # ℹ 3 more variables: relative_target <dbl>, relative_held <dbl>, ## #   relative_shortfall <dbl> # calculate  feature representation statistics based on the prioritization tc_s1 <- eval_target_coverage_summary(p1, s1[, \"solution_1\"]) print(tc_s1) ## # A tibble: 33 × 9 ##    feature   met   total_amount absolute_target absolute_held absolute_shortfall ##    <chr>     <lgl>        <dbl>           <dbl>         <dbl>              <dbl> ##  1 Banksia … TRUE          2.00           0.340         0.367                  0 ##  2 Boulders… TRUE        140.            23.9          68.8                    0 ##  3 Callitri… TRUE          6.00           1.02          1.49                   0 ##  4 Cool tem… TRUE       7257.          1234.         3239.                     0 ##  5 Eucalypt… TRUE       5699.           969.         1726.                     0 ##  6 Eucalypt… TRUE       9180.          1561.         1808.                     0 ##  7 Eucalypt… TRUE         38.0            6.46         18.0                    0 ##  8 Eucalypt… TRUE       1908.           324.          325.                     0 ##  9 Eucalypt… TRUE        388.            65.9          69.3                    0 ## 10 Eucalypt… TRUE       6145.          1045.         2055.                     0 ## # ℹ 23 more rows ## # ℹ 3 more variables: relative_target <dbl>, relative_held <dbl>, ## #   relative_shortfall <dbl> # explore representation by existing protected areas ## calculate number of features adequately represented by existing protected ## areas sum(tc_pa$met) ## [1] 18 ## summarize representation (values show percent coverage) summary(tc_pa$relative_held * 100) ##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  ##   0.000   3.163  18.363  23.827  39.649  93.002 ## visualize representation  (values show percent coverage) hist(tc_pa$relative_held * 100,      main = \"Feature representation by existing protected areas\",      xlim = c(0, 100),      xlab = \"Percent coverage of features (%)\") # explore representation by prioritization ## summarize representation (values show percent coverage) summary(tc_s1$relative_held * 100) ##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  ##   17.02   18.56   30.29   36.82   48.96  100.00 ## calculate number of features adequately represented by the prioritization sum(tc_s1$met) ## [1] 33 ## visualize representation  (values show percent coverage) hist(   tc_s1$relative_held * 100,   main = \"Feature representation by prioritization\",   xlim = c(0, 100),   xlab = \"Percent coverage of features (%)\" )"},{"path":"https://prioritizr.net/articles/prioritizr.html","id":"irreplaceability","dir":"Articles","previous_headings":"","what":"Irreplaceability","title":"Getting started","text":"generating prioritization, can examine relative importance planning units selected prioritization. can useful identify critically important planning units conservation – words, places contain biodiversity features represented anywhere else – schedule implementation prioritization. achieve , use Ferrier metric (Ferrier et al. 2000).","code":"# calculate irreplaceability irrep_s1 <- eval_ferrier_importance(p1, s1[\"solution_1\"]) print(irrep_s1) ## Simple feature collection with 1130 features and 34 fields ## Geometry type: MULTIPOLYGON ## Dimension:     XY ## Bounding box:  xmin: 298809.6 ymin: 5167775 xmax: 613818.8 ymax: 5502544 ## Projected CRS: WGS 84 / UTM zone 55S ## # A tibble: 1,130 × 35 ##    `Banksia woodlands` Boulders/rock with algae, lichen…¹ Callitris forests an…² ##  *               <dbl>                              <dbl>                  <dbl> ##  1                   0                                  0                      0 ##  2                   0                                  0                      0 ##  3                   0                                  0                      0 ##  4                   0                                  0                      0 ##  5                   0                                  0                      0 ##  6                   0                                  0                      0 ##  7                   0                                  0                      0 ##  8                   0                                  0                      0 ##  9                   0                                  0                      0 ## 10                   0                                  0                      0 ## # ℹ 1,120 more rows ## # ℹ abbreviated names: ## #   ¹​`Boulders/rock with algae, lichen or scattered plants, or alpine fjaeldmarks`, ## #   ²​`Callitris forests and woodlands` ## # ℹ 32 more variables: `Cool temperate rainforest` <dbl>, ## #   `Eucalyptus (+/- tall) open forest with a dense broad-leaved and/or tree-fern understorey (wet sclerophyll)` <dbl>, ## #   `Eucalyptus open forests with a shrubby understorey` <dbl>, … # manually coerce values for planning units not selected in prioritization # to NA, so that they are shown in white irrep_s1$plot_total <- irrep_s1$total irrep_s1$plot_total[s1$solution_1 < 0.5] <- NA_real_  # plot map of overall importance scores plot(st_as_sf(irrep_s1[, \"plot_total\"]), main = \"Overall importance\")"},{"path":"https://prioritizr.net/articles/prioritizr.html","id":"portfolios","dir":"Articles","previous_headings":"","what":"Portfolios","title":"Getting started","text":"Conservation planning exercises often involve generating multiple different prioritizations. can help decision makers consider different options, provide starting points building consensus among stakeholders. generate range different prioritizations given problem formulation, can use portfolio functions. use gap portfolio generate 1000 solutions within 20% optimality. Please note need Gurobi solver installed use specific portfolio. don’t access Gurobi, try using shuffle portfolio instead (using add_shuffle_portfolio() function). generating prioritizations, now want way visualize . onerous look every prioritization individually, use statistical analyses help us. can visualize differences different prioritizations – based planning units selected – using hierarchical cluster analysis (Harris et al. 2014).  can see approximately six main groups prioritizations portfolio. explore different groups, let’s conduct another cluster analysis (.e., k-medoids analysis) extract representative prioritization groups. words, run another statistical analysis find central prioritization within group.","code":"# create new problem with a portfolio added to it p2 <-   p1 %>%   add_gap_portfolio(number_solutions = 1000, pool_gap = 0.2)  # print problem print(p2) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"Banksia woodlands\" , … (33 total) ## │└•planning units: ## │ ├•data:       <sftbl_dftbldata.frame> (1130 total) ## │ ├•costs:      continuous values (between 0.1925 and 61.9273) ## │ ├•extent:     298809.5764, 5167774.5993, 613818.7743, 5502543.7119 (xmin, ymin, xmax, ymax) ## │ └•CRS:        WGS 84 / UTM zone 55S (projected) ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties: ## ││└•1:          boundary penalties (`penalty` = 0.005, `edge_factor` = 0.5, …) ## │├•targets:     relative targets (between 0.17 and 0.17) ## │├•constraints: ## ││└•1:          locked in constraints (257 planning units) ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   gap portfolio (`number_solutions` = 1000, `pool_gap` = 0.2) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # generate prioritizations prt <- solve(p2) ## Gurobi Optimizer version 10.0.2 build v10.0.2rc0 (linux64) ##  ## CPU model: 11th Gen Intel(R) Core(TM) i7-1185G7 @ 3.00GHz, instruction set [SSE2|AVX|AVX2|AVX512] ## Thread count: 4 physical cores, 8 logical processors, using up to 1 threads ##  ## Optimize a model with 6329 rows, 4278 columns and 20749 nonzeros ## Model fingerprint: 0xf830e2c0 ## Variable types: 0 continuous, 4278 integer (4278 binary) ## Coefficient statistics: ##   Matrix range     [2e-06, 6e+01] ##   Objective range  [5e-01, 2e+02] ##   Bounds range     [1e+00, 1e+00] ##   RHS range        [2e-01, 2e+03] ## Found heuristic solution: objective 36789.525254 ## Found heuristic solution: objective 26818.653495 ## Presolve removed 1434 rows and 258 columns ## Presolve time: 0.02s ## Presolved: 4895 rows, 4020 columns, 12064 nonzeros ## Variable types: 0 continuous, 4020 integer (4020 binary) ## Found heuristic solution: objective 25741.299203 ## Root relaxation presolved: 4895 rows, 4020 columns, 12064 nonzeros ##  ##  ## Root relaxation: objective 1.799626e+04, 1497 iterations, 0.05 seconds (0.10 work units) ##  ##     Nodes    |    Current Node    |     Objective Bounds      |     Work ##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time ##  ##      0     0 17996.2587    0 1216 25741.2992 17996.2587  30.1%     -    0s ## H    0     0                    22020.805500 17996.2587  18.3%     -    0s ## H    0     0                    20449.688378 17996.2587  12.0%     -    0s ##      0     0 18090.6275    0 1238 20449.6884 18090.6275  11.5%     -    0s ## H    0     0                    19499.543014 18090.6275  7.23%     -    0s ##      0     0 18106.4253    0 1203 19499.5430 18106.4253  7.14%     -    0s ##      0     0 18106.5097    0 1128 19499.5430 18106.5097  7.14%     -    0s ##      0     0 18108.9518    0 1121 19499.5430 18108.9518  7.13%     -    0s ##      0     0 18108.9518    0 1121 19499.5430 18108.9518  7.13%     -    1s ##      0     2 18109.0152    0 1121 19499.5430 18109.0152  7.13%     -    1s ## H    3     3                    19238.085224 18121.7633  5.80%   134    1s ## H  158   158                    19215.171695 18121.7633  5.69%  43.1    1s ## H  314   314                    19035.250720 18121.7633  4.80%  25.3    1s ## H  429   429                    19028.529805 18121.7633  4.77%  19.5    1s ## H  577   564                    18595.762444 18121.7633  2.55%  14.8    2s ## H  578   565                    18545.045971 18121.9629  2.28%  15.0    2s ## H  593     3                    18395.725721 18129.8915  1.45%  14.6    4s ##    813   221          -  219      18395.7257 18168.8755  1.23%  22.6    5s ##  ## Cutting planes: ##   MIR: 2 ##   Flow cover: 4 ##   GUB cover: 1 ##   Zero half: 4 ##   RLT: 5 ##  ## Explored 2090 nodes (43754 simplex iterations) in 6.75 seconds (10.88 work units) ## Thread count was 1 (of 8 available processors) ##  ## Solution count 1000: 18395.7 18403.7 18409.4 ... 20315.8 ##  ## Optimal solution found (tolerance 1.00e-01) ## Best objective 1.839572572128e+04, best bound 1.828619545068e+04, gap 0.5954% print(prt) ## Simple feature collection with 1130 features and 1004 fields ## Geometry type: MULTIPOLYGON ## Dimension:     XY ## Bounding box:  xmin: 298809.6 ymin: 5167775 xmax: 613818.8 ymax: 5502544 ## Projected CRS: WGS 84 / UTM zone 55S ## # A tibble: 1,130 × 1,005 ##       id  cost locked_in locked_out solution_1 solution_2 solution_3 solution_4 ##    <int> <dbl> <lgl>     <lgl>           <dbl>      <dbl>      <dbl>      <dbl> ##  1     1 60.2  FALSE     TRUE                0          0          0          0 ##  2     2 19.9  FALSE     FALSE               0          0          0          0 ##  3     3 59.7  FALSE     TRUE                0          0          0          0 ##  4     4 32.4  FALSE     FALSE               0          0          0          0 ##  5     5 26.2  FALSE     FALSE               0          0          0          0 ##  6     6 51.3  FALSE     FALSE               0          0          0          0 ##  7     7 32.3  FALSE     FALSE               0          0          0          0 ##  8     8 38.4  FALSE     FALSE               0          0          0          0 ##  9     9  3.55 FALSE     FALSE               0          0          0          0 ## 10    10  1.83 FALSE     FALSE               0          0          0          0 ## # ℹ 1,120 more rows ## # ℹ 997 more variables: solution_5 <dbl>, solution_6 <dbl>, solution_7 <dbl>, ## #   solution_8 <dbl>, solution_9 <dbl>, solution_10 <dbl>, solution_11 <dbl>, ## #   solution_12 <dbl>, solution_13 <dbl>, solution_14 <dbl>, solution_15 <dbl>, ## #   solution_16 <dbl>, solution_17 <dbl>, solution_18 <dbl>, solution_19 <dbl>, ## #   solution_20 <dbl>, solution_21 <dbl>, solution_22 <dbl>, solution_23 <dbl>, ## #   solution_24 <dbl>, solution_25 <dbl>, solution_26 <dbl>, … # extract solutions prt_results <- sf::st_drop_geometry(prt) prt_results <- prt_results[, startsWith(names(prt_results), \"solution_\")]  # calculate pair-wise distances between different prioritizations for analysis prt_dists <- vegan::vegdist(t(prt_results), method = \"jaccard\", binary = TRUE)  # run cluster analysis prt_clust <- hclust(as.dist(prt_dists), method = \"average\")  # visualize clusters opar <- par() par(oma = c(0, 0, 0, 0), mar= c(0, 4.1, 1.5, 2.1)) plot(   prt_clust, labels = FALSE, sub = NA, xlab = \"\",   main = \"Different prioritizations in portfolio\" ) suppressWarnings(par(opar)) # run k-medoids analysis prt_med <- pam(prt_dists, k = 6)  # extract names of prioritizations that are most central for each group. prt_med_names <- prt_med$medoids print(prt_med_names) ## [1] \"solution_189\" \"solution_117\" \"solution_308\" \"solution_490\" \"solution_682\" ## [6] \"solution_930\" # create a copy of prt and set values for locked in planning units to -1 # so we can easily visualize differences between prioritizations prt2 <- prt[, prt_med_names] prt2[which(tas_pu$locked_in > 0.5), prt_med_names] <- -1  # plot a map showing main different prioritizations # dark grey: locked in planning units # grey: planning units not selected # green: selected planning units plot(st_as_sf(prt2), pal = c(\"grey60\", \"grey90\", \"darkgreen\"))"},{"path":"https://prioritizr.net/articles/prioritizr.html","id":"marxan-compatibility","dir":"Articles","previous_headings":"","what":"Marxan compatibility","title":"Getting started","text":"prioritizr R package provides functionality help Marxan users generate prioritizations. Specifically, can import conservation planning data prepared Marxan, can generate prioritizations using similar problem formulation Marxan (based Beyer et al. 2016). Indeed, problem formulation presented earlier vignette similar used Marxan. key difference problem formulation specified earlier uses “hard constraints” feature representation, Marxan uses “soft constraints” feature representation. means prioritization generated earlier mathematically guaranteed reach targets features. However, used Marxan generate prioritization, produced prioritization fail reach targets (depending Species Penalty Factors used generate prioritization). addition differences terms problem formulation, prioritizr R package uses exact algorithms – instead simulated annealing algorithm – ensures obtain prioritizations near optimal. show prioritizr R package can import Marxan data generate prioritization. begin , let’s import conservation planning data prepared Marxan. importing data, can now generate prioritization based Marxan problem formulation (using marxan_problem() function). Please note function generate prioritizations using Marxan. Instead, uses data create optimization problem formulation similar Marxan – using hard constraints instead soft constraints – uses exact algorithm solver generate prioritization.","code":"# import data ## planning unit data pu_path <- system.file(\"extdata/marxan/input/pu.dat\", package = \"prioritizr\") pu_data <- read.csv(pu_path, header = TRUE, stringsAsFactors = FALSE) print(head(pu_data)) ##   id       cost status    xloc     yloc ## 1  3      0.000      0 1116623 -4493479 ## 2 30   7527.275      3 1110623 -4496943 ## 3 56  37349.075      0 1092623 -4500408 ## 4 58  16959.021      0 1116623 -4500408 ## 5 84  34220.256      0 1098623 -4503872 ## 6 85 178907.584      0 1110623 -4503872 ## feature data spec_path <- system.file(   \"extdata/marxan/input/spec.dat\", package = \"prioritizr\" ) spec_data <- read.csv(spec_path, header = TRUE, stringsAsFactors = FALSE) print(head(spec_data)) ##   id prop spf   name ## 1 10  0.3   1  bird1 ## 2 11  0.3   1  nvis2 ## 3 12  0.3   1  nvis8 ## 4 13  0.3   1  nvis9 ## 5 14  0.3   1 nvis14 ## 6 15  0.3   1 nvis20 ## amount of each feature within each planning unit data puvspr_path <- system.file(   \"extdata/marxan/input/puvspr.dat\", package = \"prioritizr\" ) puvspr_data <- read.csv(puvspr_path, header = TRUE, stringsAsFactors = FALSE) print(head(puvspr_data)) ##   species  pu     amount ## 1      26  56 120.344884 ## 2      26  58  45.167010 ## 3      26  84  68.047375 ## 4      26  85   9.735624 ## 5      26  86   7.803476 ## 6      26 111 478.327417 ## boundary data bound_path <- system.file(   \"extdata/marxan/input/bound.dat\", package = \"prioritizr\" ) bound_data <- read.table(bound_path, header = TRUE, stringsAsFactors = FALSE) print(head(bound_data)) ##   id1 id2 boundary ## 1   3   3    16000 ## 2   3  30     4000 ## 3   3  58     4000 ## 4  30  30    12000 ## 5  30  58     4000 ## 6  30  85     4000 # create problem p3 <- marxan_problem(   pu_data, spec_data, puvspr_data, bound_data, blm = 0.0005 )  # print problem print(p3) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"bird1\", \"nvis2\", \"nvis8\", \"nvis9\", \"nvis14\", \"nvis20\" , … (17 total) ## │└•planning units: ## │ ├•data:       <data.frame> (1751 total) ## │ ├•costs:      continuous values (between 0 and 415692.1938) ## │ ├•extent:     NA ## │ └•CRS:        NA ## ├•formulation ## │├•objective:   minimum set objective ## │├•penalties: ## ││└•1:          boundary penalties (`penalty` = 5e-04, `edge_factor` = 1, …) ## │├•targets:     relative targets (between 0.3 and 0.3) ## │├•constraints: ## ││├•1:          locked in constraints (317 planning units) ## ││└•2:          locked out constraints (1 planning units) ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # solve problem s3 <- solve(p3) ## Gurobi Optimizer version 10.0.2 build v10.0.2rc0 (linux64) ##  ## CPU model: 11th Gen Intel(R) Core(TM) i7-1185G7 @ 3.00GHz, instruction set [SSE2|AVX|AVX2|AVX512] ## Thread count: 4 physical cores, 8 logical processors, using up to 1 threads ##  ## Optimize a model with 10075 rows, 6780 columns and 24778 nonzeros ## Model fingerprint: 0x37d7a0a1 ## Variable types: 0 continuous, 6780 integer (6780 binary) ## Coefficient statistics: ##   Matrix range     [5e-05, 4e+03] ##   Objective range  [4e+00, 4e+05] ##   Bounds range     [1e+00, 1e+00] ##   RHS range        [5e+03, 3e+05] ## Found heuristic solution: objective 1.221202e+08 ## Presolve removed 4707 rows and 3103 columns ## Presolve time: 0.04s ## Presolved: 5368 rows, 3677 columns, 12704 nonzeros ## Variable types: 0 continuous, 3677 integer (3677 binary) ## Found heuristic solution: objective 1.009944e+08 ## Root relaxation presolved: 5368 rows, 3677 columns, 12704 nonzeros ##  ##  ## Root relaxation: objective 9.564790e+07, 521 iterations, 0.01 seconds (0.01 work units) ##  ##     Nodes    |    Current Node    |     Objective Bounds      |     Work ##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time ##  ##      0     0 9.5648e+07    0   20 1.0099e+08 9.5648e+07  5.29%     -    0s ##  ## Explored 1 nodes (521 simplex iterations) in 0.05 seconds (0.10 work units) ## Thread count was 1 (of 8 available processors) ##  ## Solution count 2: 1.00994e+08 1.2212e+08  ##  ## Optimal solution found (tolerance 1.00e-01) ## Best objective 1.009944489031e+08, best bound 9.564790440581e+07, gap 5.2939% # print first six rows of solution object print(head(s3)) ##   id       cost status    xloc     yloc locked_in locked_out solution_1 ## 1  3      0.000      0 1116623 -4493479     FALSE      FALSE          0 ## 2 30   7527.275      3 1110623 -4496943     FALSE       TRUE          0 ## 3 56  37349.075      0 1092623 -4500408     FALSE      FALSE          0 ## 4 58  16959.021      0 1116623 -4500408     FALSE      FALSE          0 ## 5 84  34220.256      0 1098623 -4503872     FALSE      FALSE          0 ## 6 85 178907.584      0 1110623 -4503872     FALSE      FALSE          0"},{"path":"https://prioritizr.net/articles/prioritizr.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Getting started","text":"tutorial shows prioritizr R package can used build conservation problem, generate prioritization, evaluate . Although explored just functions, package provides many different functions can build custom-tailor conservation planning problems suit needs. learn package, please see package vignettes overview package, instructions installing Gurobi optimization suite, benchmarks comparing performance different solvers, record publications cited package. addition tutorial, package also provides tutorials incorporating connectivity prioritizations, calibrating trade-offs different criteria (e.g., total cost spatial fragmentation), creating prioritizations multiple management zones management actions.","code":""},{"path":[]},{"path":[]},{"path":"https://prioritizr.net/articles/publication_record.html","id":"section","dir":"Articles","previous_headings":"Research articles","what":"2023","title":"Publication record","text":"Alves F, Banks SC, Edworthy M, Stojanovic D, Langmore NE, Heinsohn R (2023) Using conservation genetics prioritise management options endangered songbird. Heredity, press: DOI:10.1038/s41437-023-00609-6. Boussarie G, Kopp D, Lavialle G, Mouchet M, Morfin M (2023) Marine spatial planning solve increasing conflicts sea: framework prioritizing offshore windfarms marine protected areas. Journal Environmental Management, 339: 117857. Buenafe KCV, Dunn DC, Everett JD, Brito-Morales , Schoeman DS, Hanson JO, Dabalà , Neubert S, Cannicci S, Kaschner K, Richardson AJ (2023) metric-based framework climate-smart conservation planning. Ecological Applications, press: DOI:10.1002/eap.2852. Chowdhury S, Zalucki MP, Hanson JO, Tiatragul S, Green D, Watson JEM, Fuller RA (2023) Three quarters insects insufficiently covered protected areas. One Earth, 6: 1–8. Engert J Laurance SG (2023) Economics optics influence funding ecological restoration nation-wide program. Environmental Research Letters, 18: 054020. Faure-Beaulieu N, Lombard , Olbers J, Goodall V, da Silva C, Daly R, Jordaan G, Kerwath SE, Kock , Mann BQ, Murray TS, Albano P, Cliff G, dos Santos NA, Gennari E, Hammerschlag N, Bester-van der Merwe AE, Watson R, Andreotti S, Bernard ATF, Cowley PD, De Vos L, Drobniewska N, Elston C, Fallows C, Rogers TD, Smith G, van Staden M, de Villiers P, Paulet TG, Harris J (2023). systematic conservation plan identifying critical areas improved chondrichthyan protection South Africa. Biological Conservation, 284: 110163. Finn RJR, Chalifour L, Gergel SE, Hinch SG, Scott DC, Martin TG (2023) Using systematic conservation planning inform restoration freshwater habitat connectivity salmon. Conservation Science Practice, press: DOI:10.1111/csp2.12973. Li Y, Zhao X, Xia M, Hou H (2023). Genetic epigenetic variation Trapa bispinosa slope gradient: case study subtropical freshwater lake. Aquatic Botany, 188: 103679. Liczner AR, Schuster R, Richardson LL, Colla SR (2023) Identifying conservation priority areas North American bumble bee species Canada current future climate scenarios. Conservation Science Practice, press: DOI:10.1111/csp2.12994. Massante JC, de Castro AF, de Medeiros Sarmento PS, da Silva GM, Caldeira CF, Ramos S, Gastauer M (2023) Species selection optimizing mine land rehabilitation: Integrating functional traits minimum set prioritization technique. Ecological Engineering, 194: 107039. Shen X, Liu M, Hanson JO, Wang J, Locke H, Watson JEM, Ellis EC, Li S, Ma K (2023) Countries’ differentiated responsibilities fulfill area-based conservation targets Kunming-Montreal Global Biodiversity Framework. One Earth, press: DOI:10.1016/j.oneear.2023.04.007. von Takach B, Sargent H, Penton CE, Rick K, Murphy BP, Neave G, Davies HF, Hill BM, Banks SC (2023) Population genomics conservation management threatened black-footed tree-rat (Mesembriomys gouldii) northern Australia. Heredity, press: DOI:10.1038/s41437-023-00601-0. Vyas , Dwivedi R (2023) Global Regions, Biological Diversity, Urban Land Significance. Applied Science Engineering Journal Advanced Research, 2: 1–7.","code":""},{"path":"https://prioritizr.net/articles/publication_record.html","id":"section-1","dir":"Articles","previous_headings":"Research articles","what":"2022","title":"Publication record","text":"Algador D (2022) Effective conservation planning Iberian amphibians based regionalization climate driven range shifts. Conservation Biology, press: e14026. André LV, Van Wynsberge S, Chinain M, Gatti CMI, Liao V, Andréfouët S (2022) Spatial solutions impacts reshuffling coastal management priorities small islands limited diversification opportunities. Sustainability, 14: 3871. de Assis Barros L, Venter M, Elkin C, Venter O (2022) Managing forests old-growth attributes better promotes provision ecosystem services current age-based old-growth management. Forest Ecology Management, 511: 120130. Benez-Secanho FJ, Dwivedi P, Ferreira S, Hepinstall-Cymerman J, Wenger S (2022) Trade-offs value ecosystem services connectivity among protected areas Upper Chattahoochee watershed. Environmental Management, 69: 937–951. Brito-Morales , Schoeman DS, Everett JD, Klein CJ, Dunn DC, García Molinos J., Burrows MT, Buenafe KCV, Dominguez RM, Possingham HP, Richardson AJ (2022) Towards climate-smart, three-dimensional protected areas biodiversity conservation high seas. Nature Climate Change, 12: 402–407. Burbano-Girón J, Jantke K, Molina-Berbeo MA, Buriticá-Mejía N, Urbina-Cardona JN, Sánchez-Clavijo LM, Etter (2022) assessment spatial conservation priorities biodiversity attributes: Composition, structure, function Neotropical biodiversity. Biological Conservation, 265: 109421. Chung HI, Choi Y, Yoo Y, Engler R, Lee K, Jeon SW (2022) Integrated spatial model based evaluation methodology optimal invasive species management: common ragweed Republic Korea. Environmental Research Letters, 17: 034047. Daberger M, Kuemmerle T, Khaleghi Hamidi , Khalatbari L, Abolghasemi H, Mirzadeh HR, Ghoddousi (2022) Prioritizing livestock grazing right buyouts safeguard Asiatic cheetahs extinction. Conservation Science Practice, press: e12832. González-Fernández , González-Salazar C, Sunny , Ruíz-Gutiérrez F, Chávez C (2022) Determination priority areas amphibian conservation Guerrero (Mexico), systematic conservation planning tools. Journal Nature Conservation, 68: 126235. Hanson JO, Vincent J, Schuster R, Fahrig L, Brennan , Martin AE, Hughes JS, Pither R, Bennett JR (2022) comparison approaches including connectivity systematic conservation planning. Journal Applied Ecology, 59: 2507–2519. Henry RC, Arneth , Jung M, Rabin SS, Rounsevell MD, Warren F, Alexander P (2022) Global regional health food security strict conservation scenarios. Nature Sustainability, 5: 303–310. Frank F, Volante J, Calamari N, Peri PL, González Chávez B, García Martínez P, Mosciaro MJ, Martín G, Benito Amaro , Guerrero IP, Casellas K (2022) multi-model approach explore sustainable food land use pathways Argentina. Sustainability Science, press: DOI:10.1007/s11625-022-01245-5. Ladouceur E, McGowan J, Huber P, Possingham H, Scridel D, van Klink R, Poschlod P, Cornelissen JHC, Bonomi C, Jiménez-Alfaro B (2022) objective-based prioritization approach tosm support trophic complexity ecological restoration species mixes. Journal Applied Ecology, 59: 394–407. Neo L, Tan HT, Wong KM (2022) little, late? Conservation exigencies Borneo inferred biogeographic considerations endemic plant genera intense landscape modifications. Biodiversity Conservation, 31: 59–76. Paradinas , Giménez J, Conesa D, López-Quílez , Pennino MG (2022) Evidence spatiotemporal shift demersal fishery management priority areas western Mediterranean. Canadian Journal Fisheries Aquatic Sciences, 79: 1641–1654. Proctor CA, Schuster R, Buxton RT, Bennett JR (2022) Prioritization public private land protect species risk habitat. Conservation Science Practice, 4: e12771. Simkin RD, Seto KC, McDonald RI, Jetz W (2022) Biodiversity impacts conservation implications urban land expansion projected 2050. Proceedings National Academy Sciences, 119, e2117297119. Wilson S, Lin H-Y, Schuster R, González , Gómez C, Botero‐Delgadillo E, Bayly NJ, Bennett JR, Rodewald AD, Roehrdanz P, Ruiz Gutierrez V (2022) Opportunities conservation migratory birds benefit threatened resident vertebrates Neotropics. Journal Applied Ecology, 59: 653–663. de Zwaan DR, Alavi N, Mitchell GW, Lapen DR, Duffe J, Wilson S (2022) Balancing conservation priorities grassland forest specialist bird communities agriculturally dominated landscapes. Biological Conservation, 265: 109402.","code":""},{"path":"https://prioritizr.net/articles/publication_record.html","id":"section-2","dir":"Articles","previous_headings":"Research articles","what":"2021","title":"Publication record","text":"Carroll KA (2021) Systematic prioritization protocol applied wolverine habitat connectivity. STAR Protocols, 2: 100882. Combes M, Vaz S, Grehan , Morato T, Arnaud-Haond S, Dominguez-Carrió C, Fox , González-Irusta JM, Johnson D, Callery O, Davies , Fauconnet L, Kenchington E, Orejas C, Roberts JM, Taranto G, Menot L (2021) Systematic conservation planning ocean basin scale: Identifying viable network deep-sea protected areas North Atlantic Mediterranean. Frontiers Marine Science, 8: 611358. Delso Á, Fajardo J, Muñoz J (2021) Protected area networks represent unseen biodiversity. Scientific Reports, 11: 12275. Duchardt CJ, Monroe AP, Heinrichs JA, O’Donnell MS, Edmunds DR, Aldridge CL (2021) Prioritizing restoration areas conserve multiple sagebrush-associated wildlife species. Biological Conservation, 260: 109212. Carroll KA, Inman RM, Hansen AJ, Lawrence RL, Barnett K (2021) framework collaborative wolverine connectivity conservation. iScience, 24: 102840. Jung M, Arnell , de Lamo X, García-Rangel S, Lewis M, Mark J, Merow C, Miles L, Ondo , Pironon S, Ravilious C, Rivers M, Schepashenko D, Tallowin O, van Soesbergen , Govaerts R, Boyle BL, Enquist BJ, Feng X, Gallagher R, Maitner B, Meiri S, Mulligan M, Ofer G, Roll U, Hanson JO, Jetz W, Di Marco M, McGowan J, Rinnan DS, Sachs JD, Lesiv M, Adams VM, Andrew SC, Burger JR, Hannah L, Marquet PA, McCarthy JK, Morueta-Holme N, Newman EA, Park DS, Roehrdanz PR, Svenning J-C, Violle C, Wieringa JJ, Wynne G, Fritz S, Strassburg BBN, Obersteiner M, Kapos V, Burgess N, Schmidt-Traub G, Visconti P (2021) Areas global importance conserving terrestrial biodiversity, carbon water. Nature Ecology Evolution, 5: 1499–1509. Magris RA, Costa MD, Ferreira CE, Vilar CC, Joyeux JC, Creed JC, Copertino MS, Horta PA, Sumida PYG, Francini-Filho RB, Floeter SR (2021). blueprint securing Brazil’s marine biodiversity supporting achievement global conservation goals. Diversity Distributions, 27: 198-215. Southee FM, Edwards BA, Chetkiewicz CLB, O’Connor CM (2021) Freshwater conservation planning far north Ontario, Canada: identifying priority watersheds conservation fish biodiversity intact boreal landscape. FACETS, 6: 90–117. von Takach B, Penton CE, Murphy BP, Radford IJ, Davies HF, Hill BM, Banks SC (2021) Population genomics conservation management declining tropical rodent. Heredity, 126: 763–775. Xuereb , D’Aloia CC, Andrello M, Bernatchez L, Fortin M-J (2021), Incorporating putatively neutral adaptive genomic data marine conservation planning. Conservation Biology, 35: 909–920. Zheng C, Wen Z, Liu Y, Guo Q, Jiang Y, Ren H, Fan Y, Yang Y (2021) Integrating habitat suitability near-nature restoration priorities revegetation plans Based potential vegetation distribution. Forests, 12: 218.","code":""},{"path":"https://prioritizr.net/articles/publication_record.html","id":"section-3","dir":"Articles","previous_headings":"Research articles","what":"2020","title":"Publication record","text":"Bryant BP, Kelsey TR, Vogl AL, Wolny SA, MacEwan DJ, Selmants PC, Biswas T, Butterfield HS (2020) Shaping land use change ecosystem restoration water-stressed agricultural landscape achieve multiple benefits. Frontiers Sustainable Food Systems, 4: 138. Flower J, Ramdeen R, Estep , Thomas LR, Francis S, Goldberg G, Johnson AE, McClintock W, Mendes SR, Mengerink K, O’Garro M (2020) Marine spatial planning Caribbean island Montserrat: Lessons data-limited small islands. Conservation Science Practice, 2: e158. Hanson JO, Marques , Veríssimo , Camacho-Sanchez M, Velo-Antón G, Martínez-Solano Í, Carvalho SB (2020) Conservation planning adaptive neutral evolutionary processes. Journal Applied Ecology, 57: 2159–2169. Hanson JO, Rhodes JR, Butchart SHM, Buchanan GM, Rondinini C, Ficetola GF, Fuller RA (2020). Global conservation species’ niches. Nature, 580: 232–234. Lin H-Y, Robinson KF, Walter L (2020) Trade-offs among road-stream crossing upgrade prioritizations based connectivity restoration erosion risk control. River Research Applications, 36: 371–382. Lin H-Y, Schuster R, Wilson S, Cooke SJ, Rodewald AD, Bennett JR (2020) Integrating season-specific needs migratory resident birds conservation planning. Biological Conservation, 252, 108826. Pinsky ML, Rogers LA, Morley JW, Frölicher TL (2020) Ocean planning species move provides substantial benefits requires trade-offs. Science Advances, 6: eabb8428. Schuster R, Hanson JO, Strimas-Mackey M, Bennett JR (2020) Exact integer linear programming solvers outperform simulated annealing solving conservation planning problems. PeerJ, 8: e9258. Scriven SA, Williams SH, Ghani MA, Agama AL, Benedick S, Brodie JF, Hamer KC, McClean CJ, Reynolds G, Hill JK (2020) Assessing effectiveness protected areas conserving range-restricted rain forest butterflies Sabah, Borneo. Biotropica, 52: 380–391. Visalli , Best BD, Cabral RB, Cheung WWL, Clark NA, Garilao C, Kaschner K, Kesner-Reyes K, Lam VWY, Maxwell SM, Mayorga J, Moeller HV, Morgan L, Crespo GO, Pinsky ML, White TD, McCauley DJ (2020) Data-driven approach highlighting priority areas protection marine areas beyond national jurisdiction. Marine Policy, 122: 103927. Williams SH, Scriven SA, Burslem DF, Hill JK, Reynolds G, Agama AL, Kugan F, Maycock CR, Khoo E, Hastie AY, Sugau JB (2020) Incorporating connectivity conservation planning optimal representation multiple species ecosystem services. Conservation Biology, 34: 934–942.","code":""},{"path":"https://prioritizr.net/articles/publication_record.html","id":"section-4","dir":"Articles","previous_headings":"Research articles","what":"2019","title":"Publication record","text":"Bombi P, Gnetti V, D’Andrea E, De Cinti B, Taglianti AV, Bologna MA, Matteucci G (2019) Identifying priority sites insect conservation forest ecosystems high resolution: potential LiDAR data. Journal Insect Conservation, 23: 689–698. Domisch S, Friedrichs M, Hein T, Borgwardt F, Wetzig , Jähnig SC, Langhans SD (2019) Spatially explicit species distribution models: missed opportunity conservation planning? Diversity Distributions, 25: 758–769. Hanson JO, Fuller RA, Rhodes JR (2019) Conventional methods enhancing connectivity conservation planning always maintain gene flow. Journal Applied Ecology, 56: 913–922. Rodewald AD, Strimas-Mackey M, Schuster R, Arcese P (2019) Beyond canaries coal mines: Co-occurrence Andean mining concessions migratory birds. Perspectives Ecology Conservation, 17: 151–156. Rodewald AD, Strimas-Mackey M, Schuster R, Arcese P (2019) Tradeoffs value biodiversity feature cost data conservation prioritization. Scientific Reports 9: 15921. Schuster R, Wilson S, Rodewald , Arcese P, Fink D, Auer T, Bennett J (2019) Optimizing conservation migratory species full annual cycle. Nature Communications, 10: 1754. Tack JD, Jakes AF, Jones PF, Smith JT, Newton RE, Martin BH, Hebblewhite M, Naugle DE (2019) Beyond protected areas: Private lands public policy anchor intact pathways multi-species wildlife migration. Biological Conservation, 234: 18–27.","code":""},{"path":"https://prioritizr.net/articles/publication_record.html","id":"section-5","dir":"Articles","previous_headings":"Research articles","what":"2017","title":"Publication record","text":"Rosauer DF, Pollock LJ, Linke S, Jetz W (2017) Phylogenetically informed spatial planning required conserve mammalian tree life. Proceedings Royal Society London B: Biological Sciences, 284: 20170627.","code":""},{"path":[]},{"path":"https://prioritizr.net/articles/publication_record.html","id":"section-6","dir":"Articles","previous_headings":"Review articles","what":"2023","title":"Publication record","text":"Burns ES, Lopazanski C, Flower J, Thomas LR, Bradley D, Lester SE (2023) Finding harmony Marine Protected Area design guidelines. Conservation Science Practice, 5: e12946,","code":""},{"path":"https://prioritizr.net/articles/publication_record.html","id":"section-7","dir":"Articles","previous_headings":"Review articles","what":"2022","title":"Publication record","text":"Magdalena UR, Gonçalves de Souza GB, Amorim RR (2022) Spatial analysis guiding decision making environmental conservation: Systematic conservation planning ecosystem services. Progress Physical Geography: Earth Environment, 47: 123–139.","code":""},{"path":"https://prioritizr.net/articles/publication_record.html","id":"section-8","dir":"Articles","previous_headings":"Review articles","what":"2021","title":"Publication record","text":"Queffelec B, Bonnin M, Ferreira B, Bertrand S, Teles Da Silva S, Diouf F, Trouillet B, Cudennec , Brunel , Billant O, Toonen H (2021) Marine spatial planning risk ocean grabbing tropical Atlantic. ICES Journal Marine Science, 78: 1196–1208.","code":""},{"path":"https://prioritizr.net/articles/publication_record.html","id":"section-9","dir":"Articles","previous_headings":"Review articles","what":"2020","title":"Publication record","text":"Pollock LJ, O’Connor LM, Mokany K, Rosauer DF, Talluto MV, Thuiller W (2020) Protecting Biodiversity (complexity): New models methods. Trends Ecology & Evolution, 35: 1119–1128. Velazco SJE, Ribeiro BR, Laureto LMO, Júnior PDM (2020) Overprediction species distribution models conservation planning: still neglected issue strong effects. Biological Conservation, 252, 108822.","code":""},{"path":"https://prioritizr.net/articles/publication_record.html","id":"section-10","dir":"Articles","previous_headings":"Review articles","what":"2019","title":"Publication record","text":"Balbar AC, Metaxas (2019) current application ecological connectivity design marine protected areas. Global Ecology Conservation, 17: e00569.","code":""},{"path":"https://prioritizr.net/articles/publication_record.html","id":"book-chapters","dir":"Articles","previous_headings":"","what":"Book chapters","title":"Publication record","text":"Riginos C, Beger M (2022). Incorporating Genetic Measures Connectivity Adaptation Marine Spatial Planning Corals Coral Reef Conservation Restoration Omics Age (eds van Oppen MJH Aranda Lastra M). Coral Reefs World. Springer, Cham. Kuemmerle T, Kastner T, Meyfroidt P, Qin S (2019) Conservation Telecouplings Telecoupling: Exploring Land-Use Change Globalised World, Springer International Publishing (eds Friis C Nielsen J). Palgrave Studies Natural Resource Management. Palgrave Macmillan, Cham.","code":""},{"path":"https://prioritizr.net/articles/solver_benchmarks.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Solver benchmarks","text":"prioritizr R package supports variety optimization solvers generating prioritizations. Specifically, following functions can used: add_gurobi_solver() (interfaces Gurobi software), add_cplex_solver() (interfaces IBM CPLEX software), add_cbc_solver() (interfaces CBC software using rcbc R package), add_rsymphony_solver() (interfaces SYMPHONY software using Rsymphony R package), add_lpsymphony_solver() function (interfaces SYMPHONY software using lpsymphony R package), add_highs_solver() function (interfaces HiGHS software) using highs package. Broadly speaking, IBM CPLEX Gurobi tend fastest among supported solvers. Although commercial software, special academic licenses available cost. vignette, explore performance different solvers. Using benchmark analysis, see well can tackle problems varying size (e.g., number planning units) complexity (e.g., adding boundary length penalties reduce spatial fragmentation). Since users working governmental non-governmental organizations may need purchase licenses IBM CPLEX Gurobi use , vignette also aims provide insight whether potential benefits purchasing licenses worthwhile. Indeed – depending size complexity given conservation planning problem – solvers based open source software may take slightly longer commercial solvers.","code":""},{"path":"https://prioritizr.net/articles/solver_benchmarks.html","id":"methods","dir":"Articles","previous_headings":"","what":"Methods","title":"Solver benchmarks","text":"vignette report results benchmark analysis. reduce computational burden, previously completed benchmark analysis uploaded results online repository (code available online). analysis involved generating prioritizations using different solvers recording long took solvers finish. help understand factors influence long takes solvers generate prioritization, examined suite conservation planning problems varying size (.e., number planning units), complexity (.e., varying penalties reduce spatial fragmentation), different objective functions (.e., metric used evaluate competing solutions). section, download results previously completed benchmark analysis examine parameters used conduct .","code":""},{"path":"https://prioritizr.net/articles/solver_benchmarks.html","id":"set-up","dir":"Articles","previous_headings":"Methods","what":"Set up","title":"Solver benchmarks","text":"start , load packages used vignette.","code":"# load packages library(prioritizr) library(piggyback) library(ggplot2) library(units) library(dplyr)"},{"path":"https://prioritizr.net/articles/solver_benchmarks.html","id":"download-benchmark-results","dir":"Articles","previous_headings":"Methods","what":"Download benchmark results","title":"Solver benchmarks","text":"Let’s download results benchmark analysis. code save results temporary folder computer. Please note downloading results might take several minutes complete depending internet connection. unable download results onto computer, can view graphs shown vignette. need run code vignette wish explore certain aspects results .","code":"# download data to temporary folder pb_download(   file = c(\"solutions.zip\", \"results.rda\"),   repo = \"prioritizr/benchmark\", dest = tempdir(), tag = \"latest\",   show_progress = FALSE )  # load benchmark results load(file.path(tempdir(), \"results.rda\"))"},{"path":"https://prioritizr.net/articles/solver_benchmarks.html","id":"benchmark-parameters","dir":"Articles","previous_headings":"Methods","what":"Benchmark parameters","title":"Solver benchmarks","text":"downloading benchmark results, let’s look parameters used conduct . Note benchmark scenarios 72 features.","code":"# numbers of planning units examined the benchmark analysis n_planning_units <- sort(unique(benchmark_results$number_of_planning_units)) print(n_planning_units) ## [1]   1478  12902 102242 606180 # number of features (e.g., number of different species examined) sort(unique(benchmark_results$number_features)) ## [1] 72 # representation targets, # units are proportion of the total amount of each feature (e.g., 0.1 = 10%) sort(unique(benchmark_results$relative_target)) ## [1] 0.10 0.15 0.20 0.30 # number of planning units sort(unique(benchmark_results$number_of_planning_units)) ## [1]   1478  12902 102242 606180 # objective functions sort(unique(benchmark_results$objective)) ## [1] \"add_min_set_objective\"       \"add_min_shortfall_objective\" # extract boundary penalty values, # note that different values were examined for different objective functions boundary_penalty_values <-   benchmark_results %>%   plyr::dlply(\"objective\", function(x) unique(x$boundary_penalty))  ## boundary penalty values for min set objective function sort(boundary_penalty_values$add_min_set_objective) ## [1] 0e+00 1e-05 1e-03 ## boundary penalty values for min shortfall objective function sort(boundary_penalty_values$add_min_shortfall_objective) ## [1] 0e+00 1e-14 1e-13 # budgets examined for budget-limited objectives (e.g., 0.1 = 10% of total cost) ## note that the min set objective function does not use a budget, ## and thus it has a NA value tibble(   objective = unique(benchmark_results$objective),   budget = unique(benchmark_results$budget) ) ## # A tibble: 2 × 2 ##   objective                   budget ##   <chr>                        <dbl> ## 1 add_min_set_objective         NA   ## 2 add_min_shortfall_objective    0.1"},{"path":"https://prioritizr.net/articles/solver_benchmarks.html","id":"helper-function","dir":"Articles","previous_headings":"Methods","what":"Helper function","title":"Solver benchmarks","text":"Now define helper function quickly plot results benchmark analysis. helpful interpreting results benchmark analysis following section.","code":"# define helper function to create plots plot_benchmark <- function(   objective, n_pu, boundary_penalty, solver = NULL){   # assert arguments are valid   ## verify parameters with no default arguments   assertthat::assert_that(     assertthat::is.count(n_pu), assertthat::noNA(n_pu),     n_pu %in% unique(benchmark_results$number_of_planning_units),     assertthat::is.number(boundary_penalty), assertthat::noNA(boundary_penalty),     assertthat::is.string(objective), assertthat::noNA(objective),     objective %in% unique(benchmark_results$objective)   )   ## set default argument for solver if needed   if (is.null(solver)) {     solver <- unique(benchmark_results$solver)   }   ## verify solver argument   assertthat::assert_that(     is.character(solver), all(solver %in% benchmark_results$solver)   )   ## verify that only a single set of features was used   assertthat::assert_that(     dplyr::n_distinct(benchmark_results$number_features) == 1   )    # prepare data for plotting   ## rename variables to avoid scoping issues   sol <- solver   obj <- objective   bp <- boundary_penalty   ## subset data relevant for plotting   plot_data <-     benchmark_results %>%     filter(.$objective == obj, .$solver %in% sol,            .$number_of_planning_units == n_pu,            .$boundary_penalty == bp     )   ## scale run time to helpful units for plotting   plot_units <-     dplyr::case_when(       # show hours if max(run_time) > 3 h       max(plot_data$run_time, na.rm = TRUE) > 60 * 60 * 3 ~ \"hours\",       # show minutes if max(run_time) > 3 M       max(plot_data$run_time, na.rm = TRUE) > 60 * 3 ~ \"minutes\",       # else show seconds       TRUE ~ \"seconds\"     )    plot_data$min_set_scaled <-     plot_data$run_time %>%     units::set_units(s) %>%     units::set_units(plot_units, mode = \"standard\") %>%     as.numeric()   ## plot labels   n_f <- unique(benchmark_results$number_features)[1]   plot_title =     paste0(       dplyr::case_when(         objective == \"add_min_set_objective\" ~ \"Min. set\",         objective == \"add_min_shortfall_objective\" ~ \"Min. shortfall\",         TRUE ~ objective),       \": \",       formatC(         n_f, big.mark = \",\", digits = 2, format = \"f\",         drop0trailing = TRUE),       \" features, \",       formatC(         n_pu, big.mark = \",\", digits = 2, format = \"f\",         drop0trailing = TRUE),       \" planning units\"   )   if (bp > 1e-15) {     plot_title <- paste0(plot_title, \", \", bp, \" boundary penalty\")   }   ## determine colors for solvers (so that solvers always have same color   solver_names <- unique(benchmark_results$solver)   solver_colors <- scales::hue_pal()(length(solver_names))   names(solver_colors) <- solver_names    # return plot for selected benchmark runs   # (suppress warnings when a solver doesn't have results)   suppressWarnings(     print(       ggplot(         data = plot_data,         mapping = aes(           x = relative_target, y = min_set_scaled, color = solver         )       ) +       scale_y_continuous(limits = c(0, NA_real_)) +       geom_line() +       geom_point() +       scale_x_continuous(labels = function(x) x * 100) +       scale_color_manual(values = solver_colors) +       labs(         title = plot_title,         x = \"Representation targets (%)\",         y = paste0(\"Run time (\", plot_units, \")\"))     )   ) }"},{"path":"https://prioritizr.net/articles/solver_benchmarks.html","id":"results","dir":"Articles","previous_headings":"","what":"Results","title":"Solver benchmarks","text":"now inspect results benchmark analysis. benchmark_results object table (.e., tibble()) containing information benchmark run (e.g., run time), solution_raster_data object (.e., RasterStack) contains prioritizations generated benchmark run. Note benchmarks run using time limit (.e., 6 hours), meaning solvers able generate prioritization certain runs (indicated exceeded_run_time column). Specifically, benchmark_results object following columns: id: Unique identifier run. number_of_planning_units: Number planning units run. number_features: Number features run. objective: Objective function problem run. budget: Budget used run (missing [NA] values denote objectives use budgets). relative_target: Targets used run (expressed proportion). boundary_penalty: Boundary penalty value used run (zeros indicate penalties). solver: Solver used run generate prioritization. status: Status solver generating prioritization. total_time: Overall time (seconds) elapsed generating prioritization run. run_time: Time (seconds) elapsed solver generate prioritization run. exceeded_run_time: run time exceed maximum time limit? importing data, let’s examine run times solver across benchmark runs. achieve , create box plot. Since prefer solvers generate prioritizations short period time, solvers shorter (lower) run times considered better. looking box plot, can see average run times IBM CPLEX Gurobi solvers consistently low don’t differ much . Additionally, run times open source CBC solver generally low . However, cases run times CBC solver much higher IBM CPLEX Gurobi solvers. can also see lpsymphony Rsymphony solvers – use open source SYMPHONY software – can take much longer generate prioritizations solvers.","code":"# extract columns from table with relevant data benchmark_results <-   benchmark_results %>%   dplyr::select(     id, number_of_planning_units, number_features,     objective, budget, relative_target, boundary_penalty,     solver, status, total_time, run_time, exceeded_run_time   )  # preview results print(benchmark_results) ## # A tibble: 576 × 12 ##    id    number_of_planning_u…¹ number_features objective budget relative_target ##    <chr>                  <int>           <int> <chr>      <dbl>           <dbl> ##  1 0095…                  12902              72 add_min_…   NA              0.3  ##  2 00da…                 606180              72 add_min_…    0.1            0.1  ##  3 00e9…                 606180              72 add_min_…   NA              0.2  ##  4 0115…                   1478              72 add_min_…    0.1            0.3  ##  5 0125…                   1478              72 add_min_…   NA              0.15 ##  6 012c…                   1478              72 add_min_…   NA              0.3  ##  7 0184…                 606180              72 add_min_…   NA              0.2  ##  8 02ae…                 606180              72 add_min_…    0.1            0.2  ##  9 03fd…                 102242              72 add_min_…   NA              0.3  ## 10 0408…                  12902              72 add_min_…    0.1            0.15 ## # ℹ 566 more rows ## # ℹ abbreviated name: ¹​number_of_planning_units ## # ℹ 6 more variables: boundary_penalty <dbl>, solver <chr>, status <chr>, ## #   total_time <dbl>, run_time <dbl>, exceeded_run_time <lgl> # plot overall summary of solver performance ggplot(   data =     benchmark_results %>%     mutate(       min_set_scaled = as.numeric(         set_units(set_units(run_time, \"seconds\"), \"hours\")       )     ),   aes(x = solver, y = min_set_scaled) ) + geom_boxplot() + theme(axis.text.x = element_text(size = 7)) + labs(x = \"Solver\", y = \"Run time (hours)\") ## Warning: Removed 33 rows containing non-finite values ## (`stat_boxplot()`)."},{"path":"https://prioritizr.net/articles/solver_benchmarks.html","id":"minimum-set-results-no-boundary-penalty","dir":"Articles","previous_headings":"Results","what":"Minimum set results (no boundary penalty)","title":"Solver benchmarks","text":"Now, let’s investigate solver behavior detail. Specifically, examine benchmark results generated minimum set objective function. minimum set objective function commonly used objective function systematic conservation, due fact used Marxan decision support software. begin , let’s examine results smallest simplest conservation planning problems examined benchmark analysis. , prioritizations generated using problems involved 1,478 planning units contain boundary length penalties. Since benchmark scenarios 72 features – mentioned earlier – prioritizations generated 72 features. looking results, can see solvers solve problem comparable amount time across targets investigated.  Next, let’s look results realistic problem involving 12,902 planning units see timing different solvers used compares. Note factors (e.g., absence boundary length penalties) previous graph.  Next, look medium sized problem 102,242 planning units. Now really start see difference Rsymphony lpsymphony solvers – use SYMPHONY software – solvers.  Finally, let’s look timing comparisons large problem 606,180 planning units. can see Rsymphony lpsymphony solvers really taking much longer time generate prioritizations now.  get better sense faster solvers (.e., based CBC, IBM CPLEX, Gurobi) compare large problem, let’s take closer look three solvers. Interestingly, can see solver based open source CBC software slightly faster – minutes – solvers.","code":"plot_benchmark(   objective = \"add_min_set_objective\",   n_pu = n_planning_units[1],   boundary_penalty = 0 ) plot_benchmark(   objective = \"add_min_set_objective\",   n_pu = n_planning_units[2],   boundary_penalty = 0 ) plot_benchmark(   objective = \"add_min_set_objective\",   n_pu = n_planning_units[3],   boundary_penalty = 0 ) plot_benchmark(   objective = \"add_min_set_objective\",   n_pu = n_planning_units[4],   boundary_penalty = 0 ) plot_benchmark(   objective = \"add_min_set_objective\",   n_pu = n_planning_units[4],   boundary_penalty = 0,   solver = c(\"add_cbc_solver\", \"add_cplex_solver\", \"add_gurobi_solver\") )"},{"path":"https://prioritizr.net/articles/solver_benchmarks.html","id":"minimum-set-results-with-low-boundary-penalty","dir":"Articles","previous_headings":"Results","what":"Minimum set results with low boundary penalty","title":"Solver benchmarks","text":"Now let’s look problem types, time low boundary length penalty value added problem formulation. start , look scenarios low boundary_penalty value (.e., \\(10^{-5}\\)). Let’s start smallest problem size ’ve benchmarked. problem 1,478 planning units.  Next, let’s look results realistic problem 12,902 planning units see timing different solvers used compares.  Next, look medium sized problem 102,242 planning units. Now really start see difference lpsymphony Rsymphony solvers solvers.  Finally, let’s look timing comparisons large problem 606,180 planning units. scenario without boundary penalties, lpsymphony Rsymphony solvers take lot longer generate prioritizations three solvers.  Similar earlier, let’s take look just CBC, IBM CPLEX, Gurobi solvers. can see Gurobi solver best performance, generating prioritizations half hour cases. result shows commercial solvers can massively outperform open source solvers large-scale problems boundary length penalties.","code":"plot_benchmark(   objective = \"add_min_set_objective\",   n_pu = n_planning_units[1],   boundary_penalty = boundary_penalty_values$add_min_set_objective[2] ) plot_benchmark(   objective = \"add_min_set_objective\",   n_pu = n_planning_units[2],   boundary_penalty = boundary_penalty_values$add_min_set_objective[2] ) plot_benchmark(   objective = \"add_min_set_objective\",   n_pu = n_planning_units[3],   boundary_penalty = boundary_penalty_values$add_min_set_objective[3] ) plot_benchmark(   objective = \"add_min_set_objective\",   n_pu = n_planning_units[4],   boundary_penalty = boundary_penalty_values$add_min_set_objective[2] ) plot_benchmark(   objective = \"add_min_set_objective\",   n_pu = n_planning_units[4],   boundary_penalty = boundary_penalty_values$add_min_set_objective[2],   solver = c(\"add_cbc_solver\", \"add_cplex_solver\", \"add_gurobi_solver\") )"},{"path":"https://prioritizr.net/articles/solver_benchmarks.html","id":"minimum-set-results-with-high-boundary-penalty","dir":"Articles","previous_headings":"Results","what":"Minimum set results with high boundary penalty","title":"Solver benchmarks","text":"Now let’s look problem types, time high boundary length penalty parameter added problem formulation (.e., \\(0.001\\)). Let’s start smallest problem size ’ve benchmarked. problem 1,478 planning units. Although differences solvers, similar run times (.e., less one second).  Next, let’s look results realistic problem 12,902 planning units see timing different solvers used compares.  Next, look medium sized problem 102,242 planning units. see difference Rsymphony lpsymphony solvers solvers.  Finally, let’s look timing comparisons large problem 606,180 planning units. previous scenarios, Rsymphony lpsymphony solvers take lot longer generate prioritizations solvers.  Similar , let’s take look just CBC, IBM CPLEX, Gurobi solvers. can see Gurobi best performance. result emphasizes potential speed gains commercial solvers large-scale conservation planning problems boundary penalties.","code":"plot_benchmark(   objective = \"add_min_set_objective\",   n_pu = n_planning_units[1],   boundary_penalty = boundary_penalty_values$add_min_set_objective[3] ) plot_benchmark(   objective = \"add_min_set_objective\",   n_pu = n_planning_units[2],   boundary_penalty = boundary_penalty_values$add_min_set_objective[3] ) plot_benchmark(   objective = \"add_min_set_objective\",   n_pu = n_planning_units[3],   boundary_penalty = boundary_penalty_values$add_min_set_objective[3] ) plot_benchmark(   objective = \"add_min_set_objective\",   n_pu = n_planning_units[4],   boundary_penalty = boundary_penalty_values$add_min_set_objective[3] ) plot_benchmark(   objective = \"add_min_set_objective\",   n_pu = n_planning_units[4],   boundary_penalty = boundary_penalty_values$add_min_set_objective[3],   solver = c(\"add_cbc_solver\", \"add_cplex_solver\", \"add_gurobi_solver\") )"},{"path":"https://prioritizr.net/articles/solver_benchmarks.html","id":"minimize-shortfall-results-no-boundary-penalty","dir":"Articles","previous_headings":"Results","what":"Minimize shortfall results (no boundary penalty)","title":"Solver benchmarks","text":"Now, let’s investigate solver behavior minimum shortfall objective function. Let’s start smallest problem size examined. benchmark scenarios 72 features. problem 1,478 planning units. can see solvers solve problem comparable amount time across targets investigated.  Next, let’s look results realistic problem 12,902 planning units see timing different solvers used compares. , CBC solver takes slightly longer solvers.  Next, look medium sized problem 102,242 planning units. Now see larger difference CBC solver solvers, CBC solver taking several minutes longer complete.  Finally, let’s look timing comparisons large problem 606,180 planning units. can see open source solvers (.e., CBC, Rsymphony lpsymphony) take lot longer commercial solvers (.e., IBM CPLEX Guorbi).","code":"plot_benchmark(   objective = \"add_min_shortfall_objective\",   n_pu = n_planning_units[1],   boundary_penalty = 0 ) plot_benchmark(   objective = \"add_min_shortfall_objective\",   n_pu = n_planning_units[2],   boundary_penalty = 0 ) plot_benchmark(   objective = \"add_min_shortfall_objective\",   n_pu = n_planning_units[3],   boundary_penalty = 0 ) plot_benchmark(   objective = \"add_min_shortfall_objective\",   n_pu = n_planning_units[4],   boundary_penalty = 0 )"},{"path":"https://prioritizr.net/articles/solver_benchmarks.html","id":"minimize-shortfall-results-with-low-boundary-penalty","dir":"Articles","previous_headings":"Results","what":"Minimize shortfall results with low boundary penalty","title":"Solver benchmarks","text":"Now let’s look problem type, time low boundary_penalty parameter added problem formulation (.e., \\(0\\)). Let’s start smallest problem size examined. problem 1,478 planning units.  Next, let’s look results realistic problem 12,902 planning units see timing different solvers compare. Similar , can see CBC solver takes slightly longer solvers.  Next, look medium sized problem 102,242 planning units. Now really start see difference CBC solver solvers. Additionally, Rsymphony lpsymphony solvers also take considerably longer commercial solvers .  Finally, let’s look timing comparisons large problem 606,180 planning units. CBC solver now performs better Rsymphony lpsymphony solvers, can take whole day complete.  get better sense faster solvers compare (.e., CBC, IBM CPLEX, Gurobi), let’s take closer look three solvers. can see CBC solver takes lot longer generate prioritizations IBM CPLEX Gurobi solvers. result suggests IBM CPLEX Gurobi really beneficial large-scale conservation planning problems boundary length penalties minimum shortfall objective function.","code":"plot_benchmark(   objective = \"add_min_shortfall_objective\",   n_pu = n_planning_units[1],   boundary_penalty = boundary_penalty_values$add_min_shortfall_objective[2] ) plot_benchmark(   objective = \"add_min_shortfall_objective\",   n_pu = n_planning_units[2],   boundary_penalty = boundary_penalty_values$add_min_shortfall_objective[2] ) plot_benchmark(   objective = \"add_min_shortfall_objective\",   n_pu = n_planning_units[3],   boundary_penalty = boundary_penalty_values$add_min_shortfall_objective[2] ) plot_benchmark(   objective = \"add_min_shortfall_objective\",   n_pu = n_planning_units[4],   boundary_penalty = boundary_penalty_values$add_min_shortfall_objective[2] ) plot_benchmark(   objective = \"add_min_shortfall_objective\",   n_pu = n_planning_units[4],   boundary_penalty = boundary_penalty_values$add_min_shortfall_objective[2],   solver = c(\"add_cbc_solver\", \"add_cplex_solver\", \"add_gurobi_solver\") )"},{"path":"https://prioritizr.net/articles/solver_benchmarks.html","id":"minimize-shortfall-results-with-high-boundary-penalty","dir":"Articles","previous_headings":"Results","what":"Minimize shortfall results with high boundary penalty","title":"Solver benchmarks","text":"Now let’s look problem types, time higher boundary_penalty parameter added problem formulation (\\(10^{-14}\\)). Let’s start smallest problem size examined. problem 1,478 planning units.  Next, let’s look results greater number planning units (.e., 12,902 planning units) see timings compare. solvers similar run time now. Interestingly, Gurobi solver slowest – couple minutes – benchmark parameters.  Next, look medium sized problem 102,242 planning units. Similar previous results minimum shortfall objective, CBC solver slowest IBM CPLEX Gurobi commercial solvers fastest.  Finally, let’s look timing comparisons large problem 606,180 planning units. can see benchmark times vary greatly Rsymphony lpsymphony solvers, run times ranging one two whole days. Additionally, although CBC solver can still require several hours generate prioritization, now outperforms Rsymphony lpsymphony solvers. Finally, IBM CPLEX Gurobi solvers perform much, much better solvers.","code":"plot_benchmark(   objective = \"add_min_shortfall_objective\",   n_pu = n_planning_units[1],   boundary_penalty = boundary_penalty_values$add_min_shortfall_objective[3] ) plot_benchmark(   objective = \"add_min_shortfall_objective\",   n_pu = n_planning_units[2],   boundary_penalty = boundary_penalty_values$add_min_shortfall_objective[3] ) plot_benchmark(   objective = \"add_min_shortfall_objective\",   n_pu = n_planning_units[3],   boundary_penalty = boundary_penalty_values$add_min_shortfall_objective[3] ) plot_benchmark(   objective = \"add_min_shortfall_objective\",   n_pu = n_planning_units[4],   boundary_penalty = boundary_penalty_values$add_min_shortfall_objective[3] )"},{"path":"https://prioritizr.net/articles/solver_benchmarks.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Solver benchmarks","text":"benchmark results demonstrate time required solve conservation planning problem can vary considerably depending size complexity problem, also solver used generate prioritization. Indeed, solvers (e.g., Rsymphony solver) may require many hours solve problem solvers (e.g., CBC Gurobi solvers) can solve within minutes. Broadly speaking, recommend using Gurobi IBM CPLEX solvers possible. often best performance. Although academics can obtain special license use solvers cost, conservation planners working governmental non-governmental organizations may access solvers. cases, recommend using CBC solver generally better performance open source solvers (.e., Rsymphony lpsymphony solvers). Since CBC solver always better performance open source solvers, recommend trying lpsymphony solver CBC solver taking long time solve particular problem.","code":""},{"path":"https://prioritizr.net/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Jeffrey O Hanson. Author. Richard Schuster. Author, maintainer. Nina Morrell. Author. Matthew Strimas-Mackey. Author. Brandon P M Edwards. Author. Matthew E Watts. Author. Peter Arcese. Author. Joseph Bennett. Author. Hugh P Possingham. Author.","code":""},{"path":"https://prioritizr.net/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Hanson JO, Schuster R, Morrell N, Strimas-Mackey M, Edwards BPM, Watts , Arcese P, Bennett J, Possingham HP (2023). prioritizr: Systematic Conservation Prioritization R. https://prioritizr.net, https://github.com/prioritizr/prioritizr.","code":"@Manual{,   title = {prioritizr: Systematic Conservation Prioritization in R},   author = {Jeffrey O Hanson and Richard Schuster and Nina Morrell and Matthew Strimas-Mackey and Brandon P M Edwards and Matthew E Watts and Peter Arcese and Joseph Bennett and Hugh P Possingham},   year = {2023},   note = {https://prioritizr.net, https://github.com/prioritizr/prioritizr}, }"},{"path":[]},{"path":"https://prioritizr.net/index.html","id":"systematic-conservation-prioritization-in-r","dir":"","previous_headings":"","what":"Systematic Conservation Prioritization in R","title":"Systematic Conservation Prioritization in R","text":"prioritizr R package uses mixed integer linear programming (MILP) techniques provide flexible interface building solving conservation planning problems. supports broad range objectives, constraints, penalties can used custom-tailor conservation planning problems specific needs conservation planning exercise. built, conservation planning problems can solved using variety commercial open-source exact algorithm solvers. contrast algorithms conventionally used solve conservation problems, heuristics simulated annealing, exact algorithms used guaranteed find optimal solutions. Furthermore, conservation problems can constructed optimize spatial allocation different management actions zones, meaning conservation practitioners can identify solutions benefit multiple stakeholders. Finally, package functionality read input data formatted Marxan conservation planning program, find much cheaper solutions much shorter period time Marxan.","code":""},{"path":[]},{"path":"https://prioritizr.net/index.html","id":"official-version","dir":"","previous_headings":"Installation","what":"Official version","title":"Systematic Conservation Prioritization in R","text":"latest official version prioritizr R package can installed Comprehensive R Archive Network (CRAN) using following R code.","code":"install.packages(\"prioritizr\", repos = \"https://cran.rstudio.com/\")"},{"path":"https://prioritizr.net/index.html","id":"developmental-version","dir":"","previous_headings":"Installation","what":"Developmental version","title":"Systematic Conservation Prioritization in R","text":"latest development version can installed gain access new functionality yet present latest official version. Please note developmental version likely contain coding errors official version. install developmental version, can install directly GitHub online code repository R Universe. general, recommend installing developmental version R Universe. installation via R Universe require additional software (e.g., RTools Windows systems, Xcode gfortran macOS systems). install latest development version R Universe, use following R code. install latest development version GitHub, use following R code.","code":"install.packages(   \"prioritizr\",   repos = c(     \"https://prioritizr.r-universe.dev\",     \"https://cloud.r-project.org\"   ) ) if (!require(remotes)) install.packages(\"remotes\") remotes::install_github(\"prioritizr/prioritizr\")"},{"path":"https://prioritizr.net/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Systematic Conservation Prioritization in R","text":"Please cite prioritizr R package using publications. cite latest official version, please use: Hanson JO, Schuster R, Morrell N, Strimas-Mackey M, Edwards BPM, Watts , Arcese P, Bennett J, Possingham HP (2023). prioritizr: Systematic Conservation Prioritization R. R package version 8.0.2. Available https://CRAN.R-project.org/package=prioritizr. Alternatively, cite latest development version, please use: Hanson JO, Schuster R, Morrell N, Strimas-Mackey M, Edwards BPM, Watts , Arcese P, Bennett J, Possingham HP (2023). prioritizr: Systematic Conservation Prioritization R. R package version 8.0.2.7. Available https://github.com/prioritizr/prioritizr. Additionally, keep record publications use prioritizr R package. use package reports publications, please file issue GitHub can add record.","code":""},{"path":"https://prioritizr.net/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Systematic Conservation Prioritization in R","text":"provide short example showing prioritizr R package can used build solve conservation problems. Specifically, use example dataset available prioritizrdata R package. Additionally, use terra R package perform raster calculations. begin , load packages. use Washington dataset example. import planning unit data, use get_wa_pu() function. Although prioritizr R package can support many different types planning unit data, planning units represented single-layer raster (.e., terra::rast() object). cell represents different planning unit, cell values denote land acquisition costs. Specifically, 10757 planning units total (.e., cells non-missing values).  Next, use get_wa_features() function import conservation feature data. Although prioritizr R package can support many different types feature data, feature data represented multi-layer raster (.e., terra::rast() object). layer describes spatial distribution feature. , feature data correspond different bird species. account migratory patterns, breeding non-breeding distributions species represented different features. Specifically, cell values denote relative abundance individuals, higher values indicating greater abundance.  Let’s make sure solver installed computer. important can use optimization algorithms generate spatial prioritizations. first time using prioritizr R package, please install HiGHS solver using following R code. Although HiGHS solver relatively fast easy install, please note ’ll need install Gurobi software suite gurobi R package best performance (see Gurobi Installation Guide details). Now, let’s generate spatial prioritization. ensure feasibility, set budget. Specifically, total cost prioritization represent 5% total land value study area. Given budget, want prioritization increase feature representation, much possible, feature , ideally, 20% distribution covered prioritization. scenario, can either purchase land inside given planning unit, none land inside given planning unit. Thus create new problem() use minimum shortfall objective (via add_min_shortfall_objective()), relative targets 20% (via add_relative_targets()), binary decisions (via add_binary_decisions()), specify want near-optimal solutions (.e., 10% optimality) using best solver installed computer (via add_default_solver()). built problem(), can solve obtain solution.  generating solution, important evaluate . , calculate number planning units selected solution, total cost solution. can also check many representation targets met solution. Although solution helps meet representation targets, account existing protected areas inside study area. , account possibility features partially – even fully – represented existing protected areas , turn, might fail identify meaningful priorities new protected areas. address issue, use get_wa_locked_in() function import spatial data protected areas study area. add constraints problem() ensure selected solution (via add_locked_in_constraints()).   solution improvement previous solution. However, places study area available protected area establishment (e.g., due land tenure). consequence, solution might practical implementation, might select places available protection. address issue, use get_wa_locked_out() function import spatial data describing planning units available protection. add constraints problem() ensure selected solution (via add_locked_out_constraints()).   solution even better previous solution. However, finished yet. planning units selected solution fairly fragmented. can cause issues fragmentation increases management costs reduces conservation benefits edge effects. address issue, can modify problem adding penalties punish overly fragmented solutions (via add_boundary_penalties()). use penalty factor (.e., boundary length modifier) 0.003, edge factor 50% planning units occur outer edge study area overly penalized.  Now, let’s explore planning units selected solution important cost-effectively meeting targets. achieve , calculate importance (irreplaceability) scores using Ferrier method. Although method produces scores feature separately, examine total scores summarize overall importance across features.  short example demonstrates prioritizr R package can used build customize conservation problems, solve generate solutions. Although explored just different functions modifying conservation problem, package provides many functions specifying objectives, constraints, penalties, decision variables, can build custom-tailor conservation planning problems suit planning scenario.","code":"# load packages library(prioritizr) library(prioritizrdata) library(terra) # import planning unit data wa_pu <- get_wa_pu()  # preview data print(wa_pu) ## class       : SpatRaster  ## dimensions  : 109, 147, 1  (nrow, ncol, nlyr) ## resolution  : 4000, 4000  (x, y) ## extent      : -1816382, -1228382, 247483.5, 683483.5  (xmin, xmax, ymin, ymax) ## coord. ref. : +proj=laea +lat_0=45 +lon_0=-100 +x_0=0 +y_0=0 +ellps=sphere +units=m +no_defs  ## source      : wa_pu.tif  ## name        :         cost  ## min value   :    0.2986647  ## max value   : 1804.1838379 # plot data plot(wa_pu, main = \"Costs\", axes = FALSE) # import feature data wa_features <- get_wa_features()  # preview data print(wa_features) ## class       : SpatRaster  ## dimensions  : 109, 147, 396  (nrow, ncol, nlyr) ## resolution  : 4000, 4000  (x, y) ## extent      : -1816382, -1228382, 247483.5, 683483.5  (xmin, xmax, ymin, ymax) ## coord. ref. : +proj=laea +lat_0=45 +lon_0=-100 +x_0=0 +y_0=0 +ellps=sphere +units=m +no_defs  ## source      : wa_features.tif  ## names       : Recur~ding), Botau~ding), Botau~ding), Corvu~ding), Corvu~ding), Cincl~full), ...  ## min values  :       0.000,       0.000,       0.000,       0.000,       0.000,        0.00, ...  ## max values  :       0.514,       0.812,       3.129,       0.115,       0.296,        0.06, ... # plot the first nine features plot(wa_features[[1:9]], nr = 3, axes = FALSE) # if needed, install HiGHS solver install.packages(\"highs\", repos = \"https://cran.rstudio.com/\") # calculate budget budget <- terra::global(wa_pu, \"sum\", na.rm = TRUE)[[1]] * 0.05  # create problem p1 <-   problem(wa_pu, features = wa_features) %>%   add_min_shortfall_objective(budget) %>%   add_relative_targets(0.2) %>%   add_binary_decisions() %>%   add_default_solver(gap = 0.1, verbose = FALSE)  # print problem print(p1) ## A conservation problem (<ConservationProblem>) ## ├•data ## │├•features:    \"Recurvirostra americana (breeding)\" , … (396 total) ## │└•planning units: ## │ ├•data:       <SpatRaster> (10757 total) ## │ ├•costs:      continuous values (between 0.2987 and 1804.1838) ## │ ├•extent:     -1816381.6182, 247483.5211, -1228381.6182, 683483.5211 (xmin, ymin, xmax, ymax) ## │ └•CRS:        +proj=laea +lat_0=45 +lon_0=-100 +x_0=0 +y_0=0 +ellps=sphere +units=m +no_defs (projected) ## ├•formulation ## │├•objective:   minimum shortfall objective (`budget` = 8748.4908) ## │├•penalties:   none specified ## │├•targets:     relative targets (between 0.2 and 0.2) ## │├•constraints: none specified ## │└•decisions:   binary decision ## └•optimization ##  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) ##  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) ## # ℹ Use `summary(...)` to see complete formulation. # solve the problem s1 <- solve(p1)  # extract the objective print(attr(s1, \"objective\")) ## solution_1  ##    4.40521 # extract time spent solving the problem print(attr(s1, \"runtime\")) ## solution_1  ##      2.962 # extract state message from the solver print(attr(s1, \"status\")) ## solution_1  ##  \"OPTIMAL\" # plot the solution plot(s1, main = \"Solution\", axes = FALSE) # calculate number of selected planning units by solution eval_n_summary(p1, s1) ## # A tibble: 1 × 2 ##   summary     n ##   <chr>   <dbl> ## 1 overall  2319 # calculate total cost of solution eval_cost_summary(p1, s1) ## # A tibble: 1 × 2 ##   summary  cost ##   <chr>   <dbl> ## 1 overall 8748. # calculate target coverage for the solution p1_target_coverage <- eval_target_coverage_summary(p1, s1) print(p1_target_coverage) ## # A tibble: 396 × 9 ##    feature   met   total_amount absolute_target absolute_held absolute_shortfall ##    <chr>     <lgl>        <dbl>           <dbl>         <dbl>              <dbl> ##  1 Recurvir… TRUE         100.             20.0          23.4               0    ##  2 Botaurus… TRUE          99.9            20.0          29.2               0    ##  3 Botaurus… TRUE         100.             20.0          34.0               0    ##  4 Corvus b… TRUE          99.9            20.0          20.2               0    ##  5 Corvus b… FALSE         99.9            20.0          18.7               1.29 ##  6 Cinclus … TRUE         100.             20.0          20.4               0    ##  7 Spinus t… TRUE          99.9            20.0          22.4               0    ##  8 Spinus t… TRUE          99.9            20.0          23.0               0    ##  9 Falco sp… TRUE          99.9            20.0          24.5               0    ## 10 Falco sp… TRUE         100.             20.0          24.4               0    ## # ℹ 386 more rows ## # ℹ 3 more variables: relative_target <dbl>, relative_held <dbl>, ## #   relative_shortfall <dbl> # check percentage of the features that have their target met given the solution print(mean(p1_target_coverage$met) * 100) ## [1] 96.46465 # import locked in data wa_locked_in <- get_wa_locked_in()  # print data print(wa_locked_in) ## class       : SpatRaster  ## dimensions  : 109, 147, 1  (nrow, ncol, nlyr) ## resolution  : 4000, 4000  (x, y) ## extent      : -1816382, -1228382, 247483.5, 683483.5  (xmin, xmax, ymin, ymax) ## coord. ref. : +proj=laea +lat_0=45 +lon_0=-100 +x_0=0 +y_0=0 +ellps=sphere +units=m +no_defs  ## source      : wa_locked_in.tif  ## name        : protected areas  ## min value   :               0  ## max value   :               1 # plot data plot(wa_locked_in, main = \"Existing protected areas\", axes = FALSE) # create new problem with locked in constraints added to it p2 <-   p1 %>%   add_locked_in_constraints(wa_locked_in)  # solve the problem s2 <- solve(p2)  # plot the solution plot(s2, main = \"Solution\", axes = FALSE) # import locked out data wa_locked_out <- get_wa_locked_out()  # print data print(wa_locked_out) ## class       : SpatRaster  ## dimensions  : 109, 147, 1  (nrow, ncol, nlyr) ## resolution  : 4000, 4000  (x, y) ## extent      : -1816382, -1228382, 247483.5, 683483.5  (xmin, xmax, ymin, ymax) ## coord. ref. : +proj=laea +lat_0=45 +lon_0=-100 +x_0=0 +y_0=0 +ellps=sphere +units=m +no_defs  ## source      : wa_locked_out.tif  ## name        : urban areas  ## min value   :           0  ## max value   :           1 # plot data plot(wa_locked_out, main = \"Areas not available for protection\", axes = FALSE) # create new problem with locked out constraints added to it p3 <-   p2 %>%   add_locked_out_constraints(wa_locked_out)  # solve the problem s3 <- solve(p3)  # plot the solution plot(s3, main = \"Solution\", axes = FALSE) # create new problem with boundary penalties added to it p4 <-   p3 %>%   add_boundary_penalties(penalty = 0.003, edge_factor = 0.5)  # solve the problem s4 <- solve(p4)  # plot the solution plot(s4, main = \"Solution\", axes = FALSE) # calculate importance scores rc <-   p4 %>%   eval_ferrier_importance(s4)  # print scores print(rc) ## class       : SpatRaster  ## dimensions  : 109, 147, 397  (nrow, ncol, nlyr) ## resolution  : 4000, 4000  (x, y) ## extent      : -1816382, -1228382, 247483.5, 683483.5  (xmin, xmax, ymin, ymax) ## coord. ref. : +proj=laea +lat_0=45 +lon_0=-100 +x_0=0 +y_0=0 +ellps=sphere +units=m +no_defs  ## source(s)   : memory ## varnames    : wa_pu  ##               wa_pu  ##               wa_pu  ##               ... ## names       :  Recur~ding),  Botau~ding),  Botau~ding),  Corvu~ding),  Corvu~ding),  Cincl~full), ...  ## min values  : 0.0000000000, 0.0000000000, 0.0000000000, 0.000000e+00, 0.000000e+00, 0.000000e+00, ...  ## max values  : 0.0003227724, 0.0002213034, 0.0006622152, 7.771815e-05, 8.974447e-05, 8.483296e-05, ... # plot the total importance scores ## note that gray cells are not selected by the prioritization plot(   rc[[\"total\"]], main = \"Importance scores\", axes = FALSE,   breaks = c(0, 1e-10, 0.005, 0.01, 0.025),   col = c(\"#e5e5e5\", \"#fff7ec\", \"#fc8d59\", \"#7f0000\") )"},{"path":"https://prioritizr.net/index.html","id":"learning-resources","dir":"","previous_headings":"","what":"Learning resources","title":"Systematic Conservation Prioritization in R","text":"package website contains information prioritizr R package. can find documentation every function built-dataset, news describing updates package version. also contains following articles tutorials. Getting started: Short tutorial using package. Package overview: Introduction systematic conservation planning comprehensive overview package. Connectivity tutorial: Tutorial incorporating connectivity prioritizations. Calibrating trade-offs tutorial: Tutorial running calibration analyses satisfy multiple criteria. Management zones tutorial: Tutorial incorporating multiple management zones actions prioritizations. Gurobi installation guide: Instructions installing Gurobi optimization suite generating prioritizations. Solver benchmarks: Performance comparison optimization solvers generating prioritizations. Publication record: List publications cited package. Additional resources can also found online repositories prioritizr organization. resources include slides talks seminars package. Additionally, workshop materials available (e.g., Carleton 2023 workshop).","code":""},{"path":"https://prioritizr.net/index.html","id":"getting-help","dir":"","previous_headings":"","what":"Getting help","title":"Systematic Conservation Prioritization in R","text":"questions prioritizr R package suggestions improving , please post issue code repository.","code":""},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Conservation problem modifier class — ConservationModifier-class","title":"Conservation problem modifier class — ConservationModifier-class","text":"super-class used construct Objective Penalty, Target, Constraint, Portfolio, Solver, Decision objects. experts use fields methods class directly.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"public-fields","dir":"Reference","previous_headings":"","what":"Public fields","title":"Conservation problem modifier class — ConservationModifier-class","text":"name character value. data list containing data. internal list containing internal computed values. compressed_formulation logical value indicating object compatible compressed formulation.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Conservation problem modifier class — ConservationModifier-class","text":"ConservationModifier$print() ConservationModifier$show() ConservationModifier$repr() ConservationModifier$calculate() ConservationModifier$get_data() ConservationModifier$set_data() ConservationModifier$get_internal() ConservationModifier$set_internal() ConservationModifier$clone()","code":""},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"method-print-","dir":"Reference","previous_headings":"","what":"Method print()","title":"Conservation problem modifier class — ConservationModifier-class","text":"Print information object.","code":""},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem modifier class — ConservationModifier-class","text":"","code":"ConservationModifier$print()"},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem modifier class — ConservationModifier-class","text":"None.","code":""},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"method-show-","dir":"Reference","previous_headings":"","what":"Method show()","title":"Conservation problem modifier class — ConservationModifier-class","text":"Print information object.","code":""},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem modifier class — ConservationModifier-class","text":"","code":"ConservationModifier$show()"},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem modifier class — ConservationModifier-class","text":"None.","code":""},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"method-repr-","dir":"Reference","previous_headings":"","what":"Method repr()","title":"Conservation problem modifier class — ConservationModifier-class","text":"Generate character representation object.","code":""},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem modifier class — ConservationModifier-class","text":"","code":"ConservationModifier$repr(compact = TRUE)"},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conservation problem modifier class — ConservationModifier-class","text":"compact logical value indicating output value compact? Defaults FALSE.","code":""},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"returns-2","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem modifier class — ConservationModifier-class","text":"character value.","code":""},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"method-calculate-","dir":"Reference","previous_headings":"","what":"Method calculate()","title":"Conservation problem modifier class — ConservationModifier-class","text":"Perform computations need completed applying object.","code":""},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem modifier class — ConservationModifier-class","text":"","code":"ConservationModifier$calculate(x, y)"},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conservation problem modifier class — ConservationModifier-class","text":"x optimization_problem() object. y problem() object.","code":""},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"returns-3","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem modifier class — ConservationModifier-class","text":"Invisible TRUE.","code":""},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"method-get-data-","dir":"Reference","previous_headings":"","what":"Method get_data()","title":"Conservation problem modifier class — ConservationModifier-class","text":"Get values stored data field.","code":""},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem modifier class — ConservationModifier-class","text":"","code":"ConservationModifier$get_data(x)"},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conservation problem modifier class — ConservationModifier-class","text":"x character name data.","code":""},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"returns-4","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem modifier class — ConservationModifier-class","text":"object. data field contain object associated argument x, new_waiver() object returned.","code":""},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"method-set-data-","dir":"Reference","previous_headings":"","what":"Method set_data()","title":"Conservation problem modifier class — ConservationModifier-class","text":"Set values stored data field. Note method overwrite existing data.","code":""},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem modifier class — ConservationModifier-class","text":"","code":"ConservationModifier$set_data(x, value)"},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conservation problem modifier class — ConservationModifier-class","text":"x character name data. value Object store.","code":""},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"returns-5","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem modifier class — ConservationModifier-class","text":"Invisible TRUE.","code":""},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"method-get-internal-","dir":"Reference","previous_headings":"","what":"Method get_internal()","title":"Conservation problem modifier class — ConservationModifier-class","text":"Get values stored internal field.","code":""},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem modifier class — ConservationModifier-class","text":"","code":"ConservationModifier$get_internal(x)"},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conservation problem modifier class — ConservationModifier-class","text":"x character name data.","code":""},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"returns-6","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem modifier class — ConservationModifier-class","text":"object. internal field contain object associated argument x, new_waiver() object returned.","code":""},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"method-set-internal-","dir":"Reference","previous_headings":"","what":"Method set_internal()","title":"Conservation problem modifier class — ConservationModifier-class","text":"Set values stored internal field. Note method overwrite existing data.","code":""},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"usage-7","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem modifier class — ConservationModifier-class","text":"","code":"ConservationModifier$set_internal(x, value)"},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"arguments-5","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conservation problem modifier class — ConservationModifier-class","text":"x character name data. value Object store.","code":""},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"returns-7","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem modifier class — ConservationModifier-class","text":"object. internal field contain object associated argument x, new_waiver() object returned.","code":""},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Conservation problem modifier class — ConservationModifier-class","text":"objects class cloneable method.","code":""},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"usage-8","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem modifier class — ConservationModifier-class","text":"","code":"ConservationModifier$clone(deep = FALSE)"},{"path":"https://prioritizr.net/reference/ConservationModifier-class.html","id":"arguments-6","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conservation problem modifier class — ConservationModifier-class","text":"deep Whether make deep clone.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Conservation problem class — ConservationProblem-class","title":"Conservation problem class — ConservationProblem-class","text":"class used represent conservation planning problems. stores data (e.g., planning units, features) mathematical formulation (e.g., objective, constraints, design criteria) needed generate prioritizations. users use problem() generate new conservation problem objects, functions distributed package interact (e.g., number_of_features(), number_of_planning_units()). experts use fields methods class directly.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"public-fields","dir":"Reference","previous_headings":"","what":"Public fields","title":"Conservation problem class — ConservationProblem-class","text":"data list containing data (e.g., planning units, costs). defaults list indicating fields contain defaults. objective Objective object specifying objective function problem formulation. decisions sDecision object specifying decision types problem formulation. targets Target object specifying representation targets problem formulation. constraints list containing Constraint objects specify constraints problem formulation. penalties list containing Penalty objects specify penalties problem formulation. portfolio Portfolio object specifying approach generating multiple solutions. solver Solver object specifying solver generating solutions.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Conservation problem class — ConservationProblem-class","text":"ConservationProblem$new() ConservationProblem$summary() ConservationProblem$print() ConservationProblem$show() ConservationProblem$repr() ConservationProblem$get_data() ConservationProblem$set_data() ConservationProblem$number_of_planning_units() ConservationProblem$planning_unit_indices() ConservationProblem$set_planning_unit_indices() ConservationProblem$planning_unit_indices_with_finite_costs() ConservationProblem$set_planning_unit_indices_with_finite_costs() ConservationProblem$number_of_total_units() ConservationProblem$planning_unit_costs() ConservationProblem$set_planning_unit_costs() ConservationProblem$number_of_features() ConservationProblem$feature_names() ConservationProblem$feature_abundances_in_planning_units() ConservationProblem$set_feature_abundances_in_planning_units() ConservationProblem$feature_positive_abundances_in_planning_units() ConservationProblem$set_feature_positive_abundances_in_planning_units() ConservationProblem$feature_abundances_in_total_units() ConservationProblem$feature_targets() ConservationProblem$number_of_zones() ConservationProblem$zone_names() ConservationProblem$add_portfolio() ConservationProblem$add_solver() ConservationProblem$add_targets() ConservationProblem$add_objective() ConservationProblem$add_decisions() ConservationProblem$add_constraint() ConservationProblem$add_penalty() ConservationProblem$clone()","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"Conservation problem class — ConservationProblem-class","text":"Create new conservation problem object.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem class — ConservationProblem-class","text":"","code":"ConservationProblem$new(data = list())"},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conservation problem class — ConservationProblem-class","text":"data list containing data","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem class — ConservationProblem-class","text":"new ConservationProblem object.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"method-summary-","dir":"Reference","previous_headings":"","what":"Method summary()","title":"Conservation problem class — ConservationProblem-class","text":"Print extended information object.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem class — ConservationProblem-class","text":"","code":"ConservationProblem$summary()"},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem class — ConservationProblem-class","text":"Invisible TRUE.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"method-print-","dir":"Reference","previous_headings":"","what":"Method print()","title":"Conservation problem class — ConservationProblem-class","text":"Print concise information object.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem class — ConservationProblem-class","text":"","code":"ConservationProblem$print()"},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"returns-2","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem class — ConservationProblem-class","text":"Invisible TRUE.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"method-show-","dir":"Reference","previous_headings":"","what":"Method show()","title":"Conservation problem class — ConservationProblem-class","text":"Display concise information object.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem class — ConservationProblem-class","text":"","code":"ConservationProblem$show()"},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"returns-3","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem class — ConservationProblem-class","text":"Invisible TRUE.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"method-repr-","dir":"Reference","previous_headings":"","what":"Method repr()","title":"Conservation problem class — ConservationProblem-class","text":"Generate character representation object.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem class — ConservationProblem-class","text":"","code":"ConservationProblem$repr()"},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"returns-4","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem class — ConservationProblem-class","text":"character value.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"method-get-data-","dir":"Reference","previous_headings":"","what":"Method get_data()","title":"Conservation problem class — ConservationProblem-class","text":"Get values stored data field.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem class — ConservationProblem-class","text":"","code":"ConservationProblem$get_data(x)"},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conservation problem class — ConservationProblem-class","text":"x character name data.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"returns-5","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem class — ConservationProblem-class","text":"object. data field contain object associated argument x, new_waiver() object returned.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"method-set-data-","dir":"Reference","previous_headings":"","what":"Method set_data()","title":"Conservation problem class — ConservationProblem-class","text":"Set values stored data field. Note method overwrite existing data.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem class — ConservationProblem-class","text":"","code":"ConservationProblem$set_data(x, value)"},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conservation problem class — ConservationProblem-class","text":"x character name data. value Object store.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"returns-6","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem class — ConservationProblem-class","text":"Invisible TRUE.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"method-number-of-planning-units-","dir":"Reference","previous_headings":"","what":"Method number_of_planning_units()","title":"Conservation problem class — ConservationProblem-class","text":"Obtain number planning units. planning units correspond elements cost data (e.g., indices, rows, geometries, pixels) finite values least one zone. words, planning unit elements cost data missing (NA) values every zone.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"usage-7","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem class — ConservationProblem-class","text":"","code":"ConservationProblem$number_of_planning_units()"},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"returns-7","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem class — ConservationProblem-class","text":"integer value.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"method-planning-unit-indices-","dir":"Reference","previous_headings":"","what":"Method planning_unit_indices()","title":"Conservation problem class — ConservationProblem-class","text":"Obtain planning unit indices.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"usage-8","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem class — ConservationProblem-class","text":"","code":"ConservationProblem$planning_unit_indices()"},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"returns-8","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem class — ConservationProblem-class","text":"integer vector.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"method-set-planning-unit-indices-","dir":"Reference","previous_headings":"","what":"Method set_planning_unit_indices()","title":"Conservation problem class — ConservationProblem-class","text":"Perform calculations cache planning unit indices.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"usage-9","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem class — ConservationProblem-class","text":"","code":"ConservationProblem$set_planning_unit_indices()"},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"returns-9","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem class — ConservationProblem-class","text":"Invisible TRUE.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"method-planning-unit-indices-with-finite-costs-","dir":"Reference","previous_headings":"","what":"Method planning_unit_indices_with_finite_costs()","title":"Conservation problem class — ConservationProblem-class","text":"Obtain planning unit indices associated finite cost values.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"usage-10","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem class — ConservationProblem-class","text":"","code":"ConservationProblem$planning_unit_indices_with_finite_costs()"},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"returns-10","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem class — ConservationProblem-class","text":"list integer vectors. list element corresponds different zone.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"method-set-planning-unit-indices-with-finite-costs-","dir":"Reference","previous_headings":"","what":"Method set_planning_unit_indices_with_finite_costs()","title":"Conservation problem class — ConservationProblem-class","text":"Perform calculations cache planning unit indices associated finite cost values.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"usage-11","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem class — ConservationProblem-class","text":"","code":"ConservationProblem$set_planning_unit_indices_with_finite_costs()"},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"returns-11","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem class — ConservationProblem-class","text":"Invisible TRUE.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"method-number-of-total-units-","dir":"Reference","previous_headings":"","what":"Method number_of_total_units()","title":"Conservation problem class — ConservationProblem-class","text":"Obtain number total units. total units include elements cost data (e.g., indices, rows, geometries, pixels), including missing (NA) values.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"usage-12","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem class — ConservationProblem-class","text":"","code":"ConservationProblem$number_of_total_units()"},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"returns-12","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem class — ConservationProblem-class","text":"integer value.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"method-planning-unit-costs-","dir":"Reference","previous_headings":"","what":"Method planning_unit_costs()","title":"Conservation problem class — ConservationProblem-class","text":"Obtain planning unit costs.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"usage-13","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem class — ConservationProblem-class","text":"","code":"ConservationProblem$planning_unit_costs()"},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"returns-13","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem class — ConservationProblem-class","text":"numeric matrix.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"method-set-planning-unit-costs-","dir":"Reference","previous_headings":"","what":"Method set_planning_unit_costs()","title":"Conservation problem class — ConservationProblem-class","text":"Perform calculations cache planning unit costs.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"usage-14","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem class — ConservationProblem-class","text":"","code":"ConservationProblem$set_planning_unit_costs()"},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"returns-14","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem class — ConservationProblem-class","text":"Invisible TRUE.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"method-number-of-features-","dir":"Reference","previous_headings":"","what":"Method number_of_features()","title":"Conservation problem class — ConservationProblem-class","text":"Obtain number features.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"usage-15","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem class — ConservationProblem-class","text":"","code":"ConservationProblem$number_of_features()"},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"returns-15","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem class — ConservationProblem-class","text":"integer value.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"method-feature-names-","dir":"Reference","previous_headings":"","what":"Method feature_names()","title":"Conservation problem class — ConservationProblem-class","text":"Obtain names features.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"usage-16","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem class — ConservationProblem-class","text":"","code":"ConservationProblem$feature_names()"},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"returns-16","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem class — ConservationProblem-class","text":"character vector.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"method-feature-abundances-in-planning-units-","dir":"Reference","previous_headings":"","what":"Method feature_abundances_in_planning_units()","title":"Conservation problem class — ConservationProblem-class","text":"Obtain abundance features planning units.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"usage-17","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem class — ConservationProblem-class","text":"","code":"ConservationProblem$feature_abundances_in_planning_units()"},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"returns-17","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem class — ConservationProblem-class","text":"numeric matrix. column corresponds different zone row corresponds different feature.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"method-set-feature-abundances-in-planning-units-","dir":"Reference","previous_headings":"","what":"Method set_feature_abundances_in_planning_units()","title":"Conservation problem class — ConservationProblem-class","text":"Perform calculations cache abundance features planning units.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"usage-18","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem class — ConservationProblem-class","text":"","code":"ConservationProblem$set_feature_abundances_in_planning_units()"},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"returns-18","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem class — ConservationProblem-class","text":"Invisible TRUE.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"method-feature-positive-abundances-in-planning-units-","dir":"Reference","previous_headings":"","what":"Method feature_positive_abundances_in_planning_units()","title":"Conservation problem class — ConservationProblem-class","text":"Obtain positive abundance features planning units. Note method, unlike feature_abundances_in_planning_units,","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"usage-19","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem class — ConservationProblem-class","text":"","code":"ConservationProblem$feature_positive_abundances_in_planning_units()"},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"returns-19","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem class — ConservationProblem-class","text":"numeric matrix. column corresponds different zone row corresponds different feature.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"method-set-feature-positive-abundances-in-planning-units-","dir":"Reference","previous_headings":"","what":"Method set_feature_positive_abundances_in_planning_units()","title":"Conservation problem class — ConservationProblem-class","text":"Perform calculations cache positive abundance features planning units.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"usage-20","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem class — ConservationProblem-class","text":"","code":"ConservationProblem$set_feature_positive_abundances_in_planning_units()"},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"returns-20","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem class — ConservationProblem-class","text":"Invisible TRUE.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"method-feature-abundances-in-total-units-","dir":"Reference","previous_headings":"","what":"Method feature_abundances_in_total_units()","title":"Conservation problem class — ConservationProblem-class","text":"Obtain abundance features total units.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"usage-21","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem class — ConservationProblem-class","text":"","code":"ConservationProblem$feature_abundances_in_total_units()"},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"returns-21","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem class — ConservationProblem-class","text":"numeric matrix. column corresponds different zone row corresponds different feature.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"method-feature-targets-","dir":"Reference","previous_headings":"","what":"Method feature_targets()","title":"Conservation problem class — ConservationProblem-class","text":"Obtain representation targets features.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"usage-22","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem class — ConservationProblem-class","text":"","code":"ConservationProblem$feature_targets()"},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"returns-22","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem class — ConservationProblem-class","text":"tibble::tibble() data frame.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"method-number-of-zones-","dir":"Reference","previous_headings":"","what":"Method number_of_zones()","title":"Conservation problem class — ConservationProblem-class","text":"Obtain number zones.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"usage-23","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem class — ConservationProblem-class","text":"","code":"ConservationProblem$number_of_zones()"},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"returns-23","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem class — ConservationProblem-class","text":"integer value.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"method-zone-names-","dir":"Reference","previous_headings":"","what":"Method zone_names()","title":"Conservation problem class — ConservationProblem-class","text":"Obtain zone names.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"usage-24","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem class — ConservationProblem-class","text":"","code":"ConservationProblem$zone_names()"},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"returns-24","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem class — ConservationProblem-class","text":"character vector.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"method-add-portfolio-","dir":"Reference","previous_headings":"","what":"Method add_portfolio()","title":"Conservation problem class — ConservationProblem-class","text":"Create new object portfolio added problem formulation.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"usage-25","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem class — ConservationProblem-class","text":"","code":"ConservationProblem$add_portfolio(x)"},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conservation problem class — ConservationProblem-class","text":"x Portfolio object.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"returns-25","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem class — ConservationProblem-class","text":"updated ConservationProblem object.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"method-add-solver-","dir":"Reference","previous_headings":"","what":"Method add_solver()","title":"Conservation problem class — ConservationProblem-class","text":"Create new object solver added problem formulation.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"usage-26","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem class — ConservationProblem-class","text":"","code":"ConservationProblem$add_solver(x)"},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conservation problem class — ConservationProblem-class","text":"x Solver object.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"returns-26","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem class — ConservationProblem-class","text":"updated ConservationProblem object.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"method-add-targets-","dir":"Reference","previous_headings":"","what":"Method add_targets()","title":"Conservation problem class — ConservationProblem-class","text":"Create new object targets added problem formulation.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"usage-27","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem class — ConservationProblem-class","text":"","code":"ConservationProblem$add_targets(x)"},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"arguments-5","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conservation problem class — ConservationProblem-class","text":"x Target object.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"returns-27","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem class — ConservationProblem-class","text":"updated ConservationProblem object.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"method-add-objective-","dir":"Reference","previous_headings":"","what":"Method add_objective()","title":"Conservation problem class — ConservationProblem-class","text":"Create new object objective added problem formulation.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"usage-28","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem class — ConservationProblem-class","text":"","code":"ConservationProblem$add_objective(x)"},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"arguments-6","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conservation problem class — ConservationProblem-class","text":"x Objective object.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"returns-28","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem class — ConservationProblem-class","text":"updated ConservationProblem object.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"method-add-decisions-","dir":"Reference","previous_headings":"","what":"Method add_decisions()","title":"Conservation problem class — ConservationProblem-class","text":"Create new object decisions added problem formulation.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"usage-29","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem class — ConservationProblem-class","text":"","code":"ConservationProblem$add_decisions(x)"},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"arguments-7","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conservation problem class — ConservationProblem-class","text":"x Decision object.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"returns-29","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem class — ConservationProblem-class","text":"updated ConservationProblem object.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"method-add-constraint-","dir":"Reference","previous_headings":"","what":"Method add_constraint()","title":"Conservation problem class — ConservationProblem-class","text":"Create new object constraint added problem formulation.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"usage-30","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem class — ConservationProblem-class","text":"","code":"ConservationProblem$add_constraint(x)"},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"arguments-8","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conservation problem class — ConservationProblem-class","text":"x Constraint object.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"returns-30","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem class — ConservationProblem-class","text":"updated ConservationProblem object.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"method-add-penalty-","dir":"Reference","previous_headings":"","what":"Method add_penalty()","title":"Conservation problem class — ConservationProblem-class","text":"Create new object penalty added problem formulation.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"usage-31","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem class — ConservationProblem-class","text":"","code":"ConservationProblem$add_penalty(x)"},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"arguments-9","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conservation problem class — ConservationProblem-class","text":"x Penalty object.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"returns-31","dir":"Reference","previous_headings":"","what":"Returns","title":"Conservation problem class — ConservationProblem-class","text":"updated ConservationProblem object.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Conservation problem class — ConservationProblem-class","text":"objects class cloneable method.","code":""},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"usage-32","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation problem class — ConservationProblem-class","text":"","code":"ConservationProblem$clone(deep = FALSE)"},{"path":"https://prioritizr.net/reference/ConservationProblem-class.html","id":"arguments-10","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conservation problem class — ConservationProblem-class","text":"deep Whether make deep clone.","code":""},{"path":"https://prioritizr.net/reference/Constraint-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Constraint class — Constraint-class","title":"Constraint class — Constraint-class","text":"class used represent constraints used optimization. experts use fields methods class directly.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/Constraint-class.html","id":"super-class","dir":"Reference","previous_headings":"","what":"Super class","title":"Constraint class — Constraint-class","text":"prioritizr::ConservationModifier -> Constraint","code":""},{"path":"https://prioritizr.net/reference/Constraint-class.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Constraint class — Constraint-class","text":"prioritizr::ConservationModifier$calculate() prioritizr::ConservationModifier$get_data() prioritizr::ConservationModifier$get_internal() prioritizr::ConservationModifier$print() prioritizr::ConservationModifier$repr() prioritizr::ConservationModifier$set_data() prioritizr::ConservationModifier$set_internal() prioritizr::ConservationModifier$show()","code":""},{"path":"https://prioritizr.net/reference/Constraint-class.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Constraint class — Constraint-class","text":"Constraint$apply() Constraint$clone()","code":""},{"path":"https://prioritizr.net/reference/Constraint-class.html","id":"method-apply-","dir":"Reference","previous_headings":"","what":"Method apply()","title":"Constraint class — Constraint-class","text":"Update optimization problem formulation.","code":""},{"path":"https://prioritizr.net/reference/Constraint-class.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constraint class — Constraint-class","text":"","code":"Constraint$apply(x)"},{"path":"https://prioritizr.net/reference/Constraint-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constraint class — Constraint-class","text":"x optimization_problem() object.","code":""},{"path":"https://prioritizr.net/reference/Constraint-class.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"Constraint class — Constraint-class","text":"Invisible TRUE.","code":""},{"path":"https://prioritizr.net/reference/Constraint-class.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Constraint class — Constraint-class","text":"objects class cloneable method.","code":""},{"path":"https://prioritizr.net/reference/Constraint-class.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Constraint class — Constraint-class","text":"","code":"Constraint$clone(deep = FALSE)"},{"path":"https://prioritizr.net/reference/Constraint-class.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constraint class — Constraint-class","text":"deep Whether make deep clone.","code":""},{"path":"https://prioritizr.net/reference/Decision-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Decision class — Decision-class","title":"Decision class — Decision-class","text":"class used represent decision variables used optimization. experts use fields methods class directly.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/Decision-class.html","id":"super-class","dir":"Reference","previous_headings":"","what":"Super class","title":"Decision class — Decision-class","text":"prioritizr::ConservationModifier -> Decision","code":""},{"path":"https://prioritizr.net/reference/Decision-class.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Decision class — Decision-class","text":"prioritizr::ConservationModifier$calculate() prioritizr::ConservationModifier$get_data() prioritizr::ConservationModifier$get_internal() prioritizr::ConservationModifier$print() prioritizr::ConservationModifier$repr() prioritizr::ConservationModifier$set_data() prioritizr::ConservationModifier$set_internal() prioritizr::ConservationModifier$show()","code":""},{"path":"https://prioritizr.net/reference/Decision-class.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Decision class — Decision-class","text":"Decision$apply() Decision$clone()","code":""},{"path":"https://prioritizr.net/reference/Decision-class.html","id":"method-apply-","dir":"Reference","previous_headings":"","what":"Method apply()","title":"Decision class — Decision-class","text":"Update optimization problem formulation.","code":""},{"path":"https://prioritizr.net/reference/Decision-class.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Decision class — Decision-class","text":"","code":"Decision$apply(x)"},{"path":"https://prioritizr.net/reference/Decision-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Decision class — Decision-class","text":"x optimization_problem() object.","code":""},{"path":"https://prioritizr.net/reference/Decision-class.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"Decision class — Decision-class","text":"Invisible TRUE.","code":""},{"path":"https://prioritizr.net/reference/Decision-class.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Decision class — Decision-class","text":"objects class cloneable method.","code":""},{"path":"https://prioritizr.net/reference/Decision-class.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Decision class — Decision-class","text":"","code":"Decision$clone(deep = FALSE)"},{"path":"https://prioritizr.net/reference/Decision-class.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Decision class — Decision-class","text":"deep Whether make deep clone.","code":""},{"path":"https://prioritizr.net/reference/Objective-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Objective class — Objective-class","title":"Objective class — Objective-class","text":"class used represent objective function used optimization. experts use fields methods class directly.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/Objective-class.html","id":"super-class","dir":"Reference","previous_headings":"","what":"Super class","title":"Objective class — Objective-class","text":"prioritizr::ConservationModifier -> Objective","code":""},{"path":"https://prioritizr.net/reference/Objective-class.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Objective class — Objective-class","text":"prioritizr::ConservationModifier$calculate() prioritizr::ConservationModifier$get_data() prioritizr::ConservationModifier$get_internal() prioritizr::ConservationModifier$print() prioritizr::ConservationModifier$repr() prioritizr::ConservationModifier$set_data() prioritizr::ConservationModifier$set_internal() prioritizr::ConservationModifier$show()","code":""},{"path":"https://prioritizr.net/reference/Objective-class.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Objective class — Objective-class","text":"Objective$default_weights() Objective$apply() Objective$clone()","code":""},{"path":"https://prioritizr.net/reference/Objective-class.html","id":"method-default-weights-","dir":"Reference","previous_headings":"","what":"Method default_weights()","title":"Objective class — Objective-class","text":"Specify default values weights.","code":""},{"path":"https://prioritizr.net/reference/Objective-class.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Objective class — Objective-class","text":"","code":"Objective$default_weights(x)"},{"path":"https://prioritizr.net/reference/Objective-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Objective class — Objective-class","text":"x problem() object.","code":""},{"path":"https://prioritizr.net/reference/Objective-class.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"Objective class — Objective-class","text":"Invisible TRUE.","code":""},{"path":"https://prioritizr.net/reference/Objective-class.html","id":"method-apply-","dir":"Reference","previous_headings":"","what":"Method apply()","title":"Objective class — Objective-class","text":"Update optimization problem formulation.","code":""},{"path":"https://prioritizr.net/reference/Objective-class.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Objective class — Objective-class","text":"","code":"Objective$apply(x)"},{"path":"https://prioritizr.net/reference/Objective-class.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Objective class — Objective-class","text":"x optimization_problem() object.","code":""},{"path":"https://prioritizr.net/reference/Objective-class.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"Objective class — Objective-class","text":"Invisible TRUE.","code":""},{"path":"https://prioritizr.net/reference/Objective-class.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Objective class — Objective-class","text":"objects class cloneable method.","code":""},{"path":"https://prioritizr.net/reference/Objective-class.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"Objective class — Objective-class","text":"","code":"Objective$clone(deep = FALSE)"},{"path":"https://prioritizr.net/reference/Objective-class.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"Objective class — Objective-class","text":"deep Whether make deep clone.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimization problem class — OptimizationProblem-class","title":"Optimization problem class — OptimizationProblem-class","text":"class used represent optimization problem. stores information needed generate solution using exact algorithm solver. users use compile() generate new optimization problem objects, functions distributed package interact (e.g., base::.list()). experts use fields methods class directly.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"public-fields","dir":"Reference","previous_headings":"","what":"Public fields","title":"Optimization problem class — OptimizationProblem-class","text":"ptr Rcpp::Xptr external pointer. Create new optimization problem object.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Optimization problem class — OptimizationProblem-class","text":"OptimizationProblem$new() OptimizationProblem$print() OptimizationProblem$show() OptimizationProblem$ncol() OptimizationProblem$nrow() OptimizationProblem$ncell() OptimizationProblem$modelsense() OptimizationProblem$vtype() OptimizationProblem$obj() OptimizationProblem$() OptimizationProblem$rhs() OptimizationProblem$sense() OptimizationProblem$lb() OptimizationProblem$ub() OptimizationProblem$number_of_features() OptimizationProblem$number_of_planning_units() OptimizationProblem$number_of_zones() OptimizationProblem$col_ids() OptimizationProblem$row_ids() OptimizationProblem$compressed_formulation() OptimizationProblem$shuffle_columns() OptimizationProblem$clone()","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimization problem class — OptimizationProblem-class","text":"","code":"OptimizationProblem$new(ptr)"},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimization problem class — OptimizationProblem-class","text":"ptr Rcpp::Xptr external pointer.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"Optimization problem class — OptimizationProblem-class","text":"new OptimizationProblem object.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"method-print-","dir":"Reference","previous_headings":"","what":"Method print()","title":"Optimization problem class — OptimizationProblem-class","text":"Print concise information object.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimization problem class — OptimizationProblem-class","text":"","code":"OptimizationProblem$print()"},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"Optimization problem class — OptimizationProblem-class","text":"Invisible TRUE.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"method-show-","dir":"Reference","previous_headings":"","what":"Method show()","title":"Optimization problem class — OptimizationProblem-class","text":"Print concise information object.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimization problem class — OptimizationProblem-class","text":"","code":"OptimizationProblem$show()"},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"returns-2","dir":"Reference","previous_headings":"","what":"Returns","title":"Optimization problem class — OptimizationProblem-class","text":"Invisible TRUE.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"method-ncol-","dir":"Reference","previous_headings":"","what":"Method ncol()","title":"Optimization problem class — OptimizationProblem-class","text":"Obtain number columns problem formulation.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimization problem class — OptimizationProblem-class","text":"","code":"OptimizationProblem$ncol()"},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"returns-3","dir":"Reference","previous_headings":"","what":"Returns","title":"Optimization problem class — OptimizationProblem-class","text":"numeric value.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"method-nrow-","dir":"Reference","previous_headings":"","what":"Method nrow()","title":"Optimization problem class — OptimizationProblem-class","text":"Obtain number rows problem formulation.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimization problem class — OptimizationProblem-class","text":"","code":"OptimizationProblem$nrow()"},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"returns-4","dir":"Reference","previous_headings":"","what":"Returns","title":"Optimization problem class — OptimizationProblem-class","text":"numeric value.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"method-ncell-","dir":"Reference","previous_headings":"","what":"Method ncell()","title":"Optimization problem class — OptimizationProblem-class","text":"Obtain number cells problem formulation.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimization problem class — OptimizationProblem-class","text":"","code":"OptimizationProblem$ncell()"},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"returns-5","dir":"Reference","previous_headings":"","what":"Returns","title":"Optimization problem class — OptimizationProblem-class","text":"numeric value.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"method-modelsense-","dir":"Reference","previous_headings":"","what":"Method modelsense()","title":"Optimization problem class — OptimizationProblem-class","text":"Obtain model sense.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimization problem class — OptimizationProblem-class","text":"","code":"OptimizationProblem$modelsense()"},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"returns-6","dir":"Reference","previous_headings":"","what":"Returns","title":"Optimization problem class — OptimizationProblem-class","text":"character value.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"method-vtype-","dir":"Reference","previous_headings":"","what":"Method vtype()","title":"Optimization problem class — OptimizationProblem-class","text":"Obtain decision variable types.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"usage-7","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimization problem class — OptimizationProblem-class","text":"","code":"OptimizationProblem$vtype()"},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"returns-7","dir":"Reference","previous_headings":"","what":"Returns","title":"Optimization problem class — OptimizationProblem-class","text":"character vector.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"method-obj-","dir":"Reference","previous_headings":"","what":"Method obj()","title":"Optimization problem class — OptimizationProblem-class","text":"Obtain objective function.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"usage-8","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimization problem class — OptimizationProblem-class","text":"","code":"OptimizationProblem$obj()"},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"returns-8","dir":"Reference","previous_headings":"","what":"Returns","title":"Optimization problem class — OptimizationProblem-class","text":"numeric vector.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"method-a-","dir":"Reference","previous_headings":"","what":"Method A()","title":"Optimization problem class — OptimizationProblem-class","text":"Obtain constraint matrix.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"usage-9","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimization problem class — OptimizationProblem-class","text":"","code":"OptimizationProblem$A()"},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"returns-9","dir":"Reference","previous_headings":"","what":"Returns","title":"Optimization problem class — OptimizationProblem-class","text":"Matrix::sparseMatrix() object.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"method-rhs-","dir":"Reference","previous_headings":"","what":"Method rhs()","title":"Optimization problem class — OptimizationProblem-class","text":"Obtain right-hand-side constraint values.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"usage-10","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimization problem class — OptimizationProblem-class","text":"","code":"OptimizationProblem$rhs()"},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"returns-10","dir":"Reference","previous_headings":"","what":"Returns","title":"Optimization problem class — OptimizationProblem-class","text":"numeric vector.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"method-sense-","dir":"Reference","previous_headings":"","what":"Method sense()","title":"Optimization problem class — OptimizationProblem-class","text":"Obtain constraint senses.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"usage-11","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimization problem class — OptimizationProblem-class","text":"","code":"OptimizationProblem$sense()"},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"returns-11","dir":"Reference","previous_headings":"","what":"Returns","title":"Optimization problem class — OptimizationProblem-class","text":"character vector.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"method-lb-","dir":"Reference","previous_headings":"","what":"Method lb()","title":"Optimization problem class — OptimizationProblem-class","text":"Obtain lower bounds decision variables.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"usage-12","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimization problem class — OptimizationProblem-class","text":"","code":"OptimizationProblem$lb()"},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"returns-12","dir":"Reference","previous_headings":"","what":"Returns","title":"Optimization problem class — OptimizationProblem-class","text":"numeric vector.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"method-ub-","dir":"Reference","previous_headings":"","what":"Method ub()","title":"Optimization problem class — OptimizationProblem-class","text":"Obtain upper bounds decision variables.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"usage-13","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimization problem class — OptimizationProblem-class","text":"","code":"OptimizationProblem$ub()"},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"returns-13","dir":"Reference","previous_headings":"","what":"Returns","title":"Optimization problem class — OptimizationProblem-class","text":"numeric vector.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"method-number-of-features-","dir":"Reference","previous_headings":"","what":"Method number_of_features()","title":"Optimization problem class — OptimizationProblem-class","text":"Obtain number features.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"usage-14","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimization problem class — OptimizationProblem-class","text":"","code":"OptimizationProblem$number_of_features()"},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"returns-14","dir":"Reference","previous_headings":"","what":"Returns","title":"Optimization problem class — OptimizationProblem-class","text":"numeric value.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"method-number-of-planning-units-","dir":"Reference","previous_headings":"","what":"Method number_of_planning_units()","title":"Optimization problem class — OptimizationProblem-class","text":"Obtain number planning units.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"usage-15","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimization problem class — OptimizationProblem-class","text":"","code":"OptimizationProblem$number_of_planning_units()"},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"returns-15","dir":"Reference","previous_headings":"","what":"Returns","title":"Optimization problem class — OptimizationProblem-class","text":"numeric value.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"method-number-of-zones-","dir":"Reference","previous_headings":"","what":"Method number_of_zones()","title":"Optimization problem class — OptimizationProblem-class","text":"Obtain number zones.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"usage-16","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimization problem class — OptimizationProblem-class","text":"","code":"OptimizationProblem$number_of_zones()"},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"returns-16","dir":"Reference","previous_headings":"","what":"Returns","title":"Optimization problem class — OptimizationProblem-class","text":"numeric value.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"method-col-ids-","dir":"Reference","previous_headings":"","what":"Method col_ids()","title":"Optimization problem class — OptimizationProblem-class","text":"Obtain identifiers columns.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"usage-17","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimization problem class — OptimizationProblem-class","text":"","code":"OptimizationProblem$col_ids()"},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"returns-17","dir":"Reference","previous_headings":"","what":"Returns","title":"Optimization problem class — OptimizationProblem-class","text":"character value.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"method-row-ids-","dir":"Reference","previous_headings":"","what":"Method row_ids()","title":"Optimization problem class — OptimizationProblem-class","text":"Obtain identifiers rows.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"usage-18","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimization problem class — OptimizationProblem-class","text":"","code":"OptimizationProblem$row_ids()"},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"returns-18","dir":"Reference","previous_headings":"","what":"Returns","title":"Optimization problem class — OptimizationProblem-class","text":"character value.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"method-compressed-formulation-","dir":"Reference","previous_headings":"","what":"Method compressed_formulation()","title":"Optimization problem class — OptimizationProblem-class","text":"problem formulation compressed?","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"usage-19","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimization problem class — OptimizationProblem-class","text":"","code":"OptimizationProblem$compressed_formulation()"},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"returns-19","dir":"Reference","previous_headings":"","what":"Returns","title":"Optimization problem class — OptimizationProblem-class","text":"logical value.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"method-shuffle-columns-","dir":"Reference","previous_headings":"","what":"Method shuffle_columns()","title":"Optimization problem class — OptimizationProblem-class","text":"Shuffle order columns conservation problem.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"usage-20","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimization problem class — OptimizationProblem-class","text":"","code":"OptimizationProblem$shuffle_columns()"},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"returns-20","dir":"Reference","previous_headings":"","what":"Returns","title":"Optimization problem class — OptimizationProblem-class","text":"integer vector indices un-shuffle problem.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Optimization problem class — OptimizationProblem-class","text":"objects class cloneable method.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"usage-21","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimization problem class — OptimizationProblem-class","text":"","code":"OptimizationProblem$clone(deep = FALSE)"},{"path":"https://prioritizr.net/reference/OptimizationProblem-class.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimization problem class — OptimizationProblem-class","text":"deep Whether make deep clone.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimization problem methods — OptimizationProblem-methods","title":"Optimization problem methods — OptimizationProblem-methods","text":"functions used access data optimization_problem().","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimization problem methods — OptimizationProblem-methods","text":"","code":"# S4 method for OptimizationProblem nrow(x)  # S4 method for OptimizationProblem ncol(x)  # S4 method for OptimizationProblem ncell(x)  modelsense(x)  # S4 method for OptimizationProblem modelsense(x)  vtype(x)  # S4 method for OptimizationProblem vtype(x)  obj(x)  # S4 method for OptimizationProblem obj(x)  A(x)  # S4 method for OptimizationProblem A(x)  rhs(x)  # S4 method for OptimizationProblem rhs(x)  sense(x)  # S4 method for OptimizationProblem sense(x)  lb(x)  # S4 method for OptimizationProblem lb(x)  ub(x)  # S4 method for OptimizationProblem ub(x)  col_ids(x)  # S4 method for OptimizationProblem col_ids(x)  row_ids(x)  # S4 method for OptimizationProblem row_ids(x)  compressed_formulation(x)  # S4 method for OptimizationProblem compressed_formulation(x)"},{"path":"https://prioritizr.net/reference/OptimizationProblem-methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimization problem methods — OptimizationProblem-methods","text":"x optimization_problem() object.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-methods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimization problem methods — OptimizationProblem-methods","text":"dgCMatrix, numeric vector, numeric vector, scalar integer depending method used.","code":""},{"path":"https://prioritizr.net/reference/OptimizationProblem-methods.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Optimization problem methods — OptimizationProblem-methods","text":"functions return following data: nrow integer number rows (constraints). ncol integer number columns (decision variables). ncell integer number cells. modelsense character describing problem maximized (\"max\") minimized (\"min\"). vtype character describing type decision variable: binary (\"B\"), semi-continuous (\"S\"), continuous (\"C\") obj numeric vector specifying objective function. dgCMatrix matrix object defining problem matrix. rhs numeric vector right-hand-side linear constraints sense character vector senses linear constraints (\"<=\", \">=\", \"=\"). lb numeric lower bound decision variable. Missing data values (NA) indicate lower bound given variable. ub numeric upper bounds decision variable. Missing data values (NA) indicate upper bound given variable. number_of_planning_units integer number planning units problem. number_of_features integer number features problem.","code":""},{"path":"https://prioritizr.net/reference/Penalty-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Penalty class — Penalty-class","title":"Penalty class — Penalty-class","text":"class used represent penalties used optimization. experts use fields methods class directly.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/Penalty-class.html","id":"super-class","dir":"Reference","previous_headings":"","what":"Super class","title":"Penalty class — Penalty-class","text":"prioritizr::ConservationModifier -> Penalty","code":""},{"path":"https://prioritizr.net/reference/Penalty-class.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Penalty class — Penalty-class","text":"prioritizr::ConservationModifier$calculate() prioritizr::ConservationModifier$get_data() prioritizr::ConservationModifier$get_internal() prioritizr::ConservationModifier$print() prioritizr::ConservationModifier$repr() prioritizr::ConservationModifier$set_data() prioritizr::ConservationModifier$set_internal() prioritizr::ConservationModifier$show()","code":""},{"path":"https://prioritizr.net/reference/Penalty-class.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Penalty class — Penalty-class","text":"Penalty$apply() Penalty$clone()","code":""},{"path":"https://prioritizr.net/reference/Penalty-class.html","id":"method-apply-","dir":"Reference","previous_headings":"","what":"Method apply()","title":"Penalty class — Penalty-class","text":"Update optimization problem formulation.","code":""},{"path":"https://prioritizr.net/reference/Penalty-class.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Penalty class — Penalty-class","text":"","code":"Penalty$apply(x)"},{"path":"https://prioritizr.net/reference/Penalty-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Penalty class — Penalty-class","text":"x optimization_problem() object.","code":""},{"path":"https://prioritizr.net/reference/Penalty-class.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"Penalty class — Penalty-class","text":"Invisible TRUE.","code":""},{"path":"https://prioritizr.net/reference/Penalty-class.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Penalty class — Penalty-class","text":"objects class cloneable method.","code":""},{"path":"https://prioritizr.net/reference/Penalty-class.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Penalty class — Penalty-class","text":"","code":"Penalty$clone(deep = FALSE)"},{"path":"https://prioritizr.net/reference/Penalty-class.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Penalty class — Penalty-class","text":"deep Whether make deep clone.","code":""},{"path":"https://prioritizr.net/reference/Portfolio-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Portfolio class — Portfolio-class","title":"Portfolio class — Portfolio-class","text":"class used represent portfolios used optimization. experts use fields methods class directly.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/Portfolio-class.html","id":"super-class","dir":"Reference","previous_headings":"","what":"Super class","title":"Portfolio class — Portfolio-class","text":"prioritizr::ConservationModifier -> Portfolio","code":""},{"path":"https://prioritizr.net/reference/Portfolio-class.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Portfolio class — Portfolio-class","text":"prioritizr::ConservationModifier$calculate() prioritizr::ConservationModifier$get_data() prioritizr::ConservationModifier$get_internal() prioritizr::ConservationModifier$print() prioritizr::ConservationModifier$repr() prioritizr::ConservationModifier$set_data() prioritizr::ConservationModifier$set_internal() prioritizr::ConservationModifier$show()","code":""},{"path":"https://prioritizr.net/reference/Portfolio-class.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Portfolio class — Portfolio-class","text":"Portfolio$run() Portfolio$clone()","code":""},{"path":"https://prioritizr.net/reference/Portfolio-class.html","id":"method-run-","dir":"Reference","previous_headings":"","what":"Method run()","title":"Portfolio class — Portfolio-class","text":"Run portfolio generate solutions.","code":""},{"path":"https://prioritizr.net/reference/Portfolio-class.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Portfolio class — Portfolio-class","text":"","code":"Portfolio$run(x, solver)"},{"path":"https://prioritizr.net/reference/Portfolio-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Portfolio class — Portfolio-class","text":"x optimization_problem() object. solver Solver object.","code":""},{"path":"https://prioritizr.net/reference/Portfolio-class.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"Portfolio class — Portfolio-class","text":"list solutions.","code":""},{"path":"https://prioritizr.net/reference/Portfolio-class.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Portfolio class — Portfolio-class","text":"objects class cloneable method.","code":""},{"path":"https://prioritizr.net/reference/Portfolio-class.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Portfolio class — Portfolio-class","text":"","code":"Portfolio$clone(deep = FALSE)"},{"path":"https://prioritizr.net/reference/Portfolio-class.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Portfolio class — Portfolio-class","text":"deep Whether make deep clone.","code":""},{"path":"https://prioritizr.net/reference/Solver-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Solver class — Solver-class","title":"Solver class — Solver-class","text":"class used represent solvers optimization. experts use fields methods class directly.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/Solver-class.html","id":"super-class","dir":"Reference","previous_headings":"","what":"Super class","title":"Solver class — Solver-class","text":"prioritizr::ConservationModifier -> Solver","code":""},{"path":"https://prioritizr.net/reference/Solver-class.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Solver class — Solver-class","text":"prioritizr::ConservationModifier$get_data() prioritizr::ConservationModifier$get_internal() prioritizr::ConservationModifier$print() prioritizr::ConservationModifier$repr() prioritizr::ConservationModifier$set_data() prioritizr::ConservationModifier$set_internal() prioritizr::ConservationModifier$show()","code":""},{"path":"https://prioritizr.net/reference/Solver-class.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Solver class — Solver-class","text":"Solver$run() Solver$calculate() Solver$set_variable_ub() Solver$set_variable_lb() Solver$solve() Solver$clone()","code":""},{"path":"https://prioritizr.net/reference/Solver-class.html","id":"method-run-","dir":"Reference","previous_headings":"","what":"Method run()","title":"Solver class — Solver-class","text":"Run solver generate solution.","code":""},{"path":"https://prioritizr.net/reference/Solver-class.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Solver class — Solver-class","text":"","code":"Solver$run()"},{"path":"https://prioritizr.net/reference/Solver-class.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"Solver class — Solver-class","text":"list solutions.","code":""},{"path":"https://prioritizr.net/reference/Solver-class.html","id":"method-calculate-","dir":"Reference","previous_headings":"","what":"Method calculate()","title":"Solver class — Solver-class","text":"Perform computations need completed applying object.","code":""},{"path":"https://prioritizr.net/reference/Solver-class.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Solver class — Solver-class","text":"","code":"Solver$calculate(...)"},{"path":"https://prioritizr.net/reference/Solver-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Solver class — Solver-class","text":"... Additional arguments. x optimization_problem() object.","code":""},{"path":"https://prioritizr.net/reference/Solver-class.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"Solver class — Solver-class","text":"Invisible TRUE.","code":""},{"path":"https://prioritizr.net/reference/Solver-class.html","id":"method-set-variable-ub-","dir":"Reference","previous_headings":"","what":"Method set_variable_ub()","title":"Solver class — Solver-class","text":"Set upper bound decision variable.","code":""},{"path":"https://prioritizr.net/reference/Solver-class.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"Solver class — Solver-class","text":"","code":"Solver$set_variable_ub(index, value)"},{"path":"https://prioritizr.net/reference/Solver-class.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Solver class — Solver-class","text":"index integer value indicating index decision variable. value numeric new bound value.","code":""},{"path":"https://prioritizr.net/reference/Solver-class.html","id":"returns-2","dir":"Reference","previous_headings":"","what":"Returns","title":"Solver class — Solver-class","text":"Invisible TRUE.","code":""},{"path":"https://prioritizr.net/reference/Solver-class.html","id":"method-set-variable-lb-","dir":"Reference","previous_headings":"","what":"Method set_variable_lb()","title":"Solver class — Solver-class","text":"Set lower bound decision variable.","code":""},{"path":"https://prioritizr.net/reference/Solver-class.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"Solver class — Solver-class","text":"","code":"Solver$set_variable_lb(index, value)"},{"path":"https://prioritizr.net/reference/Solver-class.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"Solver class — Solver-class","text":"index integer value indicating index decision variable. value numeric new bound value.","code":""},{"path":"https://prioritizr.net/reference/Solver-class.html","id":"returns-3","dir":"Reference","previous_headings":"","what":"Returns","title":"Solver class — Solver-class","text":"Invisible TRUE.","code":""},{"path":"https://prioritizr.net/reference/Solver-class.html","id":"method-solve-","dir":"Reference","previous_headings":"","what":"Method solve()","title":"Solver class — Solver-class","text":"Solve optimization problem.","code":""},{"path":"https://prioritizr.net/reference/Solver-class.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"Solver class — Solver-class","text":"","code":"Solver$solve(x, ...)"},{"path":"https://prioritizr.net/reference/Solver-class.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"Solver class — Solver-class","text":"x optimization_problem() object. ... Additional arguments passed calculate() method.","code":""},{"path":"https://prioritizr.net/reference/Solver-class.html","id":"returns-4","dir":"Reference","previous_headings":"","what":"Returns","title":"Solver class — Solver-class","text":"Invisible TRUE.","code":""},{"path":"https://prioritizr.net/reference/Solver-class.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Solver class — Solver-class","text":"objects class cloneable method.","code":""},{"path":"https://prioritizr.net/reference/Solver-class.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"Solver class — Solver-class","text":"","code":"Solver$clone(deep = FALSE)"},{"path":"https://prioritizr.net/reference/Solver-class.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"Solver class — Solver-class","text":"deep Whether make deep clone.","code":""},{"path":"https://prioritizr.net/reference/Target-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Target class — Target-class","title":"Target class — Target-class","text":"class used represent targets optimization. experts use fields methods class directly.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/Target-class.html","id":"super-class","dir":"Reference","previous_headings":"","what":"Super class","title":"Target class — Target-class","text":"prioritizr::ConservationModifier -> Target","code":""},{"path":"https://prioritizr.net/reference/Target-class.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Target class — Target-class","text":"prioritizr::ConservationModifier$calculate() prioritizr::ConservationModifier$get_data() prioritizr::ConservationModifier$get_internal() prioritizr::ConservationModifier$print() prioritizr::ConservationModifier$repr() prioritizr::ConservationModifier$set_data() prioritizr::ConservationModifier$set_internal() prioritizr::ConservationModifier$show()","code":""},{"path":"https://prioritizr.net/reference/Target-class.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Target class — Target-class","text":"Target$output() Target$clone()","code":""},{"path":"https://prioritizr.net/reference/Target-class.html","id":"method-output-","dir":"Reference","previous_headings":"","what":"Method output()","title":"Target class — Target-class","text":"Output targets.","code":""},{"path":"https://prioritizr.net/reference/Target-class.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Target class — Target-class","text":"","code":"Target$output()"},{"path":"https://prioritizr.net/reference/Target-class.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"Target class — Target-class","text":"tibble::tibble() data frame.","code":""},{"path":"https://prioritizr.net/reference/Target-class.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Target class — Target-class","text":"objects class cloneable method.","code":""},{"path":"https://prioritizr.net/reference/Target-class.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Target class — Target-class","text":"","code":"Target$clone(deep = FALSE)"},{"path":"https://prioritizr.net/reference/Target-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Target class — Target-class","text":"deep Whether make deep clone.","code":""},{"path":"https://prioritizr.net/reference/add_absolute_targets.html","id":null,"dir":"Reference","previous_headings":"","what":"Add absolute targets — add_absolute_targets","title":"Add absolute targets — add_absolute_targets","text":"Set targets expressed actual value features study area need represented prioritization. instance, setting target 10 requires solution secure set planning units summed feature values equal greater 10.","code":""},{"path":"https://prioritizr.net/reference/add_absolute_targets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add absolute targets — add_absolute_targets","text":"","code":"add_absolute_targets(x, targets)  # S4 method for ConservationProblem,numeric add_absolute_targets(x, targets)  # S4 method for ConservationProblem,matrix add_absolute_targets(x, targets)  # S4 method for ConservationProblem,character add_absolute_targets(x, targets)"},{"path":"https://prioritizr.net/reference/add_absolute_targets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add absolute targets — add_absolute_targets","text":"x problem() object. targets object specifies targets feature. See Targets format section information.","code":""},{"path":"https://prioritizr.net/reference/add_absolute_targets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add absolute targets — add_absolute_targets","text":"updated problem() object targets added .","code":""},{"path":"https://prioritizr.net/reference/add_absolute_targets.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add absolute targets — add_absolute_targets","text":"Targets used specify minimum amount proportion feature's distribution needs protected. conservation planning problems require targets exception maximum cover (see add_max_cover_objective()) maximum utility (see add_max_utility_objective()) problems. Attempting solve problems objectives require targets without specifying targets throw error. problems associated multiple management zones, add_absolute_targets() can used set targets pertain single feature single zone. set targets can met allocating different planning units multiple zones, see add_manual_targets() function. example target met allocations multiple zones might management zone expected result different amount feature target requires total amount feature zones must exceed certain threshold. words, target require single zone secure specific amount feature, total amount held zones must secure specific amount. Thus target , potentially, met allocating planning units specific management zone, allocating planning units different combinations management zones.","code":""},{"path":"https://prioritizr.net/reference/add_absolute_targets.html","id":"targets-format","dir":"Reference","previous_headings":"","what":"Targets format","title":"Add absolute targets — add_absolute_targets","text":"targets problem can specified using following formats. targets numeric vector containing target values feature. Additionally, convenience, format can single value assign target feature. Note format used specify targets problems multiple zones. targets matrix object containing target feature zone. , row corresponds different feature argument x, column corresponds different zone argument x, cell contains target value given feature solution needs secure given zone. targets character vector containing column name(s) feature data associated argument x contain targets. format can used feature data associated x sf::st_sf() data.frame. problems contain single zone, argument targets must contain single column name. Otherwise, problems contain multiple zones, argument targets must contain column name zone.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_absolute_targets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add absolute targets — add_absolute_targets","text":"","code":"# \\dontrun{ # set seed for reproducibility set.seed(500)  # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_features <- get_sim_zones_features()  # create minimal problem with no targets p0 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # create problem with targets to secure 3 amounts for each feature p1 <- p0 %>% add_absolute_targets(3)  # create problem with varying targets for each feature targets <- c(1, 2, 3, 2, 1) p2 <- p0 %>% add_absolute_targets(targets)  # solve problem s1 <- c(solve(p1), solve(p2)) names(s1) <- c(\"equal targets\", \"varying targets\")  # plot solution plot(s1, axes = FALSE)   # create a problem with multiple management zones p3 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_min_set_objective() %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # create a problem with targets that specify an equal amount of each feature # to be represented in each zone p4_targets <- matrix(   2,   nrow = number_of_features(sim_zones_features),   ncol = number_of_zones(sim_zones_features),   dimnames = list(     feature_names(sim_zones_features), zone_names(sim_zones_features)   ) ) print(p4_targets) #>           zone_1 zone_2 zone_3 #> feature_1      2      2      2 #> feature_2      2      2      2 #> feature_3      2      2      2 #> feature_4      2      2      2 #> feature_5      2      2      2  p4 <- p3 %>% add_absolute_targets(p4_targets)  # solve problem s4 <- solve(p4)  # plot solution (pixel values correspond to zone identifiers) plot(category_layer(s4), main = \"equal targets\", axes = FALSE)   # create a problem with targets that require a varying amount of each # feature to be represented in each zone p5_targets <- matrix(   rpois(15, 1),   nrow = number_of_features(sim_zones_features),   ncol = number_of_zones(sim_zones_features),   dimnames = list(     feature_names(sim_zones_features),     zone_names(sim_zones_features)   ) ) print(p5_targets) #>           zone_1 zone_2 zone_3 #> feature_1      2      0      0 #> feature_2      1      1      2 #> feature_3      3      3      2 #> feature_4      1      2      0 #> feature_5      2      1      1  p5 <- p3 %>% add_absolute_targets(p5_targets)  # solve problem s5 <- solve(p5)  # plot solution (pixel values correspond to zone identifiers) plot(category_layer(s5), main = \"varying targets\", axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_asym_connectivity_penalties.html","id":null,"dir":"Reference","previous_headings":"","what":"Add asymmetric connectivity penalties — add_asym_connectivity_penalties","title":"Add asymmetric connectivity penalties — add_asym_connectivity_penalties","text":"Add penalties conservation planning problem account asymmetric connectivity planning units. Asymmetric connectivity data describe connectivity information directional. example, asymmetric connectivity data describe strength rivers flowing different planning units. Since river flow directional, level connectivity upstream planning unit downstream planning unit higher downstream planning unit upstream planning unit.","code":""},{"path":"https://prioritizr.net/reference/add_asym_connectivity_penalties.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add asymmetric connectivity penalties — add_asym_connectivity_penalties","text":"","code":"# S4 method for ConservationProblem,ANY,ANY,matrix add_asym_connectivity_penalties(x, penalty, zones, data)  # S4 method for ConservationProblem,ANY,ANY,Matrix add_asym_connectivity_penalties(x, penalty, zones, data)  # S4 method for ConservationProblem,ANY,ANY,data.frame add_asym_connectivity_penalties(x, penalty, zones, data)  # S4 method for ConservationProblem,ANY,ANY,dgCMatrix add_asym_connectivity_penalties(x, penalty, zones, data)  # S4 method for ConservationProblem,ANY,ANY,array add_asym_connectivity_penalties(x, penalty, zones, data)"},{"path":"https://prioritizr.net/reference/add_asym_connectivity_penalties.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add asymmetric connectivity penalties — add_asym_connectivity_penalties","text":"x problem() object. penalty numeric penalty used scale importance selecting planning units strong connectivity compared main problem objective (e.g., solution cost argument x minimum set objective set using add_min_set_objective()). Higher penalty values can used obtain solutions high degree connectivity, smaller penalty values can used obtain solutions small degree connectivity. Note negative penalty values can used obtain solutions little connectivity. zones matrix Matrix object describing level connectivity different zones. row column corresponds different zone argument x, cell values indicate level connectivity combination zones. Cell values along diagonal matrix represent level connectivity planning units allocated zone. Cell values must lay 1 -1, negative values favor solutions weak connectivity. default argument zones identity matrix (.e., matrix ones along matrix diagonal zeros elsewhere), planning units considered connected allocated zone. argument required working multiple zones argument data matrix Matrix object. argument data array data.frame data multiple zones (e.g., using \"zone1\" \"zone2\" column names), argument must explicitly set NULL otherwise error thrown. data matrix, Matrix, data.frame, array object containing connectivity data. connectivity values correspond strength connectivity different planning units. Thus connections planning units associated higher values favorable solution. See Data format section information.","code":""},{"path":"https://prioritizr.net/reference/add_asym_connectivity_penalties.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add asymmetric connectivity penalties — add_asym_connectivity_penalties","text":"updated problem() object penalties added .","code":""},{"path":"https://prioritizr.net/reference/add_asym_connectivity_penalties.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add asymmetric connectivity penalties — add_asym_connectivity_penalties","text":"function adds penalties conservation planning problem penalize solutions low connectivity. Specifically, penalizes solutions select planning units share high connectivity values planning units selected solution (based Beger et al. 2010).","code":""},{"path":"https://prioritizr.net/reference/add_asym_connectivity_penalties.html","id":"mathematical-formulation","dir":"Reference","previous_headings":"","what":"Mathematical formulation","title":"Add asymmetric connectivity penalties — add_asym_connectivity_penalties","text":"connectivity penalties implemented using following equations. Let \\(\\) represent set planning units (indexed \\(\\) \\(j\\)), \\(Z\\) represent set management zones (indexed \\(z\\) \\(y\\)), \\(X_{iz}\\) represent decision variable planning unit \\(\\) zone \\(z\\) (e.g., binary values one indicating planning unit allocated ). Also, let \\(p\\) represent argument penalty, \\(D\\) represent argument data, \\(W\\) represent argument zones. argument data supplied matrix Matrix object, penalties calculated : $$ \\sum_{}^{} \\sum_{j}^{} \\sum_{z}^{Z} \\sum_{y}^{Z} (p \\times X_{iz} \\times D_{ij} \\times W_{zy}) - \\sum_{}^{} \\sum_{j}^{} \\sum_{z}^{Z} \\sum_{y}^{Z} (p \\times X_{iz} \\times X_{jy} \\times D_{ij} \\times W_{zy})$$ Otherwise, argument data supplied array object, penalties calculated : $$ \\sum_{}^{} \\sum_{j}^{} \\sum_{z}^{Z} \\sum_{y}^{Z} (p \\times X_{iz} \\times D_{ijzy}) - \\sum_{}^{} \\sum_{j}^{} \\sum_{z}^{Z} \\sum_{y}^{Z} (p \\times X_{iz} \\times X_{jy} \\times D_{ijzy})$$ Note problem objective maximize measure benefit minimize measure cost, term \\(p\\) replaced \\(-p\\).","code":""},{"path":"https://prioritizr.net/reference/add_asym_connectivity_penalties.html","id":"data-format","dir":"Reference","previous_headings":"","what":"Data format","title":"Add asymmetric connectivity penalties — add_asym_connectivity_penalties","text":"argument data can specified using several different formats. data matrix/Matrix object rows columns represent different planning units value cell represents strength connectivity two different planning units. Cells occur along matrix diagonal treated weights indicate planning units desirable solution. argument zones can used control strength connectivity planning units different zones. default argument zones treat planning units allocated different zones zero connectivity. data data.frame object containing columns named \"id1\", \"id2\", \"boundary\". , row denotes connectivity pair planning units (per values \"id1\" \"id2\" columns) following Marxan format. argument x contains multiple zones, \"zone1\" \"zone2\" columns can optionally provided manually specify connectivity values planning units allocated specific zones. \"zone1\" \"zone2\" columns present, argument zones must NULL. data array object containing four-dimensions cell values indicate strength connectivity planning units assigned specific management zones. first two dimensions (.e., rows columns) indicate strength connectivity different planning units second two dimensions indicate different management zones. Thus data[1, 2, 3, 4] indicates strength connectivity planning unit 1 planning unit 2 planning unit 1 assigned zone 3 planning unit 2 assigned zone 4.","code":""},{"path":"https://prioritizr.net/reference/add_asym_connectivity_penalties.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Add asymmetric connectivity penalties — add_asym_connectivity_penalties","text":"Beger M, Linke S, Watts M, Game E, Treml E, Ball , Possingham, HP (2010) Incorporating asymmetric connectivity spatial decision making conservation, Conservation Letters, 3: 359--368.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_asym_connectivity_penalties.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add asymmetric connectivity penalties — add_asym_connectivity_penalties","text":"","code":"# \\dontrun{ # load package library(Matrix)  # set seed for reproducibility set.seed(600)  # load data sim_pu_polygons <- get_sim_pu_polygons() sim_features <- get_sim_features() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_features <- get_sim_zones_features()  # create basic problem p1 <-   problem(sim_pu_polygons, sim_features, \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.2) %>%   add_default_solver(verbose = FALSE)  # create an asymmetric connectivity matrix. Here, connectivity occurs between # adjacent planning units and, due to rivers flowing southwards # through the study area, connectivity from northern planning units to # southern planning units is ten times stronger than the reverse. acm1 <- matrix(0, nrow(sim_pu_polygons), nrow(sim_pu_polygons)) acm1 <- as(acm1, \"Matrix\") centroids <- sf::st_coordinates(   suppressWarnings(sf::st_centroid(sim_pu_polygons)) ) adjacent_units <- sf::st_intersects(sim_pu_polygons, sparse = FALSE) for (i in seq_len(nrow(sim_pu_polygons))) {   for (j in seq_len(nrow(sim_pu_polygons))) {     # find if planning units are adjacent     if (adjacent_units[i, j]) {       # find if planning units lay north and south of each other       # i.e., they have the same x-coordinate       if (centroids[i, 1] == centroids[j, 1]) {         if (centroids[i, 2] > centroids[j, 2]) {           # if i is north of j add 10 units of connectivity           acm1[i, j] <- acm1[i, j] + 10         } else if (centroids[i, 2] < centroids[j, 2]) {           # if i is south of j add 1 unit of connectivity           acm1[i, j] <- acm1[i, j] + 1         }       }     }   } }  # rescale matrix values to have a maximum value of 1 acm1 <- rescale_matrix(acm1, max = 1)  # visualize asymmetric connectivity matrix image(acm1)   # create penalties penalties <- c(1, 50)  # create problems using the different penalties p2 <- list(   p1,   p1 %>% add_asym_connectivity_penalties(penalties[1], data = acm1),   p1 %>% add_asym_connectivity_penalties(penalties[2], data = acm1) )  # solve problems s2 <- lapply(p2, solve)  # create object with all solutions s2 <- sf::st_sf(   tibble::tibble(     p2_1 = s2[[1]]$solution_1,     p2_2 = s2[[2]]$solution_1,     p2_3 = s2[[3]]$solution_1  ),  geometry = sf::st_geometry(s2[[1]]) )  names(s2)[1:3] <- c(\"basic problem\", paste0(\"acm1 (\", penalties,\")\"))  # plot solutions based on different penalty values plot(s2, cex = 1.5)   # create minimal multi-zone problem and limit solver to one minute # to obtain solutions in a short period of time p3 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_min_set_objective() %>%   add_relative_targets(matrix(0.15, nrow = 5, ncol = 3)) %>%   add_binary_decisions() %>%   add_default_solver(time_limit = 60, verbose = FALSE)  # crate asymmetric connectivity data by randomly simulating values acm2 <- matrix(   runif(ncell(sim_zones_pu_raster) ^ 2),   nrow = ncell(sim_zones_pu_raster) )  # create multi-zone problems using the penalties p4 <- list(   p3,   p3 %>% add_asym_connectivity_penalties(penalties[1], data = acm2),   p3 %>% add_asym_connectivity_penalties(penalties[2], data = acm2) )  # solve problems s4 <- lapply(p4, solve) s4 <- lapply(s4, category_layer) s4 <- terra::rast(s4) names(s4) <- c(\"basic problem\", paste0(\"acm2 (\", penalties,\")\"))  # plot solutions plot(s4, axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_binary_decisions.html","id":null,"dir":"Reference","previous_headings":"","what":"Add binary decisions — add_binary_decisions","title":"Add binary decisions — add_binary_decisions","text":"Add binary decision conservation planning problem. classic decision either prioritizing prioritizing planning unit. Typically, decision assumed action buying planning unit include protected area network. decision added problem decision class used default.","code":""},{"path":"https://prioritizr.net/reference/add_binary_decisions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add binary decisions — add_binary_decisions","text":"","code":"add_binary_decisions(x)"},{"path":"https://prioritizr.net/reference/add_binary_decisions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add binary decisions — add_binary_decisions","text":"x problem() object.","code":""},{"path":"https://prioritizr.net/reference/add_binary_decisions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add binary decisions — add_binary_decisions","text":"updated problem() object decisions added .","code":""},{"path":"https://prioritizr.net/reference/add_binary_decisions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add binary decisions — add_binary_decisions","text":"Conservation planning problems involve making decisions planning units. decisions associated actions (e.g., turning planning unit protected area). single decision added problem() object. Note multiple decisions added object, last one added used.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_binary_decisions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add binary decisions — add_binary_decisions","text":"","code":"# \\dontrun{ # set seed for reproducibility set.seed(500)  # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_features <- get_sim_zones_features()  # create minimal problem with binary decisions p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s1 <- solve(p1)  # plot solution plot(s1, main = \"solution\", axes = FALSE)   # create a matrix with targets for a multi-zone conservation problem targs <- matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)  # build multi-zone conservation problem with binary decisions p2 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_min_set_objective() %>%   add_relative_targets(targs)  %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve the problem s2 <- solve(p2)  # print solution print(s2) #> class       : SpatRaster  #> dimensions  : 10, 10, 3  (nrow, ncol, nlyr) #> resolution  : 0.1, 0.1  (x, y) #> extent      : 0, 1, 0, 1  (xmin, xmax, ymin, ymax) #> coord. ref. : Undefined Cartesian SRS  #> source(s)   : memory #> names       : zone_1, zone_2, zone_3  #> min values  :      0,      0,      0  #> max values  :      1,      1,      1   # plot solution plot(category_layer(s2), main = \"solution\", axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_boundary_penalties.html","id":null,"dir":"Reference","previous_headings":"","what":"Add boundary penalties — add_boundary_penalties","title":"Add boundary penalties — add_boundary_penalties","text":"Add penalties conservation planning problem favor solutions spatially clump planning units together based overall boundary length (.e., total perimeter).","code":""},{"path":"https://prioritizr.net/reference/add_boundary_penalties.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add boundary penalties — add_boundary_penalties","text":"","code":"# S4 method for ConservationProblem,ANY,ANY,ANY,data.frame add_boundary_penalties(x, penalty, edge_factor, zones, data)  # S4 method for ConservationProblem,ANY,ANY,ANY,matrix add_boundary_penalties(x, penalty, edge_factor, zones, data)  # S4 method for ConservationProblem,ANY,ANY,ANY,ANY add_boundary_penalties(x, penalty, edge_factor, zones, data)"},{"path":"https://prioritizr.net/reference/add_boundary_penalties.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add boundary penalties — add_boundary_penalties","text":"x problem() object. penalty numeric penalty used scale importance selecting planning units spatially clumped together compared main problem objective (e.g., solution cost argument x minimum set objective per add_min_set_objective()). Higher penalty values prefer solutions higher degree spatial clumping, smaller penalty values prefer solutions smaller degree clumping. Note negative penalty values prefer solutions spread . parameter equivalent boundary length modifier (BLM) parameter Marxan. edge_factor numeric proportion scale planning unit edges (borders) neighboring planning units. example, edge factor 0.5 commonly used avoid overly penalizing planning units along coastline. Note argument must element zone argument x. zones matrix Matrix object describing clumping scheme different zones. row column corresponds different zone argument x, cell values indicate relative importance clumping planning units allocated combination zones. Cell values along diagonal matrix represent relative importance clumping planning units allocated zone. Cell values must range 1 -1, negative values favor solutions spread planning units. default argument zones identity matrix (.e., matrix ones along matrix diagonal zeros elsewhere), penalties incurred neighboring planning units assigned zone. cells along matrix diagonal contain markedly smaller values found elsewhere matrix, solutions preferred surround planning units allocated different zones (.e., greater spatial fragmentation). data NULL, data.frame, matrix, Matrix object containing boundary data. data describe total amount boundary (perimeter) length  planning unit, amount boundary (perimeter) length shared different planning units (.e., planning units adjacent ). See Data format section information.","code":""},{"path":"https://prioritizr.net/reference/add_boundary_penalties.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add boundary penalties — add_boundary_penalties","text":"updated problem() object penalties added .","code":""},{"path":"https://prioritizr.net/reference/add_boundary_penalties.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add boundary penalties — add_boundary_penalties","text":"function adds penalties conservation planning problem penalize fragmented solutions. inspired Ball et al. (2009) Beyer et al. (2016). penalty argument equivalent boundary length modifier (BLM) used Marxan. Note function can used represent symmetric relationships planning units. asymmetric relationships required, use add_connectivity_penalties() function.","code":""},{"path":"https://prioritizr.net/reference/add_boundary_penalties.html","id":"data-format","dir":"Reference","previous_headings":"","what":"Data format","title":"Add boundary penalties — add_boundary_penalties","text":"argument data can specified using following formats. Note boundary data must always describe symmetric relationships planning units. data NULL value indicating data automatically calculated using boundary_matrix() function. argument default. Note boundary data must supplied using one formats planning unit data argument x explicitly contain spatial information (e.g., planning unit data data.frame numeric class). data matrix/Matrix object rows columns represent different planning units value cell represents amount shared boundary length two different planning units. Cells occur along matrix diagonal denote total boundary length associated planning unit. data data.frame object columns \"id1\", \"id2\", \"boundary\". \"id1\" \"id2\" columns contain identifiers (indices) pair planning units, \"boundary\" column contains amount shared boundary length two planning units. Additionally, values \"id1\" \"id2\" columns contain values, value denotes amount exposed boundary length (total boundary). format follows standard Marxan format boundary data (.e., per \"bound.dat\" file).","code":""},{"path":"https://prioritizr.net/reference/add_boundary_penalties.html","id":"mathematical-formulation","dir":"Reference","previous_headings":"","what":"Mathematical formulation","title":"Add boundary penalties — add_boundary_penalties","text":"boundary penalties implemented using following equations. Let \\(\\) represent set planning units (indexed \\(\\) \\(j\\)), \\(Z\\) represent set management zones (indexed \\(z\\) \\(y\\)), \\(X_{iz}\\) represent decision variable planning unit \\(\\) zone \\(z\\) (e.g., binary values one indicating planning unit allocated ). Also, let \\(p\\) represent argument penalty, \\(E_z\\) represent argument edge_factor, \\(B_{ij}\\) represent matrix argument data (e.g., generated using boundary_matrix()), \\(W_{zz}\\) represent matrix argument zones. $$ \\sum_{}^{} \\sum_{z}^{Z} (p \\times W_{zz} B_{ii}) + \\sum_{}^{} \\sum_{j}^{} \\sum_{z}^{Z} \\sum_{y}^{Z} (-2 \\times p \\times X_{iz} \\times X_{jy} \\times W_{zy} \\times B_{ij})$$ Note problem objective maximize measure benefit minimize measure cost, term \\(p\\) replaced \\(-p\\).","code":""},{"path":"https://prioritizr.net/reference/add_boundary_penalties.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Add boundary penalties — add_boundary_penalties","text":"Ball IR, Possingham HP, Watts M (2009) Marxan relatives: Software spatial conservation prioritisation Spatial conservation prioritisation: Quantitative methods computational tools. Eds Moilanen , Wilson KA, Possingham HP. Oxford University Press, Oxford, UK. Beyer HL, Dujardin Y, Watts , Possingham HP (2016) Solving conservation planning problems integer linear programming. Ecological Modelling, 228: 14--22.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_boundary_penalties.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add boundary penalties — add_boundary_penalties","text":"","code":"# \\dontrun{ # set seed for reproducibility set.seed(500)  # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_features <- get_sim_zones_features()  # create minimal problem p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.2) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # create problem with low boundary penalties p2 <- p1 %>% add_boundary_penalties(50, 1)  # create problem with high boundary penalties but outer edges receive # half the penalty as inner edges p3 <- p1 %>% add_boundary_penalties(500, 0.5)  # create a problem using precomputed boundary data bmat <- boundary_matrix(sim_pu_raster) p4 <- p1 %>% add_boundary_penalties(50, 1, data = bmat)  # solve problems s1 <- c(solve(p1), solve(p2), solve(p3), solve(p4)) names(s1) <- c(\"basic solution\", \"small penalties\", \"high penalties\",   \"precomputed data\" )  # plot solutions plot(s1, axes = FALSE)   # create minimal problem with multiple zones and limit the run-time for # solver to 10 seconds so this example doesn't take too long p5 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_min_set_objective() %>%   add_relative_targets(matrix(0.2, nrow = 5, ncol = 3)) %>%   add_binary_decisions() %>%   add_default_solver(time_limit = 10, verbose = FALSE)  # create zone matrix which favors clumping planning units that are # allocated to the same zone together - note that this is the default zm6 <- diag(3) print(zm6) #>      [,1] [,2] [,3] #> [1,]    1    0    0 #> [2,]    0    1    0 #> [3,]    0    0    1  # create problem with the zone matrix and low penalties p6 <- p5 %>% add_boundary_penalties(50, zone = zm6)  # create another problem with the same zone matrix and higher penalties p7 <- p5 %>% add_boundary_penalties(500, zone = zm6)  # create zone matrix which favors clumping units that are allocated to # different zones together zm8 <- matrix(1, ncol = 3, nrow = 3) diag(zm8) <- 0 print(zm8) #>      [,1] [,2] [,3] #> [1,]    0    1    1 #> [2,]    1    0    1 #> [3,]    1    1    0  # create problem with the zone matrix p8 <- p5 %>% add_boundary_penalties(500, zone = zm8)  # create zone matrix which strongly favors clumping units # that are allocated to the same zone together. It will also prefer # clumping planning units in zones 1 and 2 together over having # these planning units with no neighbors in the solution zm9 <- diag(3) zm9[upper.tri(zm9)] <- c(0.3, 0, 0) zm9[lower.tri(zm9)] <- zm9[upper.tri(zm9)] print(zm9) #>      [,1] [,2] [,3] #> [1,]  1.0  0.3    0 #> [2,]  0.3  1.0    0 #> [3,]  0.0  0.0    1  # create problem with the zone matrix p9 <- p5 %>% add_boundary_penalties(500, zone = zm9)  # create zone matrix which favors clumping planning units in zones 1 and 2 # together, and favors planning units in zone 3 being spread out # (i.e., negative clumping) zm10 <- diag(3) zm10[3, 3] <- -1 print(zm10) #>      [,1] [,2] [,3] #> [1,]    1    0    0 #> [2,]    0    1    0 #> [3,]    0    0   -1  # create problem with the zone matrix p10 <- p5 %>% add_boundary_penalties(500, zone = zm10)  # solve problems s2 <- list(solve(p5), solve(p6), solve(p7), solve(p8), solve(p9), solve(p10))  #convert to category layers for visualization s2 <- terra::rast(lapply(s2, category_layer)) names(s2) <- c(   \"basic solution\", \"within zone clumping (low)\",   \"within zone clumping (high)\", \"between zone clumping\",   \"within + between clumping\", \"negative clumping\" )  # plot solutions plot(s2, axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_cbc_solver.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a CBC solver — add_cbc_solver","title":"Add a CBC solver — add_cbc_solver","text":"Specify CBC (COIN-branch cut) software used solve conservation planning problem (Forrest & Lougee-Heimer 2005). function can also used customize behavior solver. requires rcbc package installed (available GitHub, see installation instructions).","code":""},{"path":"https://prioritizr.net/reference/add_cbc_solver.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a CBC solver — add_cbc_solver","text":"","code":"add_cbc_solver(   x,   gap = 0.1,   time_limit = .Machine$integer.max,   presolve = TRUE,   threads = 1,   first_feasible = FALSE,   start_solution = NULL,   verbose = TRUE )"},{"path":"https://prioritizr.net/reference/add_cbc_solver.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a CBC solver — add_cbc_solver","text":"x problem() object. gap numeric gap optimality. gap relative expresses acceptable deviance optimal objective. example, value 0.01 result solver stopping found solution within 1% optimality. Additionally, value 0 result solver stopping found optimal solution. default value 0.1 (.e., 10% optimality). time_limit numeric time limit (seconds) generating solutions. solver return current best solution time limit exceeded. default value largest integer value (.e., .Machine$integer.max), effectively meaning solver keep running solution within optimality gap found. presolve logical attempt simplify problem solving ? Defaults TRUE. threads integer number threads use optimization algorithm. default value 1. first_feasible logical first feasible solution returned? first_feasible set TRUE, solver return first solution encounters meets constraints, regardless solution quality. Note first feasible solution arbitrary solution, rather derived relaxed solution, therefore often reasonably close optimality. Defaults FALSE. start_solution NULL object containing starting solution solver. can useful specifying starting solution can speed optimization process. Defaults NULL starting solution used. specify starting solution, argument start_solution format planning units (.e., NULL, numeric, matrix, data.frame, terra::rast(), sf::sf() object). See Start solution format section information. verbose logical information printed solving optimization problems? Defaults TRUE.","code":""},{"path":"https://prioritizr.net/reference/add_cbc_solver.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a CBC solver — add_cbc_solver","text":"updated problem() object solver added .","code":""},{"path":"https://prioritizr.net/reference/add_cbc_solver.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add a CBC solver — add_cbc_solver","text":"CBC open-source mixed integer programming solver part Computational Infrastructure Operations Research (COIN-) project. solver seems much better performance open-source solvers (.e., add_highs_solver(), add_rsymphony_solver(), add_lpsymphony_solver()) (see Solver benchmarks vignette details). , strongly recommended use solver Gurobi IBM CPLEX solvers available.","code":""},{"path":"https://prioritizr.net/reference/add_cbc_solver.html","id":"installation","dir":"Reference","previous_headings":"","what":"Installation","title":"Add a CBC solver — add_cbc_solver","text":"rcbc package required use solver. Since rcbc package available Comprehensive R Archive Network (CRAN), must installed GitHub repository. install rcbc package, please use following code:   Note may also need install several dependencies -- Rtools software system libraries -- prior installing rcbc package. details installing package, please consult online package documentation.","code":"if (!require(remotes)) install.packages(\"remotes\") remotes::install_github(\"dirkschumacher/rcbc\")"},{"path":"https://prioritizr.net/reference/add_cbc_solver.html","id":"start-solution-format","dir":"Reference","previous_headings":"","what":"Start solution format","title":"Add a CBC solver — add_cbc_solver","text":"Broadly speaking, argument start_solution must format planning unit data argument x. details correct format listed separately different planning unit data formats: x numeric planning units argument start_solution must numeric vector element corresponding different planning unit. number planning units argument x. Additionally, planning units missing cost (NA) values also missing (NA) values argument start_solution. x matrix planning units argument start_solution must matrix vector row corresponding different planning unit, column correspond different management zone. number planning units zones argument x. Additionally, planning units missing cost (NA) values particular zone also missing (NA) values argument start_solution. x terra::rast() planning units argument start_solution terra::rast() object different grid cells (pixels) correspond different planning units layers correspond different management zones. dimensionality (rows, columns, layers), resolution, extent, coordinate reference system planning units argument x. Additionally, planning units missing cost (NA) values particular zone also missing (NA)  values argument start_solution. x data.frame planning units argument start_solution must data.frame column corresponding different zone, row corresponding different planning unit, cell values corresponding solution value. means data.frame object containing solution also contains additional columns, columns need subsetted prior using function (see example sf::sf() data). Additionally, planning units missing cost (NA) values particular zone also missing (NA) values argument start_solution. x sf::sf() planning units argument start_solution must sf::sf() object column corresponding different zone, row corresponding different planning unit, cell values corresponding solution value. means sf::sf() object containing solution also contains additional columns, columns need subsetted prior using function (see example). Additionally, argument start_solution must also coordinate reference system planning unit data. Furthermore, planning units missing cost (NA) values particular zone also missing (NA) values argument start_solution.","code":""},{"path":"https://prioritizr.net/reference/add_cbc_solver.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Add a CBC solver — add_cbc_solver","text":"Forrest J Lougee-Heimer R (2005) CBC User Guide. Emerging theory, Methods, Applications (pp. 257--277). INFORMS, Catonsville, MD. doi:10.1287/educ.1053.0020 .","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_cbc_solver.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add a CBC solver — add_cbc_solver","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features()  # create problem p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_cbc_solver(gap = 0, verbose = FALSE)  # generate solution %>% s1 <- solve(p1)  # plot solution plot(s1, main = \"solution\", axes = FALSE)   # create a similar problem with boundary length penalties and # specify the solution from the previous run as a starting solution p2 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_boundary_penalties(10) %>%   add_binary_decisions() %>%   add_cbc_solver(gap = 0, start_solution = s1, verbose = FALSE)  # generate solution s2 <- solve(p2)  # plot solution plot(s2, main = \"solution with boundary penalties\", axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_connectivity_penalties.html","id":null,"dir":"Reference","previous_headings":"","what":"Add connectivity penalties — add_connectivity_penalties","title":"Add connectivity penalties — add_connectivity_penalties","text":"Add penalties conservation planning problem account symmetric connectivity planning units. Symmetric connectivity data describe connectivity information directional. example, symmetric connectivity data describe planning units adjacent (see adjacency_matrix()), planning units within threshold distance (see proximity_matrix()).","code":""},{"path":"https://prioritizr.net/reference/add_connectivity_penalties.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add connectivity penalties — add_connectivity_penalties","text":"","code":"# S4 method for ConservationProblem,ANY,ANY,matrix add_connectivity_penalties(x, penalty, zones, data)  # S4 method for ConservationProblem,ANY,ANY,Matrix add_connectivity_penalties(x, penalty, zones, data)  # S4 method for ConservationProblem,ANY,ANY,data.frame add_connectivity_penalties(x, penalty, zones, data)  # S4 method for ConservationProblem,ANY,ANY,dgCMatrix add_connectivity_penalties(x, penalty, zones, data)  # S4 method for ConservationProblem,ANY,ANY,array add_connectivity_penalties(x, penalty, zones, data)"},{"path":"https://prioritizr.net/reference/add_connectivity_penalties.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add connectivity penalties — add_connectivity_penalties","text":"x problem() object. penalty numeric penalty used scale importance selecting planning units strong connectivity compared main problem objective (e.g., solution cost argument x minimum set objective set using add_min_set_objective()). Higher penalty values can used obtain solutions high degree connectivity, smaller penalty values can used obtain solutions small degree connectivity. Note negative penalty values can used obtain solutions little connectivity. zones matrix Matrix object describing level connectivity different zones. row column corresponds different zone argument x, cell values indicate level connectivity combination zones. Cell values along diagonal matrix represent level connectivity planning units allocated zone. Cell values must lay 1 -1, negative values favor solutions weak connectivity. default argument zones identity matrix (.e., matrix ones along matrix diagonal zeros elsewhere), planning units considered connected allocated zone. argument required working multiple zones argument data matrix Matrix object. argument data array data.frame data multiple zones (e.g., using \"zone1\" \"zone2\" column names), argument must explicitly set NULL otherwise error thrown. data matrix, Matrix, data.frame, array object containing connectivity data. connectivity values correspond strength connectivity different planning units. Thus connections planning units associated higher values favorable solution. See Data format section information.","code":""},{"path":"https://prioritizr.net/reference/add_connectivity_penalties.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add connectivity penalties — add_connectivity_penalties","text":"updated problem() object penalties added .","code":""},{"path":"https://prioritizr.net/reference/add_connectivity_penalties.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add connectivity penalties — add_connectivity_penalties","text":"function adds penalties conservation planning problem penalize solutions low connectivity. Specifically, favors pair-wise connections planning units high connectivity values (based Önal Briers 2002).","code":""},{"path":"https://prioritizr.net/reference/add_connectivity_penalties.html","id":"data-format","dir":"Reference","previous_headings":"","what":"Data format","title":"Add connectivity penalties — add_connectivity_penalties","text":"argument data can specified using several different formats. data matrix/Matrix object rows columns represent different planning units value cell represents strength connectivity two different planning units. Cells occur along matrix diagonal treated weights indicate planning units desirable solution. argument zones can used control strength connectivity planning units different zones. default argument zones treat planning units allocated different zones zero connectivity. data data.frame object containing columns named \"id1\", \"id2\", \"boundary\". , row denotes connectivity pair planning units (per values \"id1\" \"id2\" columns) following Marxan format. argument x contains multiple zones, \"zone1\" \"zone2\" columns can optionally provided manually specify connectivity values planning units allocated specific zones. \"zone1\" \"zone2\" columns present, argument zones must NULL. data array object containing four-dimensions cell values indicate strength connectivity planning units assigned specific management zones. first two dimensions (.e., rows columns) indicate strength connectivity different planning units second two dimensions indicate different management zones. Thus data[1, 2, 3, 4] indicates strength connectivity planning unit 1 planning unit 2 planning unit 1 assigned zone 3 planning unit 2 assigned zone 4.","code":""},{"path":"https://prioritizr.net/reference/add_connectivity_penalties.html","id":"mathematical-formulation","dir":"Reference","previous_headings":"","what":"Mathematical formulation","title":"Add connectivity penalties — add_connectivity_penalties","text":"connectivity penalties implemented using following equations. Let \\(\\) represent set planning units (indexed \\(\\) \\(j\\)), \\(Z\\) represent set management zones (indexed \\(z\\) \\(y\\)), \\(X_{iz}\\) represent decision variable planning unit \\(\\) zone \\(z\\) (e.g., binary values one indicating planning unit allocated ). Also, let \\(p\\) represent argument penalty, \\(D\\) represent argument data, \\(W\\) represent argument zones. argument data supplied matrix Matrix object, penalties calculated : $$ \\sum_{}^{} \\sum_{j}^{} \\sum_{z}^{Z} \\sum_{y}^{Z} (-p \\times X_{iz} \\times X_{jy} \\times D_{ij} \\times W_{zy})$$ Otherwise, argument data supplied data.frame array object, penalties calculated : $$ \\sum_{}^{} \\sum_{j}^{} \\sum_{z}^{Z} \\sum_{y}^{Z} (-p \\times X_{iz} \\times X_{jy} \\times D_{ijzy})$$ Note problem objective maximize measure benefit minimize measure cost, term \\(-p\\) replaced \\(p\\).","code":""},{"path":"https://prioritizr.net/reference/add_connectivity_penalties.html","id":"notes","dir":"Reference","previous_headings":"","what":"Notes","title":"Add connectivity penalties — add_connectivity_penalties","text":"previous versions, function aimed handle symmetric asymmetric connectivity data. meant mathematical formulation used account asymmetric connectivity different implemented Marxan software (see Beger et al. details). ensure asymmetric connectivity handled similar manner Marxan software, add_asym_connectivity_penalties() function now used asymmetric connectivity data.","code":""},{"path":"https://prioritizr.net/reference/add_connectivity_penalties.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Add connectivity penalties — add_connectivity_penalties","text":"Beger M, Linke S, Watts M, Game E, Treml E, Ball , Possingham, HP (2010) Incorporating asymmetric connectivity spatial decision making conservation, Conservation Letters, 3: 359--368. Önal H, Briers RA (2002) Incorporating spatial criteria optimum reserve network selection. Proceedings Royal Society London. Series B: Biological Sciences, 269: 2437--2441.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_connectivity_penalties.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add connectivity penalties — add_connectivity_penalties","text":"","code":"# \\dontrun{ # load package library(Matrix)  # set seed for reproducibility set.seed(600)  # load data sim_pu_polygons <- get_sim_pu_polygons() sim_features <- get_sim_features() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_features <- get_sim_zones_features()  # create basic problem p1 <-   problem(sim_pu_polygons, sim_features, \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.2) %>%   add_default_solver(verbose = FALSE)  # create a symmetric connectivity matrix where the connectivity between # two planning units corresponds to their shared boundary length b_matrix <- boundary_matrix(sim_pu_polygons)  # rescale matrix values to have a maximum value of 1 b_matrix <- rescale_matrix(b_matrix, max = 1)  # visualize connectivity matrix image(b_matrix)   # create a symmetric connectivity matrix where the connectivity between # two planning units corresponds to their spatial proximity # i.e., planning units that are further apart share less connectivity centroids <- sf::st_coordinates(   suppressWarnings(sf::st_centroid(sim_pu_polygons)) ) d_matrix <- (1 / (Matrix::Matrix(as.matrix(dist(centroids))) + 1))  # rescale matrix values to have a maximum value of 1 d_matrix <- rescale_matrix(d_matrix, max = 1)  # remove connections between planning units with values below a threshold to # reduce run-time d_matrix[d_matrix < 0.8] <- 0  # visualize connectivity matrix image(d_matrix)   # create a symmetric connectivity matrix where the connectivity # between adjacent two planning units corresponds to their combined # value in a column of the planning unit data  # for example, this column could describe the extent of native vegetation in # each planning unit and we could use connectivity penalties to identify # solutions that cluster planning units together that both contain large # amounts of native vegetation  c_matrix <- connectivity_matrix(sim_pu_polygons, \"cost\")  # rescale matrix values to have a maximum value of 1 c_matrix <- rescale_matrix(c_matrix, max = 1)  # visualize connectivity matrix image(c_matrix)   # create penalties penalties <- c(10, 25)  # create problems using the different connectivity matrices and penalties p2 <- list(   p1,   p1 %>% add_connectivity_penalties(penalties[1], data = b_matrix),   p1 %>% add_connectivity_penalties(penalties[2], data = b_matrix),   p1 %>% add_connectivity_penalties(penalties[1], data = d_matrix),   p1 %>% add_connectivity_penalties(penalties[2], data = d_matrix),   p1 %>% add_connectivity_penalties(penalties[1], data = c_matrix),   p1 %>% add_connectivity_penalties(penalties[2], data = c_matrix) )  # solve problems s2 <- lapply(p2, solve)  # create single object with all solutions s2 <- sf::st_sf(   tibble::tibble(     p2_1 = s2[[1]]$solution_1,     p2_2 = s2[[2]]$solution_1,     p2_3 = s2[[3]]$solution_1,     p2_4 = s2[[4]]$solution_1,     p2_5 = s2[[5]]$solution_1,     p2_6 = s2[[6]]$solution_1,     p2_7 = s2[[7]]$solution_1   ),   geometry = sf::st_geometry(s2[[1]]) )  names(s2)[1:7] <- c(   \"basic problem\",   paste0(\"b_matrix (\", penalties,\")\"),   paste0(\"d_matrix (\", penalties,\")\"),   paste0(\"c_matrix (\", penalties,\")\") )  # plot solutions plot(s2)   # create minimal multi-zone problem and limit solver to one minute # to obtain solutions in a short period of time p3 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_min_set_objective() %>%   add_relative_targets(matrix(0.15, nrow = 5, ncol = 3)) %>%   add_binary_decisions() %>%   add_default_solver(time_limit = 60, verbose = FALSE)  # create matrix showing which planning units are adjacent to other units a_matrix <- adjacency_matrix(sim_zones_pu_raster)  # visualize matrix image(a_matrix)   # create a zone matrix where connectivities are only present between # planning units that are allocated to the same zone zm1 <- as(diag(3), \"Matrix\")  # print zone matrix print(zm1) #>      [,1] [,2] [,3] #> [1,]    1    .    . #> [2,]    .    1    . #> [3,]    .    .    1  # create a zone matrix where connectivities are strongest between # planning units allocated to different zones zm2 <- matrix(1, ncol = 3, nrow = 3) diag(zm2) <- 0 zm2 <- as(zm2, \"Matrix\")  # print zone matrix print(zm2) #> 3 x 3 Matrix of class \"dsyMatrix\" #>      [,1] [,2] [,3] #> [1,]    0    1    1 #> [2,]    1    0    1 #> [3,]    1    1    0  # create a zone matrix that indicates that connectivities between planning # units assigned to the same zone are much higher than connectivities # assigned to different zones zm3 <- matrix(0.1, ncol = 3, nrow = 3) diag(zm3) <- 1 zm3 <- as(zm3, \"Matrix\")  # print zone matrix print(zm3) #> 3 x 3 Matrix of class \"dsyMatrix\" #>      [,1] [,2] [,3] #> [1,]  1.0  0.1  0.1 #> [2,]  0.1  1.0  0.1 #> [3,]  0.1  0.1  1.0  # create a zone matrix that indicates that connectivities between planning # units allocated to zone 1 are very high, connectivities between planning # units allocated to zones 1 and 2 are moderately high, and connectivities # planning units allocated to other zones are low zm4 <- matrix(0.1, ncol = 3, nrow = 3) zm4[1, 1] <- 1 zm4[1, 2] <- 0.5 zm4[2, 1] <- 0.5 zm4 <- as(zm4, \"Matrix\")  # print zone matrix print(zm4) #> 3 x 3 Matrix of class \"dsyMatrix\" #>      [,1] [,2] [,3] #> [1,]  1.0  0.5  0.1 #> [2,]  0.5  0.1  0.1 #> [3,]  0.1  0.1  0.1  # create a zone matrix with strong connectivities between planning units # allocated to the same zone, moderate connectivities between planning # unit allocated to zone 1 and zone 2, and negative connectivities between # planning units allocated to zone 3 and the other two zones zm5 <- matrix(-1, ncol = 3, nrow = 3) zm5[1, 2] <- 0.5 zm5[2, 1] <- 0.5 diag(zm5) <- 1 zm5 <- as(zm5, \"Matrix\")  # print zone matrix print(zm5) #> 3 x 3 Matrix of class \"dsyMatrix\" #>      [,1] [,2] [,3] #> [1,]  1.0  0.5   -1 #> [2,]  0.5  1.0   -1 #> [3,] -1.0 -1.0    1  # create vector of penalties to use creating problems penalties2 <- c(5, 15)  # create multi-zone problems using the adjacent connectivity matrix and # different zone matrices p4 <- list(   p3,   p3 %>% add_connectivity_penalties(penalties2[1], zm1, a_matrix),   p3 %>% add_connectivity_penalties(penalties2[2], zm1, a_matrix),   p3 %>% add_connectivity_penalties(penalties2[1], zm2, a_matrix),   p3 %>% add_connectivity_penalties(penalties2[2], zm2, a_matrix),   p3 %>% add_connectivity_penalties(penalties2[1], zm3, a_matrix),   p3 %>% add_connectivity_penalties(penalties2[2], zm3, a_matrix),   p3 %>% add_connectivity_penalties(penalties2[1], zm4, a_matrix),   p3 %>% add_connectivity_penalties(penalties2[2], zm4, a_matrix),   p3 %>% add_connectivity_penalties(penalties2[1], zm5, a_matrix),   p3 %>% add_connectivity_penalties(penalties2[2], zm5, a_matrix) )  # solve problems s4 <- lapply(p4, solve) s4 <- lapply(s4, category_layer) s4 <- terra::rast(s4) names(s4) <-  c(   \"basic problem\",   paste0(\"zm\", rep(seq_len(5), each = 2), \" (\", rep(penalties2, 2), \")\") )  # plot solutions plot(s4, axes = FALSE)   # create an array to manually specify the connectivities between # each planning unit when they are allocated to each different zone  # for real-world problems, these connectivities would be generated using # data - but here these connectivity values are assigned as random # ones or zeros c_array <- array(0, c(rep(ncell(sim_zones_pu_raster[[1]]), 2), 3, 3)) for (z1 in seq_len(3))   for (z2 in seq_len(3))     c_array[, , z1, z2] <- round(       runif(ncell(sim_zones_pu_raster[[1]]) ^ 2, 0, 0.505)     )  # create a problem with the manually specified connectivity array # note that the zones argument is set to NULL because the connectivity # data is an array p5 <- list(   p3,   p3 %>% add_connectivity_penalties(15, zones = NULL, c_array) )  # solve problems s5 <- lapply(p5, solve) s5 <- lapply(s5, category_layer) s5 <- terra::rast(s5) names(s5) <- c(\"basic problem\", \"connectivity array\")  # plot solutions plot(s5, axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_contiguity_constraints.html","id":null,"dir":"Reference","previous_headings":"","what":"Add contiguity constraints — add_contiguity_constraints","title":"Add contiguity constraints — add_contiguity_constraints","text":"Add constraints conservation planning problem ensure selected planning units spatially connected form single contiguous unit.","code":""},{"path":"https://prioritizr.net/reference/add_contiguity_constraints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add contiguity constraints — add_contiguity_constraints","text":"","code":"# S4 method for ConservationProblem,ANY,ANY add_contiguity_constraints(x, zones, data)  # S4 method for ConservationProblem,ANY,data.frame add_contiguity_constraints(x, zones, data)  # S4 method for ConservationProblem,ANY,matrix add_contiguity_constraints(x, zones, data)"},{"path":"https://prioritizr.net/reference/add_contiguity_constraints.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add contiguity constraints — add_contiguity_constraints","text":"x problem() object. zones matrix Matrix object describing connection scheme different zones. row column corresponds different zone argument x, cell values must contain binary numeric values (.e., one zero) indicate connected planning units (specified argument data) still considered connected allocated different zones. cell values along diagonal matrix indicate planning units subject contiguity constraints allocated given zone. Note arguments zones must symmetric, row column value one diagonal element row column must also value one. default argument zones identity matrix (.e., matrix ones along matrix diagonal zeros elsewhere), planning units considered connected allocated zone. data NULL, matrix, Matrix, data.frame object showing planning units connected . argument defaults NULL means connection data calculated automatically using adjacency_matrix() function. See Data format section information.","code":""},{"path":"https://prioritizr.net/reference/add_contiguity_constraints.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add contiguity constraints — add_contiguity_constraints","text":"updated problem() object constraints added .","code":""},{"path":"https://prioritizr.net/reference/add_contiguity_constraints.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add contiguity constraints — add_contiguity_constraints","text":"function uses connection data identify solutions form single contiguous unit. inspired mathematical formulations detailed Önal Briers (2006).","code":""},{"path":"https://prioritizr.net/reference/add_contiguity_constraints.html","id":"data-format","dir":"Reference","previous_headings":"","what":"Data format","title":"Add contiguity constraints — add_contiguity_constraints","text":"argument data can specified using following formats. data NULL value indicating connection data calculated automatically using adjacency_matrix() function. default argument. Note connection data must manually defined using one formats planning unit data argument x spatially referenced (e.g., data.frame numeric format). data matrix/Matrix object rows columns represent different planning units value cell indicates two planning units connected . Cell values binary numeric values (.e., one zero). Cells occur along matrix diagonal effect solution planning unit connected . data data.frame object containing columns named \"id1\", \"id2\", \"boundary\". , row denotes connectivity two planning units following Marxan format. \"boundary\" column contain binary numeric values indicate two planning units specified \"id1\" \"id2\" columns connected . data can used describe symmetric asymmetric relationships planning units. default, input data assumed symmetric unless asymmetric data also included (e.g., data present planning units 2 3, amount connectivity expected planning units 3 2, unless connectivity data also provided planning units 3 2).","code":""},{"path":"https://prioritizr.net/reference/add_contiguity_constraints.html","id":"notes","dir":"Reference","previous_headings":"","what":"Notes","title":"Add contiguity constraints — add_contiguity_constraints","text":"early versions, function named add_connected_constraints() function.","code":""},{"path":"https://prioritizr.net/reference/add_contiguity_constraints.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Add contiguity constraints — add_contiguity_constraints","text":"Önal H Briers RA (2006) Optimal selection connected reserve network. Operations Research, 54: 379--388.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_contiguity_constraints.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add contiguity constraints — add_contiguity_constraints","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_features <- get_sim_zones_features()  # create minimal problem p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.2) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # create problem with added connected constraints p2 <- p1 %>% add_contiguity_constraints()  # solve problems s1 <- c(solve(p1), solve(p2)) names(s1) <- c(\"basic solution\", \"connected solution\")  # plot solutions plot(s1, axes = FALSE)   # create minimal problem with multiple zones, and limit the solver to # 30 seconds to obtain solutions in a feasible period of time p3 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_min_set_objective() %>%   add_relative_targets(matrix(0.2, ncol = 3, nrow = 5)) %>%   add_binary_decisions() %>%   add_default_solver(time_limit = 30, verbose = FALSE)  # create problem with added constraints to ensure that the planning units # allocated to each zone form a separate contiguous unit z4 <- diag(3) print(z4) #>      [,1] [,2] [,3] #> [1,]    1    0    0 #> [2,]    0    1    0 #> [3,]    0    0    1 p4 <- p3 %>% add_contiguity_constraints(z4)  # create problem with added constraints to ensure that the planning # units allocated to each zone form a separate contiguous unit, # except for planning units allocated to zone 3 which do not need # form a single contiguous unit z5 <- diag(3) z5[3, 3] <- 0 print(z5) #>      [,1] [,2] [,3] #> [1,]    1    0    0 #> [2,]    0    1    0 #> [3,]    0    0    0 p5 <- p3 %>% add_contiguity_constraints(z5)  # create problem with added constraints that ensure that the planning # units allocated to zones 1 and 2 form a contiguous unit z6 <- diag(3) z6[1, 2] <- 1 z6[2, 1] <- 1 print(z6) #>      [,1] [,2] [,3] #> [1,]    1    1    0 #> [2,]    1    1    0 #> [3,]    0    0    1 p6 <- p3 %>% add_contiguity_constraints(z6)  # solve problems s2 <- lapply(list(p3, p4, p5, p6), solve) s2 <- lapply(s2, category_layer) s2 <- terra::rast(s2) names(s2) <- c(\"basic solution\", \"p4\", \"p5\", \"p6\")  # plot solutions plot(s2, axes = FALSE)   # create a problem that has a main \"reserve zone\" and a secondary # \"corridor zone\" to connect up import areas. Here, each feature has a # target of 50% of its distribution. If a planning unit is allocated to the # \"reserve zone\", then the prioritization accrues 100% of the amount of # each feature in the planning unit. If a planning unit is allocated to the # \"corridor zone\" then the prioritization accrues 40% of the amount of each # feature in the planning unit. Also, the cost of managing a planning unit # in the \"corridor zone\" is 30% of that when it is managed as the # \"reserve zone\". Finally, the problem has constraints which # ensure that all of the selected planning units form a single contiguous # unit, so that the planning units allocated to the \"corridor zone\" can # link up the planning units allocated to the \"reserve zone\"  # create planning unit data pus <- sim_zones_pu_raster[[c(1, 1)]] pus[[2]] <- pus[[2]] * 0.3 print(pus) #> class       : SpatRaster  #> dimensions  : 10, 10, 2  (nrow, ncol, nlyr) #> resolution  : 0.1, 0.1  (x, y) #> extent      : 0, 1, 0, 1  (xmin, xmax, ymin, ymax) #> coord. ref. : Undefined Cartesian SRS  #> sources     : sim_zones_pu_raster.tif   #>               memory   #> names       :   zone_1,   zone_1  #> min values  : 190.1328, 57.03983  #> max values  : 215.8638, 64.75915   # create biodiversity data fts <- zones(   sim_features, sim_features * 0.4,   feature_names = names(sim_features),   zone_names = c(\"reserve zone\", \"corridor zone\") ) print(fts) #> A zones object <ZonesSpatRaster/Zones> #> • zones:    \"reserve zone\" and \"corridor zone\" (2 total) #> • features: \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total)  # create targets targets <- tibble::tibble(   feature = names(sim_features),   zone = list(zone_names(fts))[rep(1, 5)],   target = terra::global(sim_features, \"sum\", na.rm = TRUE)[[1]] * 0.5,   type = rep(\"absolute\", 5) ) print(targets) #> # A tibble: 5 × 4 #>   feature   zone      target type     #>   <chr>     <list>     <dbl> <chr>    #> 1 feature_1 <chr [2]>   41.6 absolute #> 2 feature_2 <chr [2]>   15.6 absolute #> 3 feature_3 <chr [2]>   36.0 absolute #> 4 feature_4 <chr [2]>   21.3 absolute #> 5 feature_5 <chr [2]>   28.4 absolute  # create zones matrix z7 <- matrix(1, ncol = 2, nrow = 2) print(z7) #>      [,1] [,2] #> [1,]    1    1 #> [2,]    1    1  # create problem p7 <-   problem(pus, fts) %>%   add_min_set_objective() %>%   add_manual_targets(targets) %>%   add_contiguity_constraints(z7) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problems s7 <- category_layer(solve(p7))  # plot solutions plot(s7, main = \"solution\", axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_cplex_solver.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a CPLEX solver — add_cplex_solver","title":"Add a CPLEX solver — add_cplex_solver","text":"Specify IBM CPLEX software used solve conservation planning problem (IBM 2017) . function can also used customize behavior solver. requires cplexAPI package installed (see installation instructions).","code":""},{"path":"https://prioritizr.net/reference/add_cplex_solver.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a CPLEX solver — add_cplex_solver","text":"","code":"add_cplex_solver(   x,   gap = 0.1,   time_limit = .Machine$integer.max,   presolve = TRUE,   threads = 1,   verbose = TRUE )"},{"path":"https://prioritizr.net/reference/add_cplex_solver.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a CPLEX solver — add_cplex_solver","text":"x problem() object. gap numeric gap optimality. gap relative expresses acceptable deviance optimal objective. example, value 0.01 result solver stopping found solution within 1% optimality. Additionally, value 0 result solver stopping found optimal solution. default value 0.1 (.e., 10% optimality). time_limit numeric time limit (seconds) generating solutions. solver return current best solution time limit exceeded. default value largest integer value (.e., .Machine$integer.max), effectively meaning solver keep running solution within optimality gap found. presolve logical attempt simplify problem solving ? Defaults TRUE. threads integer number threads use optimization algorithm. default value 1. verbose logical information printed solving optimization problems? Defaults TRUE.","code":""},{"path":"https://prioritizr.net/reference/add_cplex_solver.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a CPLEX solver — add_cplex_solver","text":"updated problem() object solver added .","code":""},{"path":"https://prioritizr.net/reference/add_cplex_solver.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add a CPLEX solver — add_cplex_solver","text":"IBM CPLEX commercial optimization software. faster available open source solvers (e.g., add_lpsymphony_solver() add_rsymphony_solver(). Although formal benchmarks examining performance solver conservation planning problems yet completed, preliminary analyses suggest performs slightly slower Gurobi solver (.e., add_gurobi_solver()). recommend using solver Gurobi solver available. Licenses available IBM CPLEX software academics cost (see <  https://www.ibm.com/products/ilog-cplex-optimization-studio/cplex-optimizer>).","code":""},{"path":"https://prioritizr.net/reference/add_cplex_solver.html","id":"installation","dir":"Reference","previous_headings":"","what":"Installation","title":"Add a CPLEX solver — add_cplex_solver","text":"cplexAPI package used interface IBM CPLEX software. install package, IBM CPLEX software must installed (see https://www.ibm.com/products/ilog-cplex-optimization-studio/cplex-optimizer). Next, CPLEX_BIN environmental variable must set specify file path IBM CPLEX software. example, Linux system, variable can specified adding following text ~/.bashrc file:   Please Note may need change version number file path (.e., \"CPLEX_Studio128\"). specifying CPLEX_BIN environmental variable, cplexAPI package can installed. Since cplexAPI package available Comprehensive R Archive Network (CRAN), must installed GitHub repository. install cplexAPI package, please use following code:   details installing package, please consult installation instructions.","code":"export CPLEX_BIN=\"/opt/ibm/ILOG/CPLEX_Studio128/cplex/bin/x86-64_linux/cplex\" if (!require(remotes)) install.packages(\"remotes\") remotes::install_github(\"cran/cplexAPI\")"},{"path":"https://prioritizr.net/reference/add_cplex_solver.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Add a CPLEX solver — add_cplex_solver","text":"IBM (2017) IBM ILOG CPLEX Optimization Studio CPLEX User's Manual. Version 12 Release 8. IBM ILOG CPLEX Division, Incline Village, NV.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_cplex_solver.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add a CPLEX solver — add_cplex_solver","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features()  # create problem p <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_cplex_solver(gap = 0.1, time_limit = 5, verbose = FALSE)  # generate solution s <- solve(p)  # plot solution plot(s, main = \"solution\", axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_cuts_portfolio.html","id":null,"dir":"Reference","previous_headings":"","what":"Add Bender's cuts portfolio — add_cuts_portfolio","title":"Add Bender's cuts portfolio — add_cuts_portfolio","text":"Generate portfolio solutions conservation planning problem using Bender's cuts (discussed Rodrigues et al. 2000). recommended replacement add_gap_portfolio() Gurobi software available.","code":""},{"path":"https://prioritizr.net/reference/add_cuts_portfolio.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add Bender's cuts portfolio — add_cuts_portfolio","text":"","code":"add_cuts_portfolio(x, number_solutions = 10)"},{"path":"https://prioritizr.net/reference/add_cuts_portfolio.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add Bender's cuts portfolio — add_cuts_portfolio","text":"x problem() object. number_solutions integer number attempts generate different solutions. Defaults 10.","code":""},{"path":"https://prioritizr.net/reference/add_cuts_portfolio.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add Bender's cuts portfolio — add_cuts_portfolio","text":"updated problem() object portfolio added .","code":""},{"path":"https://prioritizr.net/reference/add_cuts_portfolio.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add Bender's cuts portfolio — add_cuts_portfolio","text":"strategy generating portfolio solutions involves solving problem multiple times adding additional constraints forbid previously obtained solutions. general, strategy useful problems take long time solve benefit multiple threads allocated solving individual problem.","code":""},{"path":"https://prioritizr.net/reference/add_cuts_portfolio.html","id":"notes","dir":"Reference","previous_headings":"","what":"Notes","title":"Add Bender's cuts portfolio — add_cuts_portfolio","text":"early versions (< 4.0.1), function compatible Gurobi (.e., add_gurobi_solver()). provide functionality exact algorithm solvers, function now adds constraints problem formulation generate multiple solutions.","code":""},{"path":"https://prioritizr.net/reference/add_cuts_portfolio.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Add Bender's cuts portfolio — add_cuts_portfolio","text":"Rodrigues , Cerdeira OJ, Gaston KJ (2000) Flexibility, efficiency, accountability: adapting reserve selection algorithms complex conservation problems. Ecography, 23: 565--574.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_cuts_portfolio.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add Bender's cuts portfolio — add_cuts_portfolio","text":"","code":"# \\dontrun{ # set seed for reproducibility set.seed(500)  # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_features <- get_sim_zones_features()  # create minimal problem with cuts portfolio p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.2) %>%   add_cuts_portfolio(10) %>%   add_default_solver(gap = 0.2, verbose = FALSE)  # solve problem and generate 10 solutions within 20% of optimality s1 <- solve(p1)  # convert portfolio into a multi-layer raster object s1 <- terra::rast(s1)  # plot solutions in portfolio plot(s1, axes = FALSE)   # build multi-zone conservation problem with cuts portfolio p2 <-  problem(sim_zones_pu_raster, sim_zones_features) %>%  add_min_set_objective() %>%  add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %>%  add_binary_decisions() %>%  add_cuts_portfolio(10) %>%  add_default_solver(gap = 0.2, verbose = FALSE)  # solve the problem s2 <- solve(p2)  # print solution str(s2, max.level = 1) #> List of 10 #>  $ solution_1 :S4 class 'SpatRaster' [package \"terra\"] #>  $ solution_2 :S4 class 'SpatRaster' [package \"terra\"] #>  $ solution_3 :S4 class 'SpatRaster' [package \"terra\"] #>  $ solution_4 :S4 class 'SpatRaster' [package \"terra\"] #>  $ solution_5 :S4 class 'SpatRaster' [package \"terra\"] #>  $ solution_6 :S4 class 'SpatRaster' [package \"terra\"] #>  $ solution_7 :S4 class 'SpatRaster' [package \"terra\"] #>  $ solution_8 :S4 class 'SpatRaster' [package \"terra\"] #>  $ solution_9 :S4 class 'SpatRaster' [package \"terra\"] #>  $ solution_10:S4 class 'SpatRaster' [package \"terra\"] #>  - attr(*, \"objective\")= Named num [1:10] 11601 11815 11790 11820 11618 ... #>   ..- attr(*, \"names\")= chr [1:10] \"solution_1\" \"solution_2\" \"solution_3\" \"solution_4\" ... #>  - attr(*, \"status\")= Named chr [1:10] \"OPTIMAL\" \"OPTIMAL\" \"OPTIMAL\" \"OPTIMAL\" ... #>   ..- attr(*, \"names\")= chr [1:10] \"solution_1\" \"solution_2\" \"solution_3\" \"solution_4\" ... #>  - attr(*, \"runtime\")= Named num [1:10] 0.025 0.006 0.007 0.007 0.006 ... #>   ..- attr(*, \"names\")= chr [1:10] \"solution_1\" \"solution_2\" \"solution_3\" \"solution_4\" ...  # convert each solution in the portfolio into a single category layer s2 <- terra::rast(lapply(s2, category_layer))  # plot solutions in portfolio plot(s2, main = \"solution\", axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_default_solver.html","id":null,"dir":"Reference","previous_headings":"","what":"Add default solver — add_default_solver","title":"Add default solver — add_default_solver","text":"Specify best solver currently available used solve conservation planning problem.","code":""},{"path":"https://prioritizr.net/reference/add_default_solver.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add default solver — add_default_solver","text":"","code":"add_default_solver(x, ...)"},{"path":"https://prioritizr.net/reference/add_default_solver.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add default solver — add_default_solver","text":"x problem() object. ... arguments passed solver.","code":""},{"path":"https://prioritizr.net/reference/add_default_solver.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add default solver — add_default_solver","text":"updated problem() object solver added .","code":""},{"path":"https://prioritizr.net/reference/add_default_solver.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add default solver — add_default_solver","text":"Ranked best worst, available solvers can used : add_gurobi_solver(), add_cplex_solver(), add_cbc_solver(), add_highs_solver(), add_lpsymphony_solver(), finally add_rsymphony_solver(). information performance different solvers, please see Schuster et al. (2020).","code":""},{"path":"https://prioritizr.net/reference/add_default_solver.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Add default solver — add_default_solver","text":"Schuster R, Hanson JO, Strimas-Mackey M, Bennett JR (2020). Exact integer linear programming solvers outperform simulated annealing solving conservation planning problems. PeerJ, 8: e9258.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_extra_portfolio.html","id":null,"dir":"Reference","previous_headings":"","what":"Add an extra portfolio — add_extra_portfolio","title":"Add an extra portfolio — add_extra_portfolio","text":"Generate portfolio solutions conservation planning problem storing feasible solutions discovered optimization process. method useful quickly obtaining multiple solutions, provide guarantees number solutions, quality solutions.","code":""},{"path":"https://prioritizr.net/reference/add_extra_portfolio.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add an extra portfolio — add_extra_portfolio","text":"","code":"add_extra_portfolio(x)"},{"path":"https://prioritizr.net/reference/add_extra_portfolio.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add an extra portfolio — add_extra_portfolio","text":"x problem() object.","code":""},{"path":"https://prioritizr.net/reference/add_extra_portfolio.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add an extra portfolio — add_extra_portfolio","text":"updated problem() object portfolio added .","code":""},{"path":"https://prioritizr.net/reference/add_extra_portfolio.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add an extra portfolio — add_extra_portfolio","text":"strategy generating portfolio requires problems solved using Gurobi software suite (.e., using add_gurobi_solver(). Specifically, version 8.0.0 (greater) gurobi package must installed.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_extra_portfolio.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add an extra portfolio — add_extra_portfolio","text":"","code":"# \\dontrun{ # set seed for reproducibility set.seed(600)  # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_features <- get_sim_zones_features()  # create minimal problem with a portfolio for extra solutions p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.05) %>%   add_extra_portfolio() %>%   add_default_solver(gap = 0, verbose = FALSE)  # solve problem and generate portfolio s1 <- solve(p1)  # convert portfolio into a multi-layer raster object s1 <- terra::rast(s1)  # print number of solutions found print(terra::nlyr(s1)) #> [1] 10  # plot solutions plot(s1, axes = FALSE)   # create multi-zone problem with a portfolio for extra solutions p2 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_min_set_objective() %>%   add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %>%   add_extra_portfolio() %>%   add_default_solver(gap = 0, verbose = FALSE)  # solve problem and generate portfolio s2 <- solve(p2)  # convert each solution in the portfolio into a single category layer s2 <- terra::rast(lapply(s2, category_layer))  # print number of solutions found print(terra::nlyr(s2)) #> [1] 10  # plot solutions in portfolio plot(s2, axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_feature_contiguity_constraints.html","id":null,"dir":"Reference","previous_headings":"","what":"Add feature contiguity constraints — add_feature_contiguity_constraints","title":"Add feature contiguity constraints — add_feature_contiguity_constraints","text":"Add constraints problem ensure feature represented contiguous unit dispersible habitat. constraints advanced version implemented add_contiguity_constraints() function, ensure feature represented contiguous unit entire solution form contiguous unit. Additionally, function can use data showing distribution dispersible habitat feature ensure features can disperse throughout areas designated conservation.","code":""},{"path":"https://prioritizr.net/reference/add_feature_contiguity_constraints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add feature contiguity constraints — add_feature_contiguity_constraints","text":"","code":"# S4 method for ConservationProblem,ANY,data.frame add_feature_contiguity_constraints(x, zones, data)  # S4 method for ConservationProblem,ANY,matrix add_feature_contiguity_constraints(x, zones, data)  # S4 method for ConservationProblem,ANY,ANY add_feature_contiguity_constraints(x, zones, data)"},{"path":"https://prioritizr.net/reference/add_feature_contiguity_constraints.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add feature contiguity constraints — add_feature_contiguity_constraints","text":"x problem() object. zones matrix, Matrix list object describing connection scheme different zones. matrix Matrix arguments, row column corresponds different zone argument x, cell values must contain binary numeric values (.e., one zero) indicate connected planning units (specified argument data) still considered connected allocated different zones. cell values along diagonal matrix indicate planning units subject contiguity constraints allocated given zone. Note arguments zones must symmetric, row column value one diagonal element row column must also value one. connection scheme different zones differ among features, argument zones list matrix Matrix objects shows specific scheme feature using conventions described . default argument zones identity matrix (.e., matrix ones along matrix diagonal zeros elsewhere), planning units considered connected allocated zone. data NULL, matrix, Matrix, data.frame list matrix, Matrix, data.frame objects. argument data shows planning units treated connected implementing constraints ensure features represented contiguous units. different features different dispersal capabilities, may desirable specify sets planning units treated connected features using list objects. default argument NULL means connection data calculated automatically using adjacency_matrix() function adjacent planning units treated connected features. See Data format section information.","code":""},{"path":"https://prioritizr.net/reference/add_feature_contiguity_constraints.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add feature contiguity constraints — add_feature_contiguity_constraints","text":"updated problem() object constraints added .","code":""},{"path":"https://prioritizr.net/reference/add_feature_contiguity_constraints.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add feature contiguity constraints — add_feature_contiguity_constraints","text":"function uses connection data identify solutions represent features contiguous units dispersible habitat. inspired mathematical formulations detailed Önal Briers (2006) Cardeira et al. 2010. example used constraints, see Hanson et al. (2019). Please note constraints require expanded formulation therefore used feature data negative vales. Please note adding constraints problem drastically increase amount time required solve .","code":""},{"path":"https://prioritizr.net/reference/add_feature_contiguity_constraints.html","id":"data-format","dir":"Reference","previous_headings":"","what":"Data format","title":"Add feature contiguity constraints — add_feature_contiguity_constraints","text":"argument data can specified using following formats. data NULL value connection data calculated automatically using adjacency_matrix() function. default argument means adjacent planning units treated potentially dispersible features. Note connection data must manually defined using one formats planning unit data argument x spatially referenced (e.g., data.frame numeric format). data amatrix/Matrix object rows columns represent different planning units value cell indicates two planning units connected . Cell values binary numeric values (.e., one zero). Cells occur along matrix diagonal effect solution planning unit connected . Note pairs connected planning units treated potentially dispersible features. data data.frame object containing columns named \"id1\", \"id2\", \"boundary\". , row denotes connectivity two planning units following Marxan format. \"boundary\" column contain binary numeric values indicate two planning units specified \"id1\" \"id2\" columns connected . data can used describe symmetric asymmetric relationships planning units. default, input data assumed symmetric unless asymmetric data also included (e.g., data present planning units 2 3, amount connectivity expected planning units 3 2, unless connectivity data also provided planning units 3 2). Note pairs connected planning units treated potentially dispersible features. data list object containing matrix, Matrix, data.frame objects showing planning units treated connected feature. element list correspond different feature (specifically, different target problem), contain matrix, Matrix, data.frame object follows conventions detailed .","code":""},{"path":"https://prioritizr.net/reference/add_feature_contiguity_constraints.html","id":"notes","dir":"Reference","previous_headings":"","what":"Notes","title":"Add feature contiguity constraints — add_feature_contiguity_constraints","text":"early versions, named add_corridor_constraints function.","code":""},{"path":"https://prioritizr.net/reference/add_feature_contiguity_constraints.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Add feature contiguity constraints — add_feature_contiguity_constraints","text":"Önal H Briers RA (2006) Optimal selection connected reserve network. Operations Research, 54: 379--388. Cardeira JO, Pinto LS, Cabeza M Gaston KJ (2010) Species specific connectivity reserve-network design using graphs. Biological Conservation, 2: 408--415. Hanson JO, Fuller RA, & Rhodes JR (2019) Conventional methods enhancing connectivity conservation planning always maintain gene flow. Journal Applied Ecology, 56: 913--922.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_feature_contiguity_constraints.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add feature contiguity constraints — add_feature_contiguity_constraints","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_features <- get_sim_zones_features()  # create minimal problem p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.3) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # create problem with contiguity constraints p2 <- p1 %>% add_contiguity_constraints()  # create problem with constraints to represent features in contiguous # units p3 <- p1 %>% add_feature_contiguity_constraints()  # create problem with constraints to represent features in contiguous # units that contain highly suitable habitat values # (specifically in the top 5th percentile) cm4 <- lapply(seq_len(terra::nlyr(sim_features)), function(i) {   # create connectivity matrix using the i'th feature's habitat data   m <- connectivity_matrix(sim_pu_raster, sim_features[[i]])   # convert matrix to 0/1 values denoting values in top 5th percentile   m <- round(m > quantile(as.vector(m), 1 - 0.05, names = FALSE))   # remove 0s from the sparse matrix   m <- Matrix::drop0(m)   # return matrix   m }) p4 <- p1 %>% add_feature_contiguity_constraints(data = cm4)  # solve problems s1 <- c(solve(p1), solve(p2), solve(p3), solve(p4)) names(s1) <- c(   \"basic solution\", \"contiguity constraints\",   \"feature contiguity constraints\",   \"feature contiguity constraints with data\" ) # plot solutions plot(s1, axes = FALSE)   # create minimal problem with multiple zones, and limit the solver to # 30 seconds to obtain solutions in a feasible period of time p5 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_min_set_objective() %>%   add_relative_targets(matrix(0.1, ncol = 3, nrow = 5)) %>%   add_binary_decisions() %>%   add_default_solver(time_limit = 30, verbose = FALSE)  # create problem with contiguity constraints that specify that the # planning units used to conserve each feature in different management # zones must form separate contiguous units p6 <- p5 %>% add_feature_contiguity_constraints(diag(3))  # create problem with contiguity constraints that specify that the # planning units used to conserve each feature must form a single # contiguous unit if the planning units are allocated to zones 1 and 2 # and do not need to form a single contiguous unit if they are allocated # to zone 3 zm7 <- matrix(0, ncol = 3, nrow = 3) zm7[seq_len(2), seq_len(2)] <- 1 print(zm7) #>      [,1] [,2] [,3] #> [1,]    1    1    0 #> [2,]    1    1    0 #> [3,]    0    0    0 p7 <- p5 %>% add_feature_contiguity_constraints(zm7)  # create problem with contiguity constraints that specify that all of # the planning units in all three of the zones must conserve first feature # in a single contiguous unit but the planning units used to conserve the # remaining features do not need to be contiguous in any way zm8 <- lapply(   seq_len(number_of_features(sim_zones_features)),   function(i) matrix(ifelse(i == 1, 1, 0), ncol = 3, nrow = 3) ) print(zm8) #> [[1]] #>      [,1] [,2] [,3] #> [1,]    1    1    1 #> [2,]    1    1    1 #> [3,]    1    1    1 #>  #> [[2]] #>      [,1] [,2] [,3] #> [1,]    0    0    0 #> [2,]    0    0    0 #> [3,]    0    0    0 #>  #> [[3]] #>      [,1] [,2] [,3] #> [1,]    0    0    0 #> [2,]    0    0    0 #> [3,]    0    0    0 #>  #> [[4]] #>      [,1] [,2] [,3] #> [1,]    0    0    0 #> [2,]    0    0    0 #> [3,]    0    0    0 #>  #> [[5]] #>      [,1] [,2] [,3] #> [1,]    0    0    0 #> [2,]    0    0    0 #> [3,]    0    0    0 #>  p8 <- p5 %>% add_feature_contiguity_constraints(zm8)  # solve problems s2 <- lapply(list(p5, p6, p7, p8), solve) s2 <- terra::rast(lapply(s2, category_layer)) names(s2) <- c(\"p5\", \"p6\", \"p7\", \"p8\") # plot solutions plot(s2, axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_feature_weights.html","id":null,"dir":"Reference","previous_headings":"","what":"Add feature weights — add_feature_weights","title":"Add feature weights — add_feature_weights","text":"Add features weights conservation planning problem. Specifically, objective functions aim maximize (minimize) metric measures well set features represented solution (e.g., maximize number features adequately represented, add_max_features_objective()). cases, may desirable prefer representation features features (e.g., features higher extinction risk might considered important lower extinction risk). achieve , weights can used specify much important solution represent particular features compared features.","code":""},{"path":"https://prioritizr.net/reference/add_feature_weights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add feature weights — add_feature_weights","text":"","code":"# S4 method for ConservationProblem,numeric add_feature_weights(x, weights)  # S4 method for ConservationProblem,matrix add_feature_weights(x, weights)"},{"path":"https://prioritizr.net/reference/add_feature_weights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add feature weights — add_feature_weights","text":"x problem() object. weights numeric matrix weights. See Weights format section information.","code":""},{"path":"https://prioritizr.net/reference/add_feature_weights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add feature weights — add_feature_weights","text":"updated problem() weights added .","code":""},{"path":"https://prioritizr.net/reference/add_feature_weights.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add feature weights — add_feature_weights","text":"Weights can applied problems objective budget limited (e.g., add_max_cover_objective(), add_min_shortfall_objective()). can also applied problems aim maximize phylogenetic representation (add_max_phylo_div_objective()) favor representation specific features representation phylogenetic branches. Weights negative values must values equal larger zero. Note planning unit costs scaled 0.01 identify cheapest solution among multiple optimal solutions. means optimization process favor cheaper solutions solutions meet feature targets (occurrences) feature weights lower 0.01.","code":""},{"path":"https://prioritizr.net/reference/add_feature_weights.html","id":"weights-format","dir":"Reference","previous_headings":"","what":"Weights format","title":"Add feature weights — add_feature_weights","text":"argument weights can specified using following formats. weights numeric vector containing weights feature. Note format used specify weights problems multiple zones. weights matrix object containing weights feature zone. , row corresponds different feature argument x, column corresponds different zone argument x, cell contains weight value given feature solution can secure given zone. Note problem contains targets created using add_manual_targets() matrix supplied containing single column indicates weight fulfilling target.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_feature_weights.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add feature weights — add_feature_weights","text":"","code":"# \\dontrun{ # load package require(ape) #> Loading required package: ape  # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features() sim_phylogeny <- get_sim_phylogeny() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_features <- get_sim_zones_features()  # create minimal problem that aims to maximize the number of features # adequately conserved given a total budget of 3800. Here, each feature # needs 20% of its habitat for it to be considered adequately conserved p1 <-   problem(sim_pu_raster, sim_features) %>%   add_max_features_objective(budget = 3800) %>%   add_relative_targets(0.2) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # create weights that assign higher importance to features with less # suitable habitat in the study area w2 <- exp((1 / terra::global(sim_features, \"sum\", na.rm = TRUE)[[1]]) * 200)  # create problem using rarity weights p2 <- p1 %>% add_feature_weights(w2)  # create manually specified weights that assign higher importance to # certain features. These weights could be based on a pre-calculated index # (e.g., an index measuring extinction risk where higher values # denote higher extinction risk) w3 <- c(0, 0, 0, 100, 200) p3 <- p1 %>% add_feature_weights(w3)  # solve problems s1 <- c(solve(p1), solve(p2), solve(p3)) names(s1) <- c(\"equal weights\", \"rarity weights\", \"manual weights\")  # plot solutions plot(s1, axes = FALSE)   # plot the example phylogeny par(mfrow = c(1, 1)) plot(sim_phylogeny, main = \"simulated phylogeny\")   # create problem with a maximum phylogenetic diversity objective, # where each feature needs 10% of its distribution to be secured for # it to be adequately conserved and a total budget of 1900 p4 <-   problem(sim_pu_raster, sim_features) %>%   add_max_phylo_div_objective(1900, sim_phylogeny) %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s4 <- solve(p4)  # plot solution plot(s4, main = \"solution\", axes = FALSE)   # find out which features have their targets met r4 <- eval_target_coverage_summary(p4, s4) print(r4, width = Inf) #> # A tibble: 5 × 9 #>   feature   met   total_amount absolute_target absolute_held absolute_shortfall #>   <chr>     <lgl>        <dbl>           <dbl>         <dbl>              <dbl> #> 1 feature_1 FALSE         83.3            8.33          7.35              0.975 #> 2 feature_2 TRUE          31.2            3.12          3.13              0     #> 3 feature_3 FALSE         72.0            7.20          5.78              1.42  #> 4 feature_4 TRUE          42.7            4.27          4.50              0     #> 5 feature_5 FALSE         56.7            5.67          5.24              0.431 #>   relative_target relative_held relative_shortfall #>             <dbl>         <dbl>              <dbl> #> 1             0.1        0.0883            0.0117  #> 2             0.1        0.100             0       #> 3             0.1        0.0803            0.0197  #> 4             0.1        0.106             0       #> 5             0.1        0.0924            0.00760  # plot the example phylogeny and color the represented features in red plot(   sim_phylogeny, main = \"represented features\",   tip.color = replace(     rep(\"black\", terra::nlyr(sim_features)), which(r4$met), \"red\"   ) )   # we can see here that the third feature (\"layer.3\", i.e., # sim_features[[3]]) is not represented in the solution. Let us pretend # that it is absolutely critical this feature is adequately conserved # in the solution. For example, this feature could represent a species # that plays important role in the ecosystem, or a species that is # important commercial activities (e.g., eco-tourism). So, to generate # a solution that conserves the third feature whilst also aiming to # maximize phylogenetic diversity, we will create a set of weights that # assign a particularly high weighting to the third feature w5 <- c(0, 0, 10000, 0, 0)  # we can see that this weighting (i.e., w5[3]) has a much higher value than # the branch lengths in the phylogeny so solutions that represent this # feature be much closer to optimality print(sim_phylogeny$edge.length) #> [1] 1.42105185 0.34712544 0.04100098 0.30612447 0.30612447 0.59604770 1.17212960 #> [8] 1.17212960  # create problem with high weighting for the third feature and solve it s5 <- p4 %>% add_feature_weights(w5) %>% solve()  # plot solution plot(s5, main = \"solution\", axes = FALSE)   # find which features have their targets met r5 <- eval_target_coverage_summary(p4, s5) print(r5, width = Inf) #> # A tibble: 5 × 9 #>   feature   met   total_amount absolute_target absolute_held absolute_shortfall #>   <chr>     <lgl>        <dbl>           <dbl>         <dbl>              <dbl> #> 1 feature_1 FALSE         83.3            8.33          7.82              0.511 #> 2 feature_2 FALSE         31.2            3.12          2.86              0.259 #> 3 feature_3 TRUE          72.0            7.20          7.22              0     #> 4 feature_4 FALSE         42.7            4.27          3.60              0.669 #> 5 feature_5 FALSE         56.7            5.67          4.94              0.730 #>   relative_target relative_held relative_shortfall #>             <dbl>         <dbl>              <dbl> #> 1             0.1        0.0939            0.00614 #> 2             0.1        0.0917            0.00831 #> 3             0.1        0.100             0       #> 4             0.1        0.0843            0.0157  #> 5             0.1        0.0871            0.0129   # plot the example phylogeny and color the represented features in red # here we can see that this solution only adequately conserves the # third feature. This means that, given the budget, we are faced with the # trade-off of conserving either the third feature, or a phylogenetically # diverse set of three different features. plot(   sim_phylogeny, main = \"represented features\",   tip.color = replace(     rep(\"black\", terra::nlyr(sim_features)), which(r5$met), \"red\"   ) )   # create multi-zone problem with maximum features objective, # with 10% representation targets for each feature, and set # a budget such that the total maximum expenditure in all zones # cannot exceed 3000 p6 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_max_features_objective(3000) %>%   add_relative_targets(matrix(0.1, ncol = 3, nrow = 5)) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # create weights that assign equal weighting for the representation # of each feature in each zone except that it does not matter if # feature 1 is represented in zone 1 and it really important # that feature 3 is really in zone 1 w7 <- matrix(1, ncol = 3, nrow = 5) w7[1, 1] <- 0 w7[3, 1] <- 100  # create problem with weights p7 <- p6 %>% add_feature_weights(w7)  # solve problems s6 <- solve(p6) s7 <- solve(p7)  # convert solutions to category layers c6 <- category_layer(s6) c7 <- category_layer(s7)  # plot solutions plot(c(c6, c7), main = c(\"equal weights\", \"manual weights\"), axes = FALSE)   # create minimal problem to show the correct method for setting # weights for problems with manual targets p8 <-   problem(sim_pu_raster, sim_features) %>%   add_max_features_objective(budget = 3000) %>%   add_manual_targets(     data.frame(     feature = c(\"feature_1\", \"feature_4\"),     type = \"relative\",     target = 0.1)   ) %>%   add_feature_weights(matrix(c(1, 200), ncol = 1)) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s8 <- solve(p8)  # plot solution plot(s8, main = \"solution\", axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_gap_portfolio.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a gap portfolio — add_gap_portfolio","title":"Add a gap portfolio — add_gap_portfolio","text":"Generate portfolio solutions conservation planning problem finding certain number solutions within pre-specified optimality gap. method useful generating multiple solutions can used calculate selection frequencies moderate large-sized problems (similar Marxan).","code":""},{"path":"https://prioritizr.net/reference/add_gap_portfolio.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a gap portfolio — add_gap_portfolio","text":"","code":"add_gap_portfolio(x, number_solutions = 10, pool_gap = 0.1)"},{"path":"https://prioritizr.net/reference/add_gap_portfolio.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a gap portfolio — add_gap_portfolio","text":"x problem() object. number_solutions integer number solutions required. Defaults 10. pool_gap numeric gap optimality solutions portfolio. relative gap specifies threshold worst-case performance solutions portfolio. example, value 0.1 result portfolio returning solutions within 10% optimal solution. Note gap specified solver (.e., add_gurobi_solver() must less equal gap specified generate portfolio. Defaults 0.1.","code":""},{"path":"https://prioritizr.net/reference/add_gap_portfolio.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a gap portfolio — add_gap_portfolio","text":"updated problem() object portfolio added .","code":""},{"path":"https://prioritizr.net/reference/add_gap_portfolio.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add a gap portfolio — add_gap_portfolio","text":"strategy generating portfolio requires problems solved using Gurobi software suite (.e., using add_gurobi_solver(). Specifically, version 9.0.0 (greater) gurobi package must installed. Note number solutions returned may less argument number_solutions, total number solutions meet optimality gap less number solutions requested. Also, note portfolio function works problems binary decisions (.e., specified using add_binary_decisions()).","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_gap_portfolio.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add a gap portfolio — add_gap_portfolio","text":"","code":"# \\dontrun{ # set seed for reproducibility set.seed(600)  # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_features <- get_sim_zones_features()  # create minimal problem with a portfolio containing 10 solutions within 20% # of optimality p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.05) %>%   add_gap_portfolio(number_solutions = 5, pool_gap = 0.2) %>%   add_default_solver(gap = 0, verbose = FALSE)  # solve problem and generate portfolio s1 <- solve(p1)  # convert portfolio into a multi-layer raster s1 <- terra::rast(s1)  # print number of solutions found print(terra::nlyr(s1)) #> [1] 5  # plot solutions plot(s1, axes = FALSE)   # create multi-zone  problem with a portfolio containing 10 solutions within # 20% of optimality p2 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_min_set_objective() %>%   add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %>%   add_gap_portfolio(number_solutions = 5, pool_gap = 0.2) %>%   add_default_solver(gap = 0, verbose = FALSE)  # solve problem and generate portfolio s2 <- solve(p2)  # convert portfolio into a multi-layer raster of category layers s2 <- terra::rast(lapply(s2, category_layer))  # print number of solutions found print(terra::nlyr(s2)) #> [1] 5  # plot solutions in portfolio plot(s2, axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_gurobi_solver.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a Gurobi solver — add_gurobi_solver","title":"Add a Gurobi solver — add_gurobi_solver","text":"Specify Gurobi software used solve conservation planning problem (Gurobi Optimization LLC 2021). function can also used customize behavior solver. requires gurobi package installed (see installation instructions).","code":""},{"path":"https://prioritizr.net/reference/add_gurobi_solver.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a Gurobi solver — add_gurobi_solver","text":"","code":"add_gurobi_solver(   x,   gap = 0.1,   time_limit = .Machine$integer.max,   presolve = 2,   threads = 1,   first_feasible = FALSE,   numeric_focus = FALSE,   node_file_start = Inf,   start_solution = NULL,   verbose = TRUE )"},{"path":"https://prioritizr.net/reference/add_gurobi_solver.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a Gurobi solver — add_gurobi_solver","text":"x problem() object. gap numeric gap optimality. gap relative expresses acceptable deviance optimal objective. example, value 0.01 result solver stopping found solution within 1% optimality. Additionally, value 0 result solver stopping found optimal solution. default value 0.1 (.e., 10% optimality). time_limit numeric time limit (seconds) generating solutions. solver return current best solution time limit exceeded. default value largest integer value (.e., .Machine$integer.max), effectively meaning solver keep running solution within optimality gap found. presolve integer number indicating intensively solver try simplify problem solving . Available options : (-1) automatically determine intensity pre-solving, (0) disable pre-solving, (1) conservative level pre-solving, (2) aggressive level pre-solving . default value 2. threads integer number threads use optimization algorithm. default value 1. first_feasible logical first feasible solution returned? first_feasible set TRUE, solver return first solution encounters meets constraints, regardless solution quality. Note first feasible solution arbitrary solution, rather derived relaxed solution, therefore often reasonably close optimality. Defaults FALSE. numeric_focus logical extra attention paid verifying accuracy numerical calculations? may useful dealing problems may suffer numerical instability issues. Beware likely substantially increase run time (sets Gurobi NumericFocus parameter 3). Defaults FALSE. node_file_start numeric threshold amount memory (GB). amount memory (RAM) used store information solving optimization problem exceeds parameter value, solver begin storing information disk (using Gurobi NodeFileStart parameter). functionality useful system insufficient memory solve given problem (e.g., solving problem default settings yields MEMORY error message) system memory readily available. example, value 4 indicates solver start using disk uses 4 GB memory store information solving problem. Defaults Inf solver attempt store information disk solving given problem. start_solution NULL object containing starting solution solver. can useful specifying starting solution can speed optimization process. Defaults NULL starting solution used. specify starting solution, argument start_solution format planning units (.e., NULL, numeric, matrix, data.frame, terra::rast(), sf::sf() object). See Start solution format section information. verbose logical information printed solving optimization problems? Defaults TRUE.","code":""},{"path":"https://prioritizr.net/reference/add_gurobi_solver.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a Gurobi solver — add_gurobi_solver","text":"updated problem() object solver added .","code":""},{"path":"https://prioritizr.net/reference/add_gurobi_solver.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add a Gurobi solver — add_gurobi_solver","text":"Gurobi state---art commercial optimization software R package interface. far fastest solvers available generating prioritizations, however, freely available. said, licenses available academics cost. gurobi package distributed Gurobi software suite. solver uses gurobi package solve problems. information performance different solvers, please see Schuster et al. (2020) benchmarks comparing run time solution quality different solvers applied different sized datasets.","code":""},{"path":"https://prioritizr.net/reference/add_gurobi_solver.html","id":"installation","dir":"Reference","previous_headings":"","what":"Installation","title":"Add a Gurobi solver — add_gurobi_solver","text":"Please see Gurobi Installation Guide vignette details installing Gurobi software gurobi package. can access vignette online using following code:","code":"vignette(\"gurobi_installation_guide\", package = \"prioritizr\")"},{"path":"https://prioritizr.net/reference/add_gurobi_solver.html","id":"start-solution-format","dir":"Reference","previous_headings":"","what":"Start solution format","title":"Add a Gurobi solver — add_gurobi_solver","text":"Broadly speaking, argument start_solution must format planning unit data argument x. details correct format listed separately different planning unit data formats: x numeric planning units argument start_solution must numeric vector element corresponding different planning unit. number planning units argument x. Additionally, planning units missing cost (NA) values also missing (NA) values argument start_solution. x matrix planning units argument start_solution must matrix vector row corresponding different planning unit, column correspond different management zone. number planning units zones argument x. Additionally, planning units missing cost (NA) values particular zone also missing (NA) values argument start_solution. x terra::rast() planning units argument start_solution terra::rast() object different grid cells (pixels) correspond different planning units layers correspond different management zones. dimensionality (rows, columns, layers), resolution, extent, coordinate reference system planning units argument x. Additionally, planning units missing cost (NA) values particular zone also missing (NA)  values argument start_solution. x data.frame planning units argument start_solution must data.frame column corresponding different zone, row corresponding different planning unit, cell values corresponding solution value. means data.frame object containing solution also contains additional columns, columns need subsetted prior using function (see example sf::sf() data). Additionally, planning units missing cost (NA) values particular zone also missing (NA) values argument start_solution. x sf::sf() planning units argument start_solution must sf::sf() object column corresponding different zone, row corresponding different planning unit, cell values corresponding solution value. means sf::sf() object containing solution also contains additional columns, columns need subsetted prior using function (see example). Additionally, argument start_solution must also coordinate reference system planning unit data. Furthermore, planning units missing cost (NA) values particular zone also missing (NA) values argument start_solution.","code":""},{"path":"https://prioritizr.net/reference/add_gurobi_solver.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Add a Gurobi solver — add_gurobi_solver","text":"Gurobi Optimization LLC (2021) Gurobi Optimizer Reference Manual. https://www.gurobi.com. Schuster R, Hanson JO, Strimas-Mackey M, Bennett JR (2020). Exact integer linear programming solvers outperform simulated annealing solving conservation planning problems. PeerJ, 8: e9258.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_gurobi_solver.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add a Gurobi solver — add_gurobi_solver","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features()  # create problem p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_gurobi_solver(gap = 0, verbose = FALSE)  # generate solution s1 <- solve(p1)  # plot solution plot(s1, main = \"solution\", axes = FALSE)   # create a similar problem with boundary length penalties and # specify the solution from the previous run as a starting solution p2 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_boundary_penalties(10) %>%   add_binary_decisions() %>%   add_gurobi_solver(gap = 0, start_solution = s1, verbose = FALSE)  # generate solution s2 <- solve(p2)  # plot solution plot(s2, main = \"solution with boundary penalties\", axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_highs_solver.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a HiGHS solver — add_highs_solver","title":"Add a HiGHS solver — add_highs_solver","text":"Specify HiGHS software used solve conservation planning problem (Huangfu Hall 2018). function can also used customize behavior solver. requires highs package installed.","code":""},{"path":"https://prioritizr.net/reference/add_highs_solver.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a HiGHS solver — add_highs_solver","text":"","code":"add_highs_solver(   x,   gap = 0.1,   time_limit = .Machine$integer.max,   presolve = TRUE,   threads = 1,   verbose = TRUE )"},{"path":"https://prioritizr.net/reference/add_highs_solver.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a HiGHS solver — add_highs_solver","text":"x problem() object. gap numeric gap optimality. gap relative expresses acceptable deviance optimal objective. example, value 0.01 result solver stopping found solution within 1% optimality. Additionally, value 0 result solver stopping found optimal solution. default value 0.1 (.e., 10% optimality). time_limit numeric time limit (seconds) generating solutions. solver return current best solution time limit exceeded. default value largest integer value (.e., .Machine$integer.max), effectively meaning solver keep running solution within optimality gap found. presolve logical attempt simplify problem solving ? Defaults TRUE. threads integer number threads use optimization algorithm. default value 1. verbose logical information printed solving optimization problems? Defaults TRUE.","code":""},{"path":"https://prioritizr.net/reference/add_highs_solver.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a HiGHS solver — add_highs_solver","text":"updated problem() object solver added .","code":""},{"path":"https://prioritizr.net/reference/add_highs_solver.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add a HiGHS solver — add_highs_solver","text":"HiGHS open source optimization software. Although solver can comparable performance CBC solver (.e., add_cbc_solver()) particular problems generally faster SYMPHONY based solvers (.e., add_rsymphony_solver(), add_lpsymphony_solver()), can sometimes take much longer CBC solver particular problems. solver recommended add_gurobi_solver(), add_cplex_solver(), add_cbc_solver() used.","code":""},{"path":"https://prioritizr.net/reference/add_highs_solver.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Add a HiGHS solver — add_highs_solver","text":"Huangfu Q Hall JAJ (2018). Parallelizing dual revised simplex method. Mathematical Programming Computation, 10: 119-142.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_highs_solver.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add a HiGHS solver — add_highs_solver","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features()  # create problem p <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_highs_solver(gap = 0, verbose = FALSE)  # generate solution s <- solve(p)  # plot solution plot(s, main = \"solution\", axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_linear_constraints.html","id":null,"dir":"Reference","previous_headings":"","what":"Add linear constraints — add_linear_constraints","title":"Add linear constraints — add_linear_constraints","text":"Add constraints conservation planning problem ensure selected planning units meet certain criteria.","code":""},{"path":"https://prioritizr.net/reference/add_linear_constraints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add linear constraints — add_linear_constraints","text":"","code":"# S4 method for ConservationProblem,ANY,ANY,character add_linear_constraints(x, threshold, sense, data)  # S4 method for ConservationProblem,ANY,ANY,numeric add_linear_constraints(x, threshold, sense, data)  # S4 method for ConservationProblem,ANY,ANY,matrix add_linear_constraints(x, threshold, sense, data)  # S4 method for ConservationProblem,ANY,ANY,Matrix add_linear_constraints(x, threshold, sense, data)  # S4 method for ConservationProblem,ANY,ANY,Raster add_linear_constraints(x, threshold, sense, data)  # S4 method for ConservationProblem,ANY,ANY,SpatRaster add_linear_constraints(x, threshold, sense, data)  # S4 method for ConservationProblem,ANY,ANY,dgCMatrix add_linear_constraints(x, threshold, sense, data)"},{"path":"https://prioritizr.net/reference/add_linear_constraints.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add linear constraints — add_linear_constraints","text":"x problem() object. threshold numeric value. threshold value also known \"right-hand-side\" value per integer programming terminology. sense character sense constraint. Available options include \">=\", \"<=\", \"=\" values. data character, numeric, terra::rast(), matrix, Matrix object containing constraint values. constraint values also known constraint coefficients per integer programming terminology. See Data format section information.","code":""},{"path":"https://prioritizr.net/reference/add_linear_constraints.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add linear constraints — add_linear_constraints","text":"updated problem() object constraints added .","code":""},{"path":"https://prioritizr.net/reference/add_linear_constraints.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add linear constraints — add_linear_constraints","text":"function adds general purpose constraints can used ensure solutions meet certain criteria (see Examples section details). example, constraints can used add multiple budgets. can also used ensure total number planning units allocated certain administrative area (e.g., country) exceed certain threshold (e.g., 30% total area). Furthermore, can also used ensure features minimal level representation (e.g., 30%) using objective function aims enhance feature representation given budget (e.g., add_min_shortfall_objective()).","code":""},{"path":"https://prioritizr.net/reference/add_linear_constraints.html","id":"mathematical-formulation","dir":"Reference","previous_headings":"","what":"Mathematical formulation","title":"Add linear constraints — add_linear_constraints","text":"linear constraints implemented using following equation. Let \\(\\) denote set planning units (indexed \\(\\)), \\(Z\\) set management zones (indexed \\(z\\)), \\(X_{iz}\\) decision variable allocating planning unit \\(\\) zone \\(z\\) (e.g., binary values indicating planning unit allocated ). Also, let \\(D_{iz}\\) denote constraint data associated planning units \\(\\\\) zones \\(z \\Z\\) (argument data, supplied matrix object), \\(\\theta\\) denote constraint sense (argument sense, e.g., \\(<=\\)), \\(t\\) denote constraint threshold (argument threshold). $$ \\sum_{}^{} \\sum_{z}^{Z} (D_{iz} \\times X_{iz}) \\space \\theta \\space t $$","code":""},{"path":"https://prioritizr.net/reference/add_linear_constraints.html","id":"data-format","dir":"Reference","previous_headings":"","what":"Data format","title":"Add linear constraints — add_linear_constraints","text":"argument data can specified using following formats. data character vector containing column name(s) contain penalty values planning units. format compatible planning units argument x sf::sf() data.frame object. column(s) must numeric values, must contain missing (NA) values. problems contain single zone, argument data must contain single column name. Otherwise, problems contain multiple zones, argument data must contain column name zone. data numeric vector containing values planning units. values must contain missing (NA) values. Note format available planning units contain single zone. data matrix/Matrix object containing numeric values specify data planning unit. row corresponds planning unit, column corresponds zone, cell indicates data penalizing planning unit allocated given zone. data terra::rast() object containing values planning units. format compatible planning units argument x sf::sf(), terra::rast() objects. planning unit data sf::sf() object, values calculated overlaying planning units argument data calculating sum values associated planning unit. planning unit data terra::rast() object, values calculated extracting cell values (note planning unit data argument data must exactly dimensionality, extent, missingness). problems involving multiple zones, argument data must contain layer zone.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_linear_constraints.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add linear constraints — add_linear_constraints","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features()  # create a baseline problem with minimum shortfall objective p0 <-   problem(sim_pu_raster, sim_features) %>%   add_min_shortfall_objective(1800) %>%   add_relative_targets(0.2) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s0 <- solve(p0)  # plot solution plot(s0, main = \"solution\", axes = FALSE)   # now let's create some modified versions of this baseline problem by # adding additional criteria using linear constraints  # first, let's create a modified version of p0 that contains # an additional budget of 1600 based on a secondary cost dataset  # create a secondary cost dataset by simulating values sim_pu_raster2 <- simulate_cost(sim_pu_raster)  # plot the primary cost dataset (sim_pu_raster) and # the secondary cost dataset (sim_pu_raster2) plot(   c(sim_pu_raster, sim_pu_raster2),   main = c(\"sim_pu_raster\", \"sim_pu_raster2\"),   axes = FALSE )   # create a modified version of p0 with linear constraints that # specify that the planning units in the solution must not have # values in sim_pu_raster2 that sum to a total greater than 500 p1 <-   p0 %>%   add_linear_constraints(     threshold = 500, sense = \"<=\", data = sim_pu_raster2   )  # solve problem s1 <- solve(p1)  # plot solutions s1 and s2 to compare them plot(c(s0, s1), main = c(\"s0\", \"s1\"), axes = FALSE)   # second, let's create a modified version of p0 that contains # additional constraints to ensure that each feature has # at least 8% of its overall distribution represented by the solution  # to achieve this, we need to calculate the total amount of each feature # within the planning units so we can, in turn, set the constraint thresholds feat_abund <- feature_abundances(p0)$absolute_abundance  # create a modified version of p0 with additional constraints for each # feature to specify that the planning units in the solution must # secure at least 8% of the total abundance for each feature p2 <- p0 for (i in seq_len(terra::nlyr(sim_features))) {   p2 <-     p2 %>%     add_linear_constraints(       threshold = feat_abund[i] * 0.08,       sense = \">=\",       data = sim_features[[i]]     ) }  # overall, p2 could be described as an optimization problem # that maximizes feature representation as much as possible # towards securing 20% of the total amount of each feature, # whilst ensuring that (i) the total cost of the solution does # not exceed 1800 (per cost values in sim_pu_raster) and (ii) # the solution secures at least 8% of the total amount of each feature # (if 20% is not possible due to the budget)  # solve problem s2 <- solve(p2)  # plot solutions s0 and s2 to compare them plot(c(s0, s2), main = c(\"s1\", \"s2\"), axes = FALSE)   # third, let's create a modified version of p0 that contains # additional constraints to ensure that the solution equitably # distributes conservation effort across different administrative areas # (e.g., countries) within the study region  # to begin with, we will simulate a dataset describing the spatial extent of # four different administrative areas across the study region sim_admin <- sim_pu_raster sim_admin <- terra::aggregate(sim_admin, fact = 5) sim_admin <- terra::setValues(sim_admin, seq_len(terra::ncell(sim_admin))) sim_admin <- terra::resample(sim_admin, sim_pu_raster, method = \"near\") sim_admin <- terra::mask(sim_admin, sim_pu_raster)  # plot administrative areas layer, # we can see that the administrative areas subdivide # the study region into four quadrants, and the sim_admin object is a # SpatRaster with integer values denoting ids for the administrative areas plot(sim_admin, axes = FALSE)   # next we will convert the sim_admin SpatRaster object into a SpatRaster # object (with a layer for each administrative area) indicating which # planning units belong to each administrative area using binary # (presence/absence) values sim_admin2 <- binary_stack(sim_admin)  # plot binary stack of administrative areas plot(sim_admin2, axes = FALSE)   # we will now calculate the total amount of planning units associated # with each administrative area, so that we can set the constraint threshold  # since we are using raster data, we won't bother explicitly # accounting for the total area of each planning unit (because all # planning units have the same area in raster formats) -- but if we were # using vector data then we would need to account for the area of each unit admin_total <- Matrix::rowSums(rij_matrix(sim_pu_raster, sim_admin2))  # create a modified version of p0 with additional constraints for each # administrative area to specify that the planning units in the solution must # not encompass more than 10% of the total extent of the administrative # area p3 <- p0 for (i in seq_len(terra::nlyr(sim_admin2))) {   p3 <-     p3 %>%     add_linear_constraints(       threshold = admin_total[i] * 0.1,       sense = \"<=\",       data = sim_admin2[[i]]     ) }  # solve problem s3 <- solve(p3)  # plot solutions s0 and s3 to compare them plot(c(s0, s3), main = c(\"s0\", \"s3\"), axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_linear_penalties.html","id":null,"dir":"Reference","previous_headings":"","what":"Add linear penalties — add_linear_penalties","title":"Add linear penalties — add_linear_penalties","text":"Add penalties conservation planning problem penalize solutions select planning units higher values specific data source (e.g., anthropogenic impact). penalties assume linear trade-penalty values primary objective conservation planning problem (e.g., solution cost minimum set problems; add_min_set_objective().","code":""},{"path":"https://prioritizr.net/reference/add_linear_penalties.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add linear penalties — add_linear_penalties","text":"","code":"# S4 method for ConservationProblem,ANY,character add_linear_penalties(x, penalty, data)  # S4 method for ConservationProblem,ANY,numeric add_linear_penalties(x, penalty, data)  # S4 method for ConservationProblem,ANY,matrix add_linear_penalties(x, penalty, data)  # S4 method for ConservationProblem,ANY,Matrix add_linear_penalties(x, penalty, data)  # S4 method for ConservationProblem,ANY,Raster add_linear_penalties(x, penalty, data)  # S4 method for ConservationProblem,ANY,SpatRaster add_linear_penalties(x, penalty, data)  # S4 method for ConservationProblem,ANY,dgCMatrix add_linear_penalties(x, penalty, data)"},{"path":"https://prioritizr.net/reference/add_linear_penalties.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add linear penalties — add_linear_penalties","text":"x problem() object. penalty numeric penalty value used scale importance selecting planning units high data values. Higher penalty values can used obtain solutions strongly averse selecting places high data values, smaller penalty values can used obtain solutions avoid places especially high data values. Note negative penalty values can used obtain solutions prefer places high data values. Additionally, adding penalties problems multiple zones, argument penalty must value zone. data character, numeric, terra::rast(), matrix, Matrix object containing values used penalize solutions. Planning units associated higher data values penalized strongly solution. See Data format section information.","code":""},{"path":"https://prioritizr.net/reference/add_linear_penalties.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add linear penalties — add_linear_penalties","text":"updated problem() object penalties added .","code":""},{"path":"https://prioritizr.net/reference/add_linear_penalties.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add linear penalties — add_linear_penalties","text":"function penalizes solutions higher values according sum penalty values associated planning unit, weighted status planning unit solution.","code":""},{"path":"https://prioritizr.net/reference/add_linear_penalties.html","id":"data-format","dir":"Reference","previous_headings":"","what":"Data format","title":"Add linear penalties — add_linear_penalties","text":"argument data can specified using following formats. data character vector containing column name(s) contain penalty values planning units. format compatible planning units argument x sf::sf() data.frame object. column(s) must numeric values, must contain missing (NA) values. problems contain single zone, argument data must contain single column name. Otherwise, problems contain multiple zones, argument data must contain column name zone. data numeric vector containing values planning units. values must contain missing (NA) values. Note format available planning units contain single zone. data matrix/Matrix object containing numeric values specify data planning unit. row corresponds planning unit, column corresponds zone, cell indicates data penalizing planning unit allocated given zone. data terra::rast() object containing values planning units. format compatible planning units argument x sf::sf(), terra::rast() objects. planning unit data sf::sf() object, values calculated overlaying planning units argument data calculating sum values associated planning unit. planning unit data terra::rast() object, values calculated extracting cell values (note planning unit data argument data must exactly dimensionality, extent, missingness). problems involving multiple zones, argument data must contain layer zone.","code":""},{"path":"https://prioritizr.net/reference/add_linear_penalties.html","id":"mathematical-formulation","dir":"Reference","previous_headings":"","what":"Mathematical formulation","title":"Add linear penalties — add_linear_penalties","text":"linear penalties implemented using following equations. Let \\(\\) denote set planning units (indexed \\(\\)), \\(Z\\) set management zones (indexed \\(z\\)), \\(X_{iz}\\) decision variable allocating planning unit \\(\\) zone \\(z\\) (e.g., binary values indicating planning unit allocated ). Also, let \\(P_z\\) represent penalty scaling value zones \\(z \\Z\\) (argument penalty), \\(D_{iz}\\) penalty data allocating planning unit \\(\\\\) zones \\(z \\Z\\) (argument data, supplied matrix object). $$ \\sum_{}^{} \\sum_{z}^{Z} P_z \\times D_{iz} \\times X_{iz} $$ Note problem objective maximize measure benefit minimize measure cost, term \\(P_z\\) replaced \\(-P_z\\).","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_linear_penalties.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add linear penalties — add_linear_penalties","text":"","code":"# \\dontrun{ # set seed for reproducibility set.seed(600)  # load data sim_pu_polygons <- get_sim_pu_polygons() sim_features <- get_sim_features() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_features <- get_sim_zones_features()  # add a column to contain the penalty data for each planning unit # e.g., these values could indicate the level of habitat sim_pu_polygons$penalty_data <- runif(nrow(sim_pu_polygons))  # plot the penalty data to visualise its spatial distribution plot(sim_pu_polygons[, \"penalty_data\"], axes = FALSE)   # create minimal problem with minimum set objective, # this does not use the penalty data p1 <-   problem(sim_pu_polygons, sim_features, cost_column = \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # print problem print(p1) #> A conservation problem (<ConservationProblem>) #> ├•data #> │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) #> │└•planning units: #> │ ├•data:       <sftbl_dftbldata.frame> (90 total) #> │ ├•costs:      continuous values (between 190.1328 and 215.8638) #> │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) #> │ └•CRS:        Undefined Cartesian SRS (projected) #> ├•formulation #> │├•objective:   minimum set objective #> │├•penalties:   none specified #> │├•targets:     relative targets (between 0.1 and 0.1) #> │├•constraints: none specified #> │└•decisions:   binary decision #> └•optimization #>  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) #>  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) #> # ℹ Use `summary(...)` to see complete formulation.  # create an updated version of the previous problem, # with the penalties added to it p2 <- p1 %>% add_linear_penalties(100, data = \"penalty_data\")  # print problem print(p2) #> A conservation problem (<ConservationProblem>) #> ├•data #> │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) #> │└•planning units: #> │ ├•data:       <sftbl_dftbldata.frame> (90 total) #> │ ├•costs:      continuous values (between 190.1328 and 215.8638) #> │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) #> │ └•CRS:        Undefined Cartesian SRS (projected) #> ├•formulation #> │├•objective:   minimum set objective #> │├•penalties:  #> ││└•1:          linear penalties (`penalty` = 100, …) #> │├•targets:     relative targets (between 0.1 and 0.1) #> │├•constraints: none specified #> │└•decisions:   binary decision #> └•optimization #>  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) #>  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) #> # ℹ Use `summary(...)` to see complete formulation.  # solve the two problems s1 <- solve(p1) s2 <- solve(p2)  # create a new object with both solutions s3 <- sf::st_sf(   tibble::tibble(     s1 = s1$solution_1,     s2 = s2$solution_1   ),   geometry = sf::st_geometry(s1) )   # plot the solutions and compare them, # since we supplied a very high penalty value (i.e., 100), relative # to the range of values in the penalty data and the objective function, # the solution in s2 is very sensitive to values in the penalty data plot(s3, axes = FALSE)   # for real conservation planning exercises, # it would be worth exploring a range of penalty values (e.g., ranging # from 1 to 100 increments of 5) to explore the trade-offs  # now, let's examine a conservation planning exercise involving multiple # management zones  # create targets for each feature within each zone, # these targets indicate that each zone needs to represent 10% of the # spatial distribution of each feature targ <- matrix(   0.1, ncol = number_of_zones(sim_zones_features),   nrow = number_of_features(sim_zones_features) )  # create penalty data for allocating each planning unit to each zone, # these data will be generated by simulating values penalty_raster <- simulate_cost(   sim_zones_pu_raster[[1]],   n = number_of_zones(sim_zones_features) )  # plot the penalty data, each layer corresponds to a different zone plot(penalty_raster, main = \"penalty data\", axes = FALSE)   # create a multi-zone problem with the minimum set objective # and penalties for allocating planning units to each zone, # with a penalty scaling factor of 1 for each zone p4 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_min_set_objective() %>%   add_relative_targets(targ) %>%   add_linear_penalties(c(1, 1, 1), penalty_raster) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # print problem print(p4) #> A conservation problem (<ConservationProblem>) #> ├•data #> │├•zones:       \"zone_1\", \"zone_2\", and \"zone_3\" (3 total) #> │├•features:    \"feature_1\", \"feature_2\", \"feature_3\", \"feature_4\", and \"feature_5\" (5 total) #> │└•planning units: #> │ ├•data:       <SpatRaster> (90 total) #> │ ├•costs:      continuous values (between 182.6017 and 224.8492) #> │ ├•extent:     0, 0, 1, 1 (xmin, ymin, xmax, ymax) #> │ └•CRS:        Undefined Cartesian SRS (projected) #> ├•formulation #> │├•objective:   minimum set objective #> │├•penalties:  #> ││└•1:          linear penalties (`penalty` = 1, 1, and 1, …) #> │├•targets:     relative targets (between 0.1 and 0.1) #> │├•constraints: none specified #> │└•decisions:   binary decision #> └•optimization #>  ├•portfolio:   shuffle portfolio (`number_solutions` = 1, …) #>  └•solver:      gurobi solver (`gap` = 0.1, `time_limit` = 2147483647, `first_feasible` = FALSE, …) #> # ℹ Use `summary(...)` to see complete formulation.  # solve problem s4 <- solve(p4)  # plot solution plot(category_layer(s4), main = \"multi-zone solution\", axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_locked_in_constraints.html","id":null,"dir":"Reference","previous_headings":"","what":"Add locked in constraints — add_locked_in_constraints","title":"Add locked in constraints — add_locked_in_constraints","text":"Add constraints conservation planning problem ensure specific planning units selected (allocated specific zone) solution. example, may desirable lock planning units inside existing protected areas solution fills gaps existing reserve network. specific planning units locked solution, use add_locked_out_constraints(). problems non-binary planning unit allocations (e.g., proportions), add_manual_locked_constraints() function can used lock planning unit allocations specific value.","code":""},{"path":"https://prioritizr.net/reference/add_locked_in_constraints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add locked in constraints — add_locked_in_constraints","text":"","code":"add_locked_in_constraints(x, locked_in)  # S4 method for ConservationProblem,numeric add_locked_in_constraints(x, locked_in)  # S4 method for ConservationProblem,logical add_locked_in_constraints(x, locked_in)  # S4 method for ConservationProblem,matrix add_locked_in_constraints(x, locked_in)  # S4 method for ConservationProblem,character add_locked_in_constraints(x, locked_in)  # S4 method for ConservationProblem,Spatial add_locked_in_constraints(x, locked_in)  # S4 method for ConservationProblem,sf add_locked_in_constraints(x, locked_in)  # S4 method for ConservationProblem,Raster add_locked_in_constraints(x, locked_in)  # S4 method for ConservationProblem,SpatRaster add_locked_in_constraints(x, locked_in)"},{"path":"https://prioritizr.net/reference/add_locked_in_constraints.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add locked in constraints — add_locked_in_constraints","text":"x problem() object. locked_in Object determines planning units locked . See Data format section information.","code":""},{"path":"https://prioritizr.net/reference/add_locked_in_constraints.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add locked in constraints — add_locked_in_constraints","text":"updated problem() object constraints added .","code":""},{"path":"https://prioritizr.net/reference/add_locked_in_constraints.html","id":"data-format","dir":"Reference","previous_headings":"","what":"Data format","title":"Add locked in constraints — add_locked_in_constraints","text":"locked planning units can specified using following formats. Generally, locked data correspond planning units argument x. help make working terra::rast() planning unit data easier, locked data correspond cell indices terra::rast() data. example, integer arguments correspond cell indices logical arguments value cell---regardless planning unit cells contain NA values. data integer vector containing indices indicate planning units locked solution. argument compatible problems contain single zone. data logical vector containing TRUE /FALSE values indicate planning units locked solution. argument compatible problems contain single zone. data matrix object containing logical TRUE /FALSE values indicate certain planning units locked specific zone solution. row corresponds planning unit, column corresponds zone, cell indicates planning unit locked given zone. Thus row contain single TRUE value. data character vector containing column name(s) indicates planning units locked solution. format compatible planning units argument x sf::sf() data.frame object. columns must logical (.e., TRUE FALSE) values indicating planning unit locked solution. problems contain single zone, argument data must contain single column name. Otherwise, problems contain multiple zones, argument data must contain column name zone. data sf::sf() object containing geometries used lock planning units solution. Specifically, planning units x spatially intersect y locked (per intersecting_units()). Note option available problems contain single management zone. data terra::rast() object containing cells used lock planning units solution. Specifically, planning units x intersect cells non-zero non-NA values locked. problems contain multiple zones, data object must contain layer zone. Note multi-band arguments, pixel must contain non-zero value single band. Additionally, cost data x terra::rast() object, recommend standardizing NA values dataset cost data. words, pixels x NA values also NA values locked data.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_locked_in_constraints.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add locked in constraints — add_locked_in_constraints","text":"","code":"# \\dontrun{ # set seed for reproducibility set.seed(500)  # load data sim_pu_polygons <- get_sim_pu_polygons() sim_features <- get_sim_features() sim_locked_in_raster <- get_sim_locked_in_raster() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_pu_polygons <- get_sim_zones_pu_polygons() sim_zones_features <- get_sim_zones_features()  # create minimal problem p1 <-   problem(sim_pu_polygons, sim_features, \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.2) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # create problem with added locked in constraints using integers p2 <- p1 %>% add_locked_in_constraints(which(sim_pu_polygons$locked_in))  # create problem with added locked in constraints using a column name p3 <- p1 %>% add_locked_in_constraints(\"locked_in\")  # create problem with added locked in constraints using raster data p4 <- p1 %>% add_locked_in_constraints(sim_locked_in_raster)  # create problem with added locked in constraints using spatial polygon data locked_in <- sim_pu_polygons[sim_pu_polygons$locked_in == 1, ] p5 <- p1 %>% add_locked_in_constraints(locked_in)  # solve problems s1 <- solve(p1) s2 <- solve(p2) s3 <- solve(p3) s4 <- solve(p4) s5 <- solve(p5)  # create single object with all solutions s6 <- sf::st_sf(   tibble::tibble(     s1 = s1$solution_1,     s2 = s2$solution_1,     s3 = s3$solution_1,     s4 = s4$solution_1,     s5 = s5$solution_1   ),   geometry = sf::st_geometry(s1) )  # plot solutions plot(   s6,   main = c(     \"none locked in\", \"locked in (integer input)\",     \"locked in (character input)\", \"locked in (raster input)\",     \"locked in (polygon input)\"   ) )   # create minimal multi-zone problem with spatial data p7 <-   problem(     sim_zones_pu_polygons, sim_zones_features,     cost_column = c(\"cost_1\", \"cost_2\", \"cost_3\")   ) %>%   add_min_set_objective() %>%   add_absolute_targets(matrix(rpois(15, 1), nrow = 5, ncol = 3)) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # create multi-zone problem with locked in constraints using matrix data locked_matrix <- as.matrix(sf::st_drop_geometry(   sim_zones_pu_polygons[, c(\"locked_1\", \"locked_2\", \"locked_3\")] ))  p8 <- p7 %>% add_locked_in_constraints(locked_matrix)  # solve problem s8 <- solve(p8)  # create new column representing the zone id that each planning unit # was allocated to in the solution s8$solution <- category_vector(sf::st_drop_geometry(   s8[, c(\"solution_1_zone_1\", \"solution_1_zone_2\", \"solution_1_zone_3\")] )) s8$solution <- factor(s8$solution)  # plot solution plot(s8[ \"solution\"], axes = FALSE)   # create multi-zone problem with locked in constraints using column names p9 <- p7 %>% add_locked_in_constraints(c(\"locked_1\", \"locked_2\", \"locked_3\"))  # solve problem s9 <- solve(p9)  # create new column representing the zone id that each planning unit # was allocated to in the solution s9$solution <- category_vector(sf::st_drop_geometry(   s9[, c(\"solution_1_zone_1\", \"solution_1_zone_2\", \"solution_1_zone_3\")] )) s9$solution[s9$solution == 1 & s9$solution_1_zone_1 == 0] <- 0 s9$solution <- factor(s9$solution)  # plot solution plot(s9[, \"solution\"], axes = FALSE)  # create multi-zone problem with raster planning units p10 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_min_set_objective() %>%   add_absolute_targets(matrix(rpois(15, 1), nrow = 5, ncol = 3)) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # create multi-layer raster with locked in units locked_in_raster <- sim_zones_pu_raster[[1]] locked_in_raster[!is.na(locked_in_raster)] <- 0 locked_in_raster <- locked_in_raster[[c(1, 1, 1)]] names(locked_in_raster) <- c(\"zone_1\", \"zone_2\", \"zone_3\") locked_in_raster[[1]][1] <- 1 locked_in_raster[[2]][2] <- 1 locked_in_raster[[3]][3] <- 1  # plot locked in raster plot(locked_in_raster)   # add locked in raster units to problem p10 <- p10 %>% add_locked_in_constraints(locked_in_raster)  # solve problem s10 <- solve(p10)  # plot solution plot(category_layer(s10), main = \"solution\", axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_locked_out_constraints.html","id":null,"dir":"Reference","previous_headings":"","what":"Add locked out constraints — add_locked_out_constraints","title":"Add locked out constraints — add_locked_out_constraints","text":"Add constraints conservation planning problem ensure specific planning units selected (allocated specific zone) solution. example, may useful lock planning units degraded suitable conserving species. specific planning units locked solution, use add_locked_in_constraints(). problems non-binary planning unit allocations (e.g., proportions), add_manual_locked_constraints() function can used lock planning unit allocations specific value.","code":""},{"path":"https://prioritizr.net/reference/add_locked_out_constraints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add locked out constraints — add_locked_out_constraints","text":"","code":"add_locked_out_constraints(x, locked_out)  # S4 method for ConservationProblem,numeric add_locked_out_constraints(x, locked_out)  # S4 method for ConservationProblem,logical add_locked_out_constraints(x, locked_out)  # S4 method for ConservationProblem,matrix add_locked_out_constraints(x, locked_out)  # S4 method for ConservationProblem,character add_locked_out_constraints(x, locked_out)  # S4 method for ConservationProblem,Spatial add_locked_out_constraints(x, locked_out)  # S4 method for ConservationProblem,sf add_locked_out_constraints(x, locked_out)  # S4 method for ConservationProblem,Raster add_locked_out_constraints(x, locked_out)  # S4 method for ConservationProblem,SpatRaster add_locked_out_constraints(x, locked_out)"},{"path":"https://prioritizr.net/reference/add_locked_out_constraints.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add locked out constraints — add_locked_out_constraints","text":"x problem() object. locked_out Object determines planning units locked . See Data format section information.","code":""},{"path":"https://prioritizr.net/reference/add_locked_out_constraints.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add locked out constraints — add_locked_out_constraints","text":"updated problem() object constraints added .","code":""},{"path":"https://prioritizr.net/reference/add_locked_out_constraints.html","id":"data-format","dir":"Reference","previous_headings":"","what":"Data format","title":"Add locked out constraints — add_locked_out_constraints","text":"locked planning units can specified using following formats. Generally, locked data correspond planning units argument x. help make working terra::rast() planning unit data easier, locked data correspond cell indices terra::rast() data. example, integer arguments correspond cell indices logical arguments value cell---regardless planning unit cells contain NA values. data integer vector containing indices indicate planning units locked solution. argument compatible problems contain single zone. data logical vector containing TRUE /FALSE values indicate planning units locked solution. argument compatible problems contain single zone. data matrix object containing logical TRUE /FALSE values indicate certain planning units locked specific zone solution. row corresponds planning unit, column corresponds zone, cell indicates planning unit locked given zone. Thus row contain single TRUE value. data character vector containing column name(s) indicates planning units locked solution. format compatible planning units argument x sf::sf() data.frame object. columns must logical (.e., TRUE FALSE) values indicating planning unit locked solution. problems contain single zone, argument data must contain single column name. Otherwise, problems contain multiple zones, argument data must contain column name zone. data sf::sf() object containing geometries used lock planning units solution. Specifically, planning units x spatially intersect y locked (per intersecting_units()). Note option available problems contain single management zone. data terra::rast() object containing cells used lock planning units solution. Specifically, planning units x intersect cells non-zero non-NA values locked. problems contain multiple zones, data object must contain layer zone. Note multi-band arguments, pixel must contain non-zero value single band. Additionally, cost data x terra::rast() object, recommend standardizing NA values dataset cost data. words, pixels x NA values also NA values locked data.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_locked_out_constraints.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add locked out constraints — add_locked_out_constraints","text":"","code":"# \\dontrun{ # set seed for reproducibility set.seed(500)  # load data sim_pu_polygons <- get_sim_pu_polygons() sim_features <- get_sim_features() sim_locked_out_raster <- get_sim_locked_out_raster() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_pu_polygons <- get_sim_zones_pu_polygons() sim_zones_features <- get_sim_zones_features()  # create minimal problem p1 <-   problem(sim_pu_polygons, sim_features, \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.2) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # create problem with added locked out constraints using integers p2 <- p1 %>% add_locked_out_constraints(which(sim_pu_polygons$locked_out))  # create problem with added locked out constraints using a column name p3 <- p1 %>% add_locked_out_constraints(\"locked_out\")  # create problem with added locked out constraints using raster data p4 <- p1 %>% add_locked_out_constraints(sim_locked_out_raster)  # create problem with added locked out constraints using spatial polygon data locked_out <- sim_pu_polygons[sim_pu_polygons$locked_out == 1, ] p5 <- p1 %>% add_locked_out_constraints(locked_out)  # solve problems s1 <- solve(p1) s2 <- solve(p2) s3 <- solve(p3) s4 <- solve(p4) s5 <- solve(p5)  # create single object with all solutions s6 <- sf::st_sf(   tibble::tibble(     s1 = s1$solution_1,     s2 = s2$solution_1,     s3 = s3$solution_1,     s4 = s4$solution_1,     s5 = s5$solution_1   ),   geometry = sf::st_geometry(s1) )  # plot solutions plot(   s6,   main = c(     \"none locked out\", \"locked out (integer input)\",     \"locked out (character input)\", \"locked out (raster input)\",     \"locked out (polygon input)\"   ) )   # reset plot par(mfrow = c(1, 1))  # create minimal multi-zone problem with spatial data p7 <-   problem(     sim_zones_pu_polygons, sim_zones_features,     cost_column = c(\"cost_1\", \"cost_2\", \"cost_3\")   ) %>%   add_min_set_objective() %>%   add_absolute_targets(matrix(rpois(15, 1), nrow = 5, ncol = 3)) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # create multi-zone problem with locked out constraints using matrix data locked_matrix <- as.matrix(sf::st_drop_geometry(   sim_zones_pu_polygons[, c(\"locked_1\", \"locked_2\", \"locked_3\")] ))  p8 <- p7 %>% add_locked_out_constraints(locked_matrix)  # solve problem s8 <- solve(p8)  # create new column representing the zone id that each planning unit # was allocated to in the solution s8$solution <- category_vector(sf::st_drop_geometry(   s8[, c(\"solution_1_zone_1\", \"solution_1_zone_2\", \"solution_1_zone_3\")] )) s8$solution <- factor(s8$solution)  # plot solution plot(s8[, \"solution\"], main = \"solution\", axes = FALSE)   # create multi-zone problem with locked out constraints using column names p9 <-   p7 %>%   add_locked_out_constraints(c(\"locked_1\", \"locked_2\", \"locked_3\"))  # solve problem s9 <- solve(p9)  # create new column in s8 representing the zone id that each planning unit # was allocated to in the solution s9$solution <- category_vector(sf::st_drop_geometry(   s9[, c(\"solution_1_zone_1\", \"solution_1_zone_2\", \"solution_1_zone_3\")] )) s9$solution[s9$solution == 1 & s9$solution_1_zone_1 == 0] <- 0 s9$solution <- factor(s9$solution)  # plot solution plot(s9[, \"solution\"], main = \"solution\", axes = FALSE)  # create multi-zone problem with raster planning units p10 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_min_set_objective() %>%   add_absolute_targets(matrix(rpois(15, 1), nrow = 5, ncol = 3)) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # create multi-layer raster with locked out units locked_out_raster <- sim_zones_pu_raster[[1]] locked_out_raster[!is.na(locked_out_raster)] <- 0 locked_out_raster <- locked_out_raster[[c(1, 1, 1)]] names(locked_out_raster) <- c(\"zones_1\", \"zones_2\", \"zones_3\") locked_out_raster[[1]][1] <- 1 locked_out_raster[[2]][2] <- 1 locked_out_raster[[3]][3] <- 1  # plot locked out raster plot(locked_out_raster)   # add locked out raster units to problem p10 <- p10 %>% add_locked_out_constraints(locked_out_raster)  # solve problem s10 <- solve(p10)  # plot solution plot(category_layer(s10), main = \"solution\", axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_loglinear_targets.html","id":null,"dir":"Reference","previous_headings":"","what":"Add targets using log-linear scaling — add_loglinear_targets","title":"Add targets using log-linear scaling — add_loglinear_targets","text":"Add targets conservation planning problem log-linearly interpolating targets thresholds based total amount feature study area (Rodrigues et al. 2004). Additionally, caps can applied targets prevent features massive distributions -represented solutions (Butchart et al. 2015).","code":""},{"path":"https://prioritizr.net/reference/add_loglinear_targets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add targets using log-linear scaling — add_loglinear_targets","text":"","code":"add_loglinear_targets(   x,   lower_bound_amount,   lower_bound_target,   upper_bound_amount,   upper_bound_target,   cap_amount = NULL,   cap_target = NULL,   abundances = feature_abundances(x, na.rm = FALSE)$absolute_abundance )"},{"path":"https://prioritizr.net/reference/add_loglinear_targets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add targets using log-linear scaling — add_loglinear_targets","text":"x problem() object. lower_bound_amount numeric threshold. lower_bound_target numeric relative target applied features total amount less equal lower_bound_amount. upper_bound_amount numeric threshold. upper_bound_target numeric relative target applied features total amount greater equal upper_bound_amount. cap_amount numeric total amount targets capped. Defaults NULL targets capped. cap_target numeric amount-based target apply features total amount greater argument cap_amount. Defaults NULL targets capped. abundances numeric total amount feature use calculating targets. Defaults feature abundances study area (calculated using feature_abundances()) function.","code":""},{"path":"https://prioritizr.net/reference/add_loglinear_targets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add targets using log-linear scaling — add_loglinear_targets","text":"updated problem() object targets added .","code":""},{"path":"https://prioritizr.net/reference/add_loglinear_targets.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add targets using log-linear scaling — add_loglinear_targets","text":"Targets used specify minimum amount proportion feature's distribution needs protected. conservation planning problems require adding targets exception maximum cover problem (see add_max_cover_objective()), maximizes features solution therefore require targets. Seven parameters used calculate targets: lower_bound_amount specifies first range size threshold, lower_bound_target specifies relative target required species range size equal less first threshold, upper_bound_amount specifies second range size threshold, upper_bound_target specifies relative target required species range size equal greater second threshold, cap_amount specifies third range size threshold, cap_target specifies absolute target uniformly applied species range size larger third threshold, finally abundances specifies range size feature used calculating targets. target calculations account size planning unit. Therefore, feature data account size planning unit important (e.g., pixel values argument features function problem() correspond amount land occupied feature \\(km^2\\) units). Additionally, function can applied problem() objects associated single zone.","code":""},{"path":"https://prioritizr.net/reference/add_loglinear_targets.html","id":"notes","dir":"Reference","previous_headings":"","what":"Notes","title":"Add targets using log-linear scaling — add_loglinear_targets","text":"Early versions (< 5.0.2.4) used different equations calculating targets.","code":""},{"path":"https://prioritizr.net/reference/add_loglinear_targets.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Add targets using log-linear scaling — add_loglinear_targets","text":"Rodrigues ASL, Akcakaya HR, Andelman SJ, Bakarr MI, Boitani L, Brooks TM, Chanson JS, Fishpool LDC, da Fonseca GAB, Gaston KJ, others (2004) Global gap analysis: priority regions expanding global protected-area network. BioScience, 54: 1092--1100. Butchart SHM, Clarke M, Smith RJ, Sykes RE, Scharlemann JPW, Harfoot M, Buchanan, GM, Angulo , Balmford , Bertzky B, others (2015) Shortfalls solutions meeting national global conservation area targets. Conservation Letters, 8: 329--337.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_loglinear_targets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add targets using log-linear scaling — add_loglinear_targets","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features()  # create problem using loglinear targets p <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_loglinear_targets(10, 0.9, 100, 0.2) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s <- solve(p)  # plot solution plot(s, main = \"solution\", axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_lsymphony_solver.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a SYMPHONY solver with lpsymphony — add_lsymphony_solver","title":"Add a SYMPHONY solver with lpsymphony — add_lsymphony_solver","text":"Specify SYMPHONY software -- using lpsymphony package -- used solve conservation planning problem (Ralphs & Güzelsoy 2005). function can also used customize behavior solver. requires lpsymphony package installed (see installation instructions).","code":""},{"path":"https://prioritizr.net/reference/add_lsymphony_solver.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a SYMPHONY solver with lpsymphony — add_lsymphony_solver","text":"","code":"add_lpsymphony_solver(   x,   gap = 0.1,   time_limit = .Machine$integer.max,   first_feasible = FALSE,   verbose = TRUE )"},{"path":"https://prioritizr.net/reference/add_lsymphony_solver.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a SYMPHONY solver with lpsymphony — add_lsymphony_solver","text":"x problem() object. gap numeric gap optimality. gap relative expresses acceptable deviance optimal objective. example, value 0.01 result solver stopping found solution within 1% optimality. Additionally, value 0 result solver stopping found optimal solution. default value 0.1 (.e., 10% optimality). time_limit numeric time limit (seconds) generating solutions. solver return current best solution time limit exceeded. default value largest integer value (.e., .Machine$integer.max), effectively meaning solver keep running solution within optimality gap found. first_feasible logical first feasible solution returned? first_feasible set TRUE, solver return first solution encounters meets constraints, regardless solution quality. Note first feasible solution arbitrary solution, rather derived relaxed solution, therefore often reasonably close optimality. Defaults FALSE. verbose logical information printed solving optimization problems? Defaults TRUE.","code":""},{"path":"https://prioritizr.net/reference/add_lsymphony_solver.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a SYMPHONY solver with lpsymphony — add_lsymphony_solver","text":"updated problem() object solver added .","code":""},{"path":"https://prioritizr.net/reference/add_lsymphony_solver.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add a SYMPHONY solver with lpsymphony — add_lsymphony_solver","text":"SYMPHONY open-source mixed integer programming solver part Computational Infrastructure Operations Research (COIN-) project. solver provided may easier install systems Rsymphony package. Additionally -- although lpsymphony package provide functionality specify number threads solving problem -- lpsymphony package solve problems using parallel processing (unlike Rsymphony package). consequence, solver likely generate solutions much faster add_rsymphony_solver(). Although formal benchmarks examining performance solver yet completed, please see Schuster et al. (2020) benchmarks comparing run time solution quality Rsymphony solver.","code":""},{"path":"https://prioritizr.net/reference/add_lsymphony_solver.html","id":"installation","dir":"Reference","previous_headings":"","what":"Installation","title":"Add a SYMPHONY solver with lpsymphony — add_lsymphony_solver","text":"lpsymphony package distributed Bioconductor. install lpsymphony package, please use following code:","code":"if (!require(remotes)) install.packages(\"remotes\") remotes::install_bioc(\"lpsymphony\")"},{"path":"https://prioritizr.net/reference/add_lsymphony_solver.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Add a SYMPHONY solver with lpsymphony — add_lsymphony_solver","text":"Ralphs TK Güzelsoy M (2005) SYMPHONY callable library mixed integer programming. Next Wave Computing, Optimization, Decision Technologies (pp. 61--76). Springer, Boston, MA. Schuster R, Hanson JO, Strimas-Mackey M, Bennett JR (2020). Exact integer linear programming solvers outperform simulated annealing solving conservation planning problems. PeerJ, 8: e9258.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_lsymphony_solver.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add a SYMPHONY solver with lpsymphony — add_lsymphony_solver","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features()  # create problem p <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.05) %>%   add_proportion_decisions() %>%   add_lpsymphony_solver(time_limit = 5, verbose = FALSE)  # generate solution s <- solve(p)  # plot solution plot(s, main = \"solution\", axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_mandatory_allocation_constraints.html","id":null,"dir":"Reference","previous_headings":"","what":"Add mandatory allocation constraints — add_mandatory_allocation_constraints","title":"Add mandatory allocation constraints — add_mandatory_allocation_constraints","text":"Add constraints conservation planning problem ensure every planning unit allocated management zone solution. Note function can used problems contain multiple zones.","code":""},{"path":"https://prioritizr.net/reference/add_mandatory_allocation_constraints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add mandatory allocation constraints — add_mandatory_allocation_constraints","text":"","code":"add_mandatory_allocation_constraints(x)"},{"path":"https://prioritizr.net/reference/add_mandatory_allocation_constraints.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add mandatory allocation constraints — add_mandatory_allocation_constraints","text":"x problem() object.","code":""},{"path":"https://prioritizr.net/reference/add_mandatory_allocation_constraints.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add mandatory allocation constraints — add_mandatory_allocation_constraints","text":"updated problem() object constraints added .","code":""},{"path":"https://prioritizr.net/reference/add_mandatory_allocation_constraints.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add mandatory allocation constraints — add_mandatory_allocation_constraints","text":"conservation planning problem() multiple management zones, may sometimes desirable obtain solution assigns every planning unit zone. example, developing land-use plans, decision makers may require every parcel land allocated specific land-use type. words \"left \" areas. Although might seem tempting simply solve problem manually assign \"left \" planning units default zone afterwards (e.g., \"\", \"urban\", \"grazing\" land-use), result highly sub-optimal solutions penalties siting default land-use adjacent zones. Instead, function can used specify planning units problem multiple zones must allocated management zone (.e., zone allocation mandatory).","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_mandatory_allocation_constraints.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add mandatory allocation constraints — add_mandatory_allocation_constraints","text":"","code":"# \\dontrun{ # set seed for reproducibility set.seed(500)  # load data sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_features <- get_sim_zones_features()  # create multi-zone problem with minimum set objective targets_matrix <- matrix(rpois(15, 1), nrow = 5, ncol = 3)  # create minimal problem with minimum set objective p1 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_min_set_objective() %>%   add_absolute_targets(targets_matrix) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # create another problem that is the same as p1, but has constraints # to mandate that every planning unit in the solution is assigned to # zone p2 <- p1 %>% add_mandatory_allocation_constraints()  # solve problems s1 <- solve(p1) s2 <- solve(p2)  # convert solutions into category layers, where each pixel is assigned  # value indicating which zone it was assigned to in the zone c1 <- category_layer(s1) c2 <- category_layer(s2)  # plot solution category layers plot(c(c1, c2), main = c(\"default\", \"mandatory allocation\"), axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_manual_bounded_constraints.html","id":null,"dir":"Reference","previous_headings":"","what":"Add manually specified bound constraints — add_manual_bounded_constraints","title":"Add manually specified bound constraints — add_manual_bounded_constraints","text":"Add constraints conservation planning problem ensure planning unit values (e.g., proportion, binary) solution range specific lower upper bounds. function offers fine-grained control add_manual_locked_constraints() function useful problems involving proportion-type semi-continuous decisions.","code":""},{"path":"https://prioritizr.net/reference/add_manual_bounded_constraints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add manually specified bound constraints — add_manual_bounded_constraints","text":"","code":"add_manual_bounded_constraints(x, data)  # S4 method for ConservationProblem,data.frame add_manual_bounded_constraints(x, data)  # S4 method for ConservationProblem,tbl_df add_manual_bounded_constraints(x, data)"},{"path":"https://prioritizr.net/reference/add_manual_bounded_constraints.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add manually specified bound constraints — add_manual_bounded_constraints","text":"x problem() object. data data.frame tibble::tibble() object. See Data format section information.","code":""},{"path":"https://prioritizr.net/reference/add_manual_bounded_constraints.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add manually specified bound constraints — add_manual_bounded_constraints","text":"updated problem() object constraints added .","code":""},{"path":"https://prioritizr.net/reference/add_manual_bounded_constraints.html","id":"data-format","dir":"Reference","previous_headings":"","what":"Data format","title":"Add manually specified bound constraints — add_manual_bounded_constraints","text":"argument data data.frame following columns: pu integer planning unit identifier. zone character names zones. Note argument optional arguments x contain single zone. lower numeric values indicating minimum value planning unit can allocated zone solution. upper numeric values indicating maximum value planning unit can allocated zone solution.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_manual_bounded_constraints.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add manually specified bound constraints — add_manual_bounded_constraints","text":"","code":"# \\dontrun{ # set seed for reproducibility set.seed(500)  # load data sim_pu_polygons <- get_sim_pu_polygons() sim_features <- get_sim_features() sim_zones_pu_polygons <- get_sim_zones_pu_polygons() sim_zones_features <- get_sim_zones_features()  # create minimal problem p1 <-   problem(sim_pu_polygons, sim_features, \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.2) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # create problem with locked in constraints using add_locked_constraints p2 <- p1 %>% add_locked_in_constraints(\"locked_in\")  # create identical problem using add_manual_bounded_constraints bounds_data <- data.frame(   pu = which(sim_pu_polygons$locked_in),   lower = 1,   upper = 1 )  p3 <- p1 %>% add_manual_bounded_constraints(bounds_data)  # solve problems s1 <- solve(p1) s2 <- solve(p2) s3 <- solve(p3)  # create object with all solutions s4 <- sf::st_sf(   tibble::tibble(     s1 = s1$solution_1,     s2 = s2$solution_1,     s3 = s3$solution_1   ),   geometry = sf::st_geometry(s1) )  # plot solutions ## s1 = none locked in ## s2 = locked in constraints ## s3 = manual bounds constraints plot(s4)   # create minimal problem with multiple zones p5 <-   problem(     sim_zones_pu_polygons, sim_zones_features,     c(\"cost_1\", \"cost_2\", \"cost_3\")   ) %>%   add_min_set_objective() %>%   add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # create data.frame with the following constraints: # planning units 1, 2, and 3 must be allocated to zone 1 in the solution # planning units 4, and 5 must be allocated to zone 2 in the solution # planning units 8 and 9 must not be allocated to zone 3 in the solution bounds_data2 <- data.frame(   pu = c(1, 2, 3, 4, 5, 8, 9),   zone = c(rep(\"zone_1\", 3), rep(\"zone_2\", 2), rep(\"zone_3\", 2)),   lower = c(rep(1, 5), rep(0, 2)),   upper = c(rep(1, 5), rep(0, 2)) )  # print bounds data print(bounds_data2) #>   pu   zone lower upper #> 1  1 zone_1     1     1 #> 2  2 zone_1     1     1 #> 3  3 zone_1     1     1 #> 4  4 zone_2     1     1 #> 5  5 zone_2     1     1 #> 6  8 zone_3     0     0 #> 7  9 zone_3     0     0  # create problem with added constraints p6 <- p5 %>% add_manual_bounded_constraints(bounds_data2)  # solve problem s5 <- solve(p5) s6 <- solve(p6)  # create two new columns representing the zone id that each planning unit # was allocated to in the two solutions s5$solution <- category_vector(sf::st_drop_geometry(   s5[, c(\"solution_1_zone_1\",\"solution_1_zone_2\", \"solution_1_zone_3\")] )) s5$solution <- factor(s5$solution)  s5$solution_bounded <- category_vector(sf::st_drop_geometry(   s6[, c(\"solution_1_zone_1\", \"solution_1_zone_2\", \"solution_1_zone_3\")] )) s5$solution_bounded <- factor(s5$solution_bounded)  # plot solutions plot(s5[, c(\"solution\", \"solution_bounded\")], axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_manual_locked_constraints.html","id":null,"dir":"Reference","previous_headings":"","what":"Add manually specified locked constraints — add_manual_locked_constraints","title":"Add manually specified locked constraints — add_manual_locked_constraints","text":"Add constraints conservation planning problem ensure solutions allocate (allocate) specific planning units specific management zones. function offers fine-grained control add_locked_in_constraints() add_locked_out_constraints() functions.","code":""},{"path":"https://prioritizr.net/reference/add_manual_locked_constraints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add manually specified locked constraints — add_manual_locked_constraints","text":"","code":"add_manual_locked_constraints(x, data)  # S4 method for ConservationProblem,data.frame add_manual_locked_constraints(x, data)  # S4 method for ConservationProblem,tbl_df add_manual_locked_constraints(x, data)"},{"path":"https://prioritizr.net/reference/add_manual_locked_constraints.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add manually specified locked constraints — add_manual_locked_constraints","text":"x problem() object. data data.frame tibble::tibble() object. See Data format section information.","code":""},{"path":"https://prioritizr.net/reference/add_manual_locked_constraints.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add manually specified locked constraints — add_manual_locked_constraints","text":"updated problem() object constraints added .","code":""},{"path":"https://prioritizr.net/reference/add_manual_locked_constraints.html","id":"data-format","dir":"Reference","previous_headings":"","what":"Data format","title":"Add manually specified locked constraints — add_manual_locked_constraints","text":"argument data data.frame following columns: pu integer planning unit identifier. zone character names zones. Note argument optional arguments x contain single zone. status numeric values indicating much planning unit allocated zone solution. example, numeric values binary values (.e., zero one) problems containing binary-type decision variables (using add_binary_decisions() function). Alternatively, numeric values proportions (e.g., 0.5) problems containing proportion-type decision variables (using add_proportion_decisions()).","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_manual_locked_constraints.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add manually specified locked constraints — add_manual_locked_constraints","text":"","code":"# \\dontrun{ # set seed for reproducibility set.seed(500)  # load data sim_pu_polygons <- get_sim_pu_polygons() sim_features <- get_sim_features() sim_zones_pu_polygons <- get_sim_zones_pu_polygons() sim_zones_features <- get_sim_zones_features()  # create minimal problem p1 <-   problem(sim_pu_polygons, sim_features, \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.2) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # create problem with locked in constraints using add_locked_constraints p2 <- p1 %>% add_locked_in_constraints(\"locked_in\")  # create identical problem using add_manual_locked_constraints locked_data <- data.frame(   pu = which(sim_pu_polygons$locked_in),   status = 1 )  p3 <- p1 %>% add_manual_locked_constraints(locked_data)  # solve problems s1 <- solve(p1) s2 <- solve(p2) s3 <- solve(p3)  # create object with all solutions s4 <- sf::st_sf(   tibble::tibble(     s1 = s1$solution_1,     s2 = s2$solution_1,     s3 = s3$solution_1   ),   geometry = sf::st_geometry(s1) )  # plot solutions ## s1 = none locked in ## s2 = locked in constraints ## s3 = manual locked constraints plot(s4)   # create minimal problem with multiple zones p5 <-   problem(     sim_zones_pu_polygons, sim_zones_features,     c(\"cost_1\", \"cost_2\", \"cost_3\")   ) %>%   add_min_set_objective() %>%   add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # create data.frame with the following constraints: # planning units 1, 2, and 3 must be allocated to zone 1 in the solution # planning units 4, and 5 must be allocated to zone 2 in the solution # planning units 8 and 9 must not be allocated to zone 3 in the solution locked_data2 <- data.frame(   pu = c(1, 2, 3, 4, 5, 8, 9),   zone = c(rep(\"zone_1\", 3), rep(\"zone_2\", 2),rep(\"zone_3\", 2)),   status = c(rep(1, 5), rep(0, 2)) )  # print locked constraint data print(locked_data2) #>   pu   zone status #> 1  1 zone_1      1 #> 2  2 zone_1      1 #> 3  3 zone_1      1 #> 4  4 zone_2      1 #> 5  5 zone_2      1 #> 6  8 zone_3      0 #> 7  9 zone_3      0  # create problem with added constraints p6 <- p5 %>% add_manual_locked_constraints(locked_data2)  # solve problem s5 <- solve(p5) s6 <- solve(p6)  # create two new columns representing the zone id that each planning unit # was allocated to in the two solutions s5$solution <- category_vector(sf::st_drop_geometry(   s5[, c(\"solution_1_zone_1\", \"solution_1_zone_2\", \"solution_1_zone_3\")] )) s5$solution <- factor(s5$solution)  s5$solution_locked <- category_vector(sf::st_drop_geometry(   s6[, c(\"solution_1_zone_1\", \"solution_1_zone_2\", \"solution_1_zone_3\")] )) s5$solution_locked <- factor(s5$solution_locked)  # plot solutions plot(s5[, c(\"solution\", \"solution_locked\")], axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_manual_targets.html","id":null,"dir":"Reference","previous_headings":"","what":"Add manual targets — add_manual_targets","title":"Add manual targets — add_manual_targets","text":"Set targets conservation planning problem manually specifying required information target. function useful can used customize aspects target. cases, targets can specified using add_absolute_targets() add_relative_targets() functions. However, function can used () mix absolute relative targets different features zones, (ii) set targets pertain allocations planning units multiple zones, (iii) set targets require different senses (e.g., targets specify solution exceed certain quantity using \"<=\" values).","code":""},{"path":"https://prioritizr.net/reference/add_manual_targets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add manual targets — add_manual_targets","text":"","code":"add_manual_targets(x, targets)  # S4 method for ConservationProblem,data.frame add_manual_targets(x, targets)  # S4 method for ConservationProblem,tbl_df add_manual_targets(x, targets)"},{"path":"https://prioritizr.net/reference/add_manual_targets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add manual targets — add_manual_targets","text":"x problem() object. targets data.frame tibble::tibble() object. See Targets format section information.","code":""},{"path":"https://prioritizr.net/reference/add_manual_targets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add manual targets — add_manual_targets","text":"updated problem() object targets added .","code":""},{"path":"https://prioritizr.net/reference/add_manual_targets.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add manual targets — add_manual_targets","text":"Targets used specify minimum amount proportion feature's distribution needs protected. conservation planning problems require targets exception maximum cover (see add_max_cover_objective()) maximum utility (see add_max_utility_objective()) problems. Attempting solve problems objectives require targets without specifying targets throw error. problems associated multiple management zones, add_absolute_targets() can used set targets pertain single feature single zone. set targets can met allocating different planning units multiple zones, see add_manual_targets() function. example target met allocations multiple zones might management zone expected result different amount feature target requires total amount feature zones must exceed certain threshold. words, target require single zone secure specific amount feature, total amount held zones must secure specific amount. Thus target , potentially, met allocating planning units specific management zone, allocating planning units different combinations management zones.","code":""},{"path":"https://prioritizr.net/reference/add_manual_targets.html","id":"targets-format","dir":"Reference","previous_headings":"","what":"Targets format","title":"Add manual targets — add_manual_targets","text":"targets argument data.frame following columns: feature character name features argument x. zone character name zones argument x. can also list character vectors targets correspond multiple zones (see Examples section ). column optional arguments x contain multiple zones. type character describing type target. Acceptable values include \"absolute\" \"relative\". values correspond add_absolute_targets(), add_relative_targets() respectively. sense character sense target. Acceptable values include: \">=\", \"<=\", \"=\". column optional missing target senses default \">=\" values. target numeric target threshold.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_manual_targets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add manual targets — add_manual_targets","text":"","code":"# \\dontrun{ # set seed for reproducibility set.seed(500)  # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_features <- get_sim_zones_features()  # create problem with 10% relative targets p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s1 <- solve(p1)  # plot solution plot(s1, main = \"solution\", axes = FALSE)  # create equivalent problem using add_manual_targets p2 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_manual_targets(     data.frame(       feature = names(sim_features),       type = \"relative\", sense = \">=\",       target = 0.1     )   ) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s2 <- solve(p2)  # plot solution plot(s2, main = \"solution\", axes = FALSE)   # create problem with targets set for only a few features p3 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_manual_targets(     data.frame(       feature = names(sim_features)[1:3],       type = \"relative\",       sense = \">=\",       target = 0.1     )  ) %>%  add_binary_decisions() %>%  add_default_solver(verbose = FALSE)  # solve problem s3 <- solve(p3)  # plot solution plot(s3, main = \"solution\", axes = FALSE)   # create problem that aims to secure at least 10% of the habitat for one # feature whilst ensuring that the solution does not capture more than # 20 units habitat for different feature # create problem with targets set for only a few features p4 <-   problem(sim_pu_raster, sim_features[[1:2]]) %>%   add_min_set_objective() %>%   add_manual_targets(     data.frame(       feature = names(sim_features)[1:2],       type = \"relative\",       sense = c(\">=\", \"<=\"),       target = c(0.1, 0.2)     )   ) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s4 <- solve(p4)  # plot solution plot(s4, main = \"solution\", axes = FALSE)   # create a multi-zone problem that requires a specific amount of each # feature in each zone targets_matrix <- matrix(rpois(15, 1), nrow = 5, ncol = 3)  p5 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_min_set_objective() %>%   add_absolute_targets(targets_matrix) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s5 <- solve(p5)  # plot solution plot(category_layer(s5), main = \"solution\", axes = FALSE)   # create equivalent problem using add_manual_targets targets_dataframe <- expand.grid(   feature = feature_names(sim_zones_features),   zone = zone_names(sim_zones_features),   sense = \">=\",   type = \"absolute\" ) targets_dataframe$target <- c(targets_matrix)  p6 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_min_set_objective() %>%   add_manual_targets(targets_dataframe) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s6 <- solve(p6)  # plot solution plot(category_layer(s6), main = \"solution\", axes = FALSE)  # create a problem that requires a total of 20 units of habitat to be # captured for two species. This can be achieved through representing # habitat in two zones. The first zone represents a full restoration of the # habitat and a second zone represents a partial restoration of the habitat # Thus only half of the benefit that would have been gained from the full # restoration is obtained when planning units are allocated a partial # restoration  # create data spp_zone1 <- as.list(sim_zones_features)[[1]][[1:2]] spp_zone2 <- spp_zone1 * 0.5 costs <- sim_zones_pu_raster[[1:2]]  # create targets targets_dataframe2 <- tibble::tibble(   feature = names(spp_zone1),   zone = list(c(\"z1\", \"z2\"), c(\"z1\", \"z2\")),   sense = c(\">=\", \">=\"),   type = c(\"absolute\", \"absolute\"),   target = c(20, 20) )  # create problem p7 <-   problem(     costs,     zones(       spp_zone1, spp_zone2,       feature_names = names(spp_zone1), zone_names = c(\"z1\", \"z2\")     )   ) %>%   add_min_set_objective() %>%   add_manual_targets(targets_dataframe2) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s7 <- solve(p7)  # plot solution plot(category_layer(s7), main = \"solution\", axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_max_cover_objective.html","id":null,"dir":"Reference","previous_headings":"","what":"Add maximum coverage objective — add_max_cover_objective","title":"Add maximum coverage objective — add_max_cover_objective","text":"Set objective conservation planning problem represent least one instance many features possible within given budget. objective use targets, feature weights used instead increase representation certain features solution.","code":""},{"path":"https://prioritizr.net/reference/add_max_cover_objective.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add maximum coverage objective — add_max_cover_objective","text":"","code":"add_max_cover_objective(x, budget)"},{"path":"https://prioritizr.net/reference/add_max_cover_objective.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add maximum coverage objective — add_max_cover_objective","text":"x problem() object. budget numeric value specifying maximum expenditure prioritization. problems multiple zones, argument budget can single numeric value specify budget entire solution numeric vector specify budget management zone.","code":""},{"path":"https://prioritizr.net/reference/add_max_cover_objective.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add maximum coverage objective — add_max_cover_objective","text":"updated problem() object objective added .","code":""},{"path":"https://prioritizr.net/reference/add_max_cover_objective.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add maximum coverage objective — add_max_cover_objective","text":"maximum coverage objective seeks find set planning units maximizes number represented features, keeping cost within fixed budget. , features treated represented reserve system contains least single instance feature (.e., amount greater 1). formulation often used conservation planning problems dealing binary biodiversity data indicate presence/absence suitable habitat (e.g., Church & Velle 1974). Additionally, weights can used favor representation certain features features (see add_feature_weights()). Check add_max_features_objective() generalized formulation can accommodate user-specified representation targets.","code":""},{"path":"https://prioritizr.net/reference/add_max_cover_objective.html","id":"mathematical-formulation","dir":"Reference","previous_headings":"","what":"Mathematical formulation","title":"Add maximum coverage objective — add_max_cover_objective","text":"objective based maximum coverage reserve selection problem (Church & Velle 1974; Church et al. 1996). maximum coverage objective reserve design problem can expressed mathematically set planning units (\\(\\) indexed \\(\\)) set features (\\(J\\) indexed \\(j\\)) : $$\\mathit{Maximize} \\space \\sum_{= 1}^{} -s \\space c_i \\space x_i + \\sum_{j = 1}^{J} y_j w_j \\\\ \\mathit{subject \\space } \\\\ \\sum_{= 1}^{} x_i r_{ij} \\geq y_j \\times 1 \\forall j \\J \\\\ \\sum_{= 1}^{} x_i c_i \\leq B$$ , \\(x_i\\) decisions variable (e.g., specifying whether planning unit \\(\\) selected (1) (0)), \\(r_{ij}\\) amount feature \\(j\\) planning unit \\(\\), \\(y_j\\) indicates solution meet target \\(t_j\\) feature \\(j\\), \\(w_j\\) weight feature \\(j\\) (defaults 1 features; see add_feature_weights() specify weights). Additionally, \\(B\\) budget allocated solution, \\(c_i\\) cost planning unit \\(\\), \\(s\\) scaling factor used shrink costs problem return cheapest solution multiple solutions represent amount features within budget.","code":""},{"path":"https://prioritizr.net/reference/add_max_cover_objective.html","id":"notes","dir":"Reference","previous_headings":"","what":"Notes","title":"Add maximum coverage objective — add_max_cover_objective","text":"early versions (< 3.0.0.0), mathematical formulation underpinning function different. Specifically, described , function now follows formulations outlined Church et al. (1996). old formulation now provided add_max_utility_objective() function.","code":""},{"path":"https://prioritizr.net/reference/add_max_cover_objective.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Add maximum coverage objective — add_max_cover_objective","text":"Church RL Velle CR (1974) maximum covering location problem. Regional Science, 32: 101--118. Church RL, Stoms DM, Davis FW (1996) Reserve selection maximum covering location problem. Biological Conservation, 76: 105--112.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_max_cover_objective.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add maximum coverage objective — add_max_cover_objective","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_features <- get_sim_features() sim_zones_features <- get_sim_zones_features()  # threshold the feature data to generate binary biodiversity data sim_binary_features <- sim_features thresholds <- terra::global(   sim_features, fun = quantile, probs = 0.5, na.rm = TRUE ) for (i in seq_len(terra::nlyr(sim_features))) {   sim_binary_features[[i]] <- terra::as.int(     sim_features[[i]] > thresholds[[1]][[i]]   ) }  # create problem with maximum cover objective p1 <-   problem(sim_pu_raster, sim_binary_features) %>%   add_max_cover_objective(500) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s1 <- solve(p1)  # plot solution plot(s1, main = \"solution\", axes = FALSE)   # threshold the multi-zone feature data to generate binary biodiversity data sim_binary_features_zones <- sim_zones_features for (z in seq_len(number_of_zones(sim_zones_features))) {   thresholds <- terra::global(     sim_zones_features[[z]], fun = quantile, probs = 0.5, na.rm = TRUE   )   for (i in seq_len(number_of_features(sim_zones_features))) {     sim_binary_features_zones[[z]][[i]] <- terra::as.int(       sim_zones_features[[z]][[i]] > thresholds[[1]][[i]]     )   } }  # create multi-zone problem with maximum cover objective that # has a single budget for all zones p2 <-   problem(sim_zones_pu_raster, sim_binary_features_zones) %>%   add_max_cover_objective(800) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s2 <- solve(p2)  # plot solution plot(category_layer(s2), main = \"solution\", axes = FALSE)   # create multi-zone problem with maximum cover objective that # has separate budgets for each zone p3 <-   problem(sim_zones_pu_raster, sim_binary_features_zones) %>%   add_max_cover_objective(c(400, 400, 400)) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s3 <- solve(p3)  # plot solution plot(category_layer(s3), main = \"solution\", axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_max_features_objective.html","id":null,"dir":"Reference","previous_headings":"","what":"Add maximum feature representation objective — add_max_features_objective","title":"Add maximum feature representation objective — add_max_features_objective","text":"Set objective conservation planning problem fulfill many targets possible, whilst ensuring cost solution exceed budget.","code":""},{"path":"https://prioritizr.net/reference/add_max_features_objective.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add maximum feature representation objective — add_max_features_objective","text":"","code":"add_max_features_objective(x, budget)"},{"path":"https://prioritizr.net/reference/add_max_features_objective.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add maximum feature representation objective — add_max_features_objective","text":"x problem() object. budget numeric value specifying maximum expenditure prioritization. problems multiple zones, argument budget can () single numeric value specify single budget entire solution (ii) numeric vector specify separate budget management zone.","code":""},{"path":"https://prioritizr.net/reference/add_max_features_objective.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add maximum feature representation objective — add_max_features_objective","text":"updated problem() object objective added .","code":""},{"path":"https://prioritizr.net/reference/add_max_features_objective.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add maximum feature representation objective — add_max_features_objective","text":"maximum feature representation objective enhanced version maximum coverage objective add_max_cover_objective() targets can used ensure certain amount feature required order adequately represented (similar minimum set objective (see add_min_set_objective()). objective finds set planning units meets representation targets many features possible staying within fixed budget (inspired Cabeza Moilanen 2001). Additionally, weights can used add_feature_weights()). multiple solutions can meet number weighted targets staying within budget, cheapest solution returned.","code":""},{"path":"https://prioritizr.net/reference/add_max_features_objective.html","id":"mathematical-formulation","dir":"Reference","previous_headings":"","what":"Mathematical formulation","title":"Add maximum feature representation objective — add_max_features_objective","text":"objective can expressed mathematically set planning units (\\(\\) indexed \\(\\)) set features (\\(J\\) indexed \\(j\\)) : $$\\mathit{Maximize} \\space \\sum_{= 1}^{} -s \\space c_i \\space x_i + \\sum_{j = 1}^{J} y_j w_j \\\\ \\mathit{subject \\space } \\\\ \\sum_{= 1}^{} x_i r_{ij} \\geq y_j t_j \\forall j \\J \\\\ \\sum_{= 1}^{} x_i c_i \\leq B$$ , \\(x_i\\) decisions variable (e.g., specifying whether planning unit \\(\\) selected (1) (0)), \\(r_{ij}\\) amount feature \\(j\\) planning unit \\(\\), \\(t_j\\) representation target feature \\(j\\), \\(y_j\\) indicates solution meet target \\(t_j\\) feature \\(j\\), \\(w_j\\) weight feature \\(j\\) (defaults 1 features; see add_feature_weights() specify weights). Additionally, \\(B\\) budget allocated solution, \\(c_i\\) cost planning unit \\(\\), \\(s\\) scaling factor used shrink costs problem return cheapest solution multiple solutions represent amount features within budget.","code":""},{"path":"https://prioritizr.net/reference/add_max_features_objective.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Add maximum feature representation objective — add_max_features_objective","text":"Cabeza M Moilanen (2001) Design reserve networks persistence biodiversity. Trends Ecology & Evolution, 16: 242--248.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_max_features_objective.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add maximum feature representation objective — add_max_features_objective","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_features <- get_sim_zones_features()  # create problem with maximum features objective p1 <-   problem(sim_pu_raster, sim_features) %>%   add_max_features_objective(1800) %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s1 <- solve(p1)  # plot solution plot(s1, main = \"solution\", axes = FALSE)   # create multi-zone problem with maximum features objective, # with 10% representation targets for each feature, and set # a budget such that the total maximum expenditure in all zones # cannot exceed 3000 p2 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_max_features_objective(3000) %>%   add_relative_targets(matrix(0.1, ncol = 3, nrow = 5)) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s2 <- solve(p2)  # plot solution plot(category_layer(s2), main = \"solution\", axes = FALSE)   # create multi-zone problem with maximum features objective, # with 10% representation targets for each feature, and set # separate budgets for each management zone p3 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_max_features_objective(c(3000, 3000, 3000)) %>%   add_relative_targets(matrix(0.1, ncol = 3, nrow = 5)) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s3 <- solve(p3)  # plot solution plot(category_layer(s3), main = \"solution\", axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_max_phylo_div_objective.html","id":null,"dir":"Reference","previous_headings":"","what":"Add maximum phylogenetic diversity objective — add_max_phylo_div_objective","title":"Add maximum phylogenetic diversity objective — add_max_phylo_div_objective","text":"Set objective conservation planning problem maximize phylogenetic diversity features represented solution subject budget. objective similar add_max_features_objective() except emphasis placed representing phylogenetically diverse set species, rather many features possible (subject weights). function inspired Faith (1992) Rodrigues et al. (2002).","code":""},{"path":"https://prioritizr.net/reference/add_max_phylo_div_objective.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add maximum phylogenetic diversity objective — add_max_phylo_div_objective","text":"","code":"add_max_phylo_div_objective(x, budget, tree)"},{"path":"https://prioritizr.net/reference/add_max_phylo_div_objective.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add maximum phylogenetic diversity objective — add_max_phylo_div_objective","text":"x problem() object. budget numeric value specifying maximum expenditure prioritization. problems multiple zones, argument budget can () single numeric value specify single budget entire solution (ii) numeric vector specify separate budget management zone. tree ape::phylo() object specifying phylogenetic tree conservation features.","code":""},{"path":"https://prioritizr.net/reference/add_max_phylo_div_objective.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add maximum phylogenetic diversity objective — add_max_phylo_div_objective","text":"updated problem() object objective added .","code":""},{"path":"https://prioritizr.net/reference/add_max_phylo_div_objective.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add maximum phylogenetic diversity objective — add_max_phylo_div_objective","text":"maximum phylogenetic diversity objective finds set planning units meets representation targets phylogenetic tree staying within fixed budget. multiple solutions can meet targets staying within budget, cheapest solution chosen. Note objective similar maximum features objective (add_max_features_objective()) allows budget targets set feature. However, unlike maximum feature objective, aim objective maximize total phylogenetic diversity targets met solution, multiple targets provided single feature, problem need meet single target feature phylogenetic benefit feature counted calculating phylogenetic diversity solution. words, multi-zone problems, objective aim maximize phylogenetic diversity zone, rather objective aims maximize phylogenetic diversity targets can met allocating planning units different zones problem. can useful problems targets pertain total amount held feature across multiple zones. example, feature might non-zero amount suitable habitat planning unit planning units assigned () restored, (ii) partially restored, (iii) completely restored management zone. target corresponds single feature can met total amount habitat planning units present three zones.","code":""},{"path":"https://prioritizr.net/reference/add_max_phylo_div_objective.html","id":"mathematical-formulation","dir":"Reference","previous_headings":"","what":"Mathematical formulation","title":"Add maximum phylogenetic diversity objective — add_max_phylo_div_objective","text":"objective can expressed mathematically set planning units (\\(\\) indexed \\(\\)) set features (\\(J\\) indexed \\(j\\)) : $$\\mathit{Maximize} \\space \\sum_{= 1}^{} -s \\space c_i \\space x_i + \\sum_{j = 1}^{J} m_b l_b \\\\ \\mathit{subject \\space } \\\\ \\sum_{= 1}^{} x_i r_{ij} \\geq y_j t_j \\forall j \\J \\\\ m_b \\leq y_j \\forall j \\T(b) \\\\ \\sum_{= 1}^{} x_i c_i \\leq B$$ , \\(x_i\\) decisions variable (e.g., specifying whether planning unit \\(\\) selected (1) (0)), \\(r_{ij}\\) amount feature \\(j\\) planning unit \\(\\), \\(t_j\\) representation target feature \\(j\\), \\(y_j\\) indicates solution meet target \\(t_j\\) feature \\(j\\). Additionally, \\(T\\) represents phylogenetic tree containing features \\(j\\) branches \\(b\\) associated within lengths \\(l_b\\). binary variable \\(m_b\\) denotes least one feature associated branch \\(b\\) met representation indicated \\(y_j\\). brevity, denote features \\(j\\) associated branch \\(b\\) using \\(T(b)\\). Finally, \\(B\\) budget allocated solution, \\(c_i\\) cost planning unit \\(\\), \\(s\\) scaling factor used shrink costs problem return cheapest solution multiple solutions represent amount features within budget.","code":""},{"path":"https://prioritizr.net/reference/add_max_phylo_div_objective.html","id":"notes","dir":"Reference","previous_headings":"","what":"Notes","title":"Add maximum phylogenetic diversity objective — add_max_phylo_div_objective","text":"early versions, function named add_max_phylo_div_objective function.","code":""},{"path":"https://prioritizr.net/reference/add_max_phylo_div_objective.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Add maximum phylogenetic diversity objective — add_max_phylo_div_objective","text":"Faith DP (1992) Conservation evaluation phylogenetic diversity. Biological Conservation, 61: 1--10. Rodrigues ASL Gaston KJ (2002) Maximising phylogenetic diversity selection networks conservation areas. Biological Conservation, 105: 103--111.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_max_phylo_div_objective.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add maximum phylogenetic diversity objective — add_max_phylo_div_objective","text":"","code":"# \\dontrun{ # load ape package require(ape)  # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features() sim_phylogeny <- get_sim_phylogeny() sim_zones_pu_raster  <- get_sim_zones_pu_raster() sim_zones_features  <- get_sim_zones_features()  # plot the simulated phylogeny par(mfrow = c(1, 1)) plot(sim_phylogeny, main = \"phylogeny\")   # create problem with a maximum phylogenetic diversity objective, # where each feature needs 10% of its distribution to be secured for # it to be adequately conserved and a total budget of 1900 p1 <-   problem(sim_pu_raster, sim_features) %>%   add_max_phylo_div_objective(1900, sim_phylogeny) %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s1 <- solve(p1)  # plot solution plot(s1, main = \"solution\", axes = FALSE)   # find out which features have their targets met r1 <- eval_target_coverage_summary(p1, s1) print(r1, width = Inf) #> # A tibble: 5 × 9 #>   feature   met   total_amount absolute_target absolute_held absolute_shortfall #>   <chr>     <lgl>        <dbl>           <dbl>         <dbl>              <dbl> #> 1 feature_1 FALSE         83.3            8.33          7.35              0.975 #> 2 feature_2 TRUE          31.2            3.12          3.13              0     #> 3 feature_3 FALSE         72.0            7.20          5.78              1.42  #> 4 feature_4 TRUE          42.7            4.27          4.50              0     #> 5 feature_5 FALSE         56.7            5.67          5.24              0.431 #>   relative_target relative_held relative_shortfall #>             <dbl>         <dbl>              <dbl> #> 1             0.1        0.0883            0.0117  #> 2             0.1        0.100             0       #> 3             0.1        0.0803            0.0197  #> 4             0.1        0.106             0       #> 5             0.1        0.0924            0.00760  # plot the phylogeny and color the adequately represented features in red plot(   sim_phylogeny, main = \"adequately represented features\",   tip.color = replace(     rep(\"black\", terra::nlyr(sim_features)),     sim_phylogeny$tip.label %in% r1$feature[r1$met], \"red\"   ) )   # rename the features in the example phylogeny for use with the # multi-zone data sim_phylogeny$tip.label <- feature_names(sim_zones_features)  # create targets for a multi-zone problem. Here, each feature needs a total # of 10 units of habitat to be conserved among the three zones to be # considered adequately conserved targets <- tibble::tibble(   feature = feature_names(sim_zones_features),   zone = list(zone_names(sim_zones_features))[     rep(1, number_of_features(sim_zones_features))],   type = rep(\"absolute\", number_of_features(sim_zones_features)),   target = rep(10, number_of_features(sim_zones_features)) )  # create a multi-zone problem with a maximum phylogenetic diversity # objective, where the total expenditure in all zones is 5000. p2 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_max_phylo_div_objective(5000, sim_phylogeny) %>%   add_manual_targets(targets) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s2 <- solve(p2)  # plot solution plot(category_layer(s2), main = \"solution\", axes = FALSE)   # find out which features have their targets met r2 <- eval_target_coverage_summary(p2, s2) print(r2, width = Inf) #> # A tibble: 5 × 11 #>   feature   zone      sense met   total_amount absolute_target absolute_held #>   <chr>     <list>    <chr> <lgl>        <dbl>           <dbl>         <dbl> #> 1 feature_1 <chr [3]> >=    TRUE         250.               10         17.6  #> 2 feature_2 <chr [3]> >=    FALSE         93.6              10          6.66 #> 3 feature_3 <chr [3]> >=    TRUE         216.               10         14.0  #> 4 feature_4 <chr [3]> >=    TRUE         128.               10         10.0  #> 5 feature_5 <chr [3]> >=    TRUE         170.               10         12.4  #>   absolute_shortfall relative_target relative_held relative_shortfall #>                <dbl>           <dbl>         <dbl>              <dbl> #> 1               0             0.0400        0.0706             0      #> 2               3.34          0.107         0.0712             0.0356 #> 3               0             0.0463        0.0646             0      #> 4               0             0.0781        0.0784             0      #> 5               0             0.0588        0.0731             0       # plot the phylogeny and color the adequately represented features in red plot(   sim_phylogeny, main = \"adequately represented features\",   tip.color = replace(     rep(\"black\", terra::nlyr(sim_features)), which(r2$met), \"red\"   ) )   # create a multi-zone problem with a maximum phylogenetic diversity # objective, where each zone has a separate budget. p3 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_max_phylo_div_objective(c(2500, 500, 2000), sim_phylogeny) %>%   add_manual_targets(targets) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s3 <- solve(p3)  # plot solution plot(category_layer(s3), main = \"solution\", axes = FALSE)   # find out which features have their targets met r3 <- eval_target_coverage_summary(p3, s3) print(r3, width = Inf) #> # A tibble: 5 × 11 #>   feature   zone      sense met   total_amount absolute_target absolute_held #>   <chr>     <list>    <chr> <lgl>        <dbl>           <dbl>         <dbl> #> 1 feature_1 <chr [3]> >=    TRUE         250.               10         15.6  #> 2 feature_2 <chr [3]> >=    FALSE         93.6              10          7.23 #> 3 feature_3 <chr [3]> >=    TRUE         216.               10         12.9  #> 4 feature_4 <chr [3]> >=    TRUE         128.               10         10.1  #> 5 feature_5 <chr [3]> >=    TRUE         170.               10         10.8  #>   absolute_shortfall relative_target relative_held relative_shortfall #>                <dbl>           <dbl>         <dbl>              <dbl> #> 1               0             0.0400        0.0624             0      #> 2               2.77          0.107         0.0772             0.0296 #> 3               0             0.0463        0.0598             0      #> 4               0             0.0781        0.0788             0      #> 5               0             0.0588        0.0636             0       # plot the phylogeny and color the adequately represented features in red plot(   sim_phylogeny, main = \"adequately represented features\",   tip.color = replace(     rep(\"black\", terra::nlyr(sim_features)), which(r3$met), \"red\"   ) )  # }"},{"path":"https://prioritizr.net/reference/add_max_phylo_end_objective.html","id":null,"dir":"Reference","previous_headings":"","what":"Add maximum phylogenetic endemism objective — add_max_phylo_end_objective","title":"Add maximum phylogenetic endemism objective — add_max_phylo_end_objective","text":"Set objective conservation planning problem maximize phylogenetic endemism features represented solution subject budget. objective similar add_max_phylo_div_objective() except emphasis placed representing species geographically restricted evolutionary histories, instead representing much evolutionary history possible. function inspired Faith (1992), Rodrigues et al. (2002), Rosauer et al. (2009).","code":""},{"path":"https://prioritizr.net/reference/add_max_phylo_end_objective.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add maximum phylogenetic endemism objective — add_max_phylo_end_objective","text":"","code":"add_max_phylo_end_objective(x, budget, tree)"},{"path":"https://prioritizr.net/reference/add_max_phylo_end_objective.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add maximum phylogenetic endemism objective — add_max_phylo_end_objective","text":"x problem() object. budget numeric value specifying maximum expenditure prioritization. problems multiple zones, argument budget can () single numeric value specify single budget entire solution (ii) numeric vector specify separate budget management zone. tree ape::phylo() object specifying phylogenetic tree conservation features.","code":""},{"path":"https://prioritizr.net/reference/add_max_phylo_end_objective.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add maximum phylogenetic endemism objective — add_max_phylo_end_objective","text":"updated problem() object objective added .","code":""},{"path":"https://prioritizr.net/reference/add_max_phylo_end_objective.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add maximum phylogenetic endemism objective — add_max_phylo_end_objective","text":"maximum phylogenetic endemism objective finds set planning units meets representation targets phylogenetic tree staying within fixed budget. multiple solutions can meet targets staying within budget, cheapest solution chosen. Note objective similar maximum features objective (add_max_features_objective()) allows budget targets set feature. However, unlike maximum feature objective, aim objective maximize total phylogenetic endemism targets met solution, multiple targets provided single feature, problem need meet single target feature phylogenetic benefit feature counted calculating phylogenetic endemism solution. words, multi-zone problems, objective aim maximize phylogenetic endemism zone, rather objective aims maximize phylogenetic endemism targets can met allocating planning units different zones problem. can useful problems targets pertain total amount held feature across multiple zones. example, feature might non-zero amount suitable habitat planning unit planning units assigned () restored, (ii) partially restored, (iii) completely restored management zone. target corresponds single feature can met total amount habitat planning units present three zones.","code":""},{"path":"https://prioritizr.net/reference/add_max_phylo_end_objective.html","id":"mathematical-formulation","dir":"Reference","previous_headings":"","what":"Mathematical formulation","title":"Add maximum phylogenetic endemism objective — add_max_phylo_end_objective","text":"objective can expressed mathematically set planning units (\\(\\) indexed \\(\\)) set features (\\(J\\) indexed \\(j\\)) : $$\\mathit{Maximize} \\space \\sum_{= 1}^{} -s \\space c_i \\space x_i + \\sum_{j = 1}^{J} m_b l_b \\frac{1}{a_b} \\\\ \\mathit{subject \\space } \\\\ \\sum_{= 1}^{} x_i r_{ij} \\geq y_j t_j \\forall j \\J \\\\ m_b \\leq y_j \\forall j \\T(b) \\\\ \\sum_{= 1}^{} x_i c_i \\leq B$$ , \\(x_i\\) decisions variable (e.g., specifying whether planning unit \\(\\) selected (1) (0)), \\(r_{ij}\\) amount feature \\(j\\) planning unit \\(\\), \\(t_j\\) representation target feature \\(j\\), \\(y_j\\) indicates solution meet target \\(t_j\\) feature \\(j\\). Additionally, \\(T\\) represents phylogenetic tree containing features \\(j\\) branches \\(b\\) associated within lengths \\(l_b\\). branch \\(b \\B\\) associated total amount \\(a_b\\) indicating total geographic extent amount habitat. \\(a_b\\) variable given branch calculated summing \\(r_{ij}\\) data features \\(j \\J\\) associated branch. binary variable \\(m_b\\) denotes least one feature associated branch \\(b\\) met representation indicated \\(y_j\\). brevity, denote features \\(j\\) associated branch \\(b\\) using \\(T(b)\\). Finally, \\(B\\) budget allocated solution, \\(c_i\\) cost planning unit \\(\\), \\(s\\) scaling factor used shrink costs problem return cheapest solution multiple solutions represent amount features within budget.","code":""},{"path":"https://prioritizr.net/reference/add_max_phylo_end_objective.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Add maximum phylogenetic endemism objective — add_max_phylo_end_objective","text":"Faith DP (1992) Conservation evaluation phylogenetic diversity. Biological Conservation, 61: 1--10. Rodrigues ASL Gaston KJ (2002) Maximising phylogenetic diversity selection networks conservation areas. Biological Conservation, 105: 103--111. Rosauer D, Laffan SW, Crisp, MD, Donnellan SC Cook LG (2009) Phylogenetic endemism: new approach identifying geographical concentrations evolutionary history. Molecular Ecology, 18: 4061--4072.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_max_phylo_end_objective.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add maximum phylogenetic endemism objective — add_max_phylo_end_objective","text":"","code":"# \\dontrun{ # load ape package require(ape)  # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features() sim_phylogeny <- get_sim_phylogeny() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_features <- get_sim_zones_features()  # plot the simulated phylogeny par(mfrow = c(1, 1)) plot(sim_phylogeny, main = \"phylogeny\")   # create problem with a maximum phylogenetic endemism objective, # where each feature needs 10% of its distribution to be secured for # it to be adequately conserved and a total budget of 1900 p1 <-   problem(sim_pu_raster, sim_features) %>%   add_max_phylo_end_objective(1900, sim_phylogeny) %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s1 <- solve(p1)  # plot solution plot(s1, main = \"solution\", axes = FALSE)   # find out which features have their targets met r1 <- eval_target_coverage_summary(p1, s1) print(r1, width = Inf) #> # A tibble: 5 × 9 #>   feature   met   total_amount absolute_target absolute_held absolute_shortfall #>   <chr>     <lgl>        <dbl>           <dbl>         <dbl>              <dbl> #> 1 feature_1 FALSE         83.3            8.33          7.71              0.618 #> 2 feature_2 FALSE         31.2            3.12          2.35              0.775 #> 3 feature_3 FALSE         72.0            7.20          5.81              1.38  #> 4 feature_4 TRUE          42.7            4.27          4.28              0     #> 5 feature_5 TRUE          56.7            5.67          5.77              0     #>   relative_target relative_held relative_shortfall #>             <dbl>         <dbl>              <dbl> #> 1             0.1        0.0926            0.00742 #> 2             0.1        0.0752            0.0248  #> 3             0.1        0.0808            0.0192  #> 4             0.1        0.100             0       #> 5             0.1        0.102             0        # plot the phylogeny and color the adequately represented features in red plot(   sim_phylogeny, main = \"adequately represented features\",   tip.color = replace(     rep(\"black\", terra::nlyr(sim_features)),     sim_phylogeny$tip.label %in% r1$feature[r1$met],     \"red\"   ) )   # rename the features in the example phylogeny for use with the # multi-zone data sim_phylogeny$tip.label <- feature_names(sim_zones_features)  # create targets for a multi-zone problem. Here, each feature needs a total # of 10 units of habitat to be conserved among the three zones to be # considered adequately conserved targets <- tibble::tibble(   feature = feature_names(sim_zones_features),   zone = list(zone_names(sim_zones_features))[     rep(1, number_of_features(sim_zones_features))],   type = rep(\"absolute\", number_of_features(sim_zones_features)),   target = rep(10, number_of_features(sim_zones_features)) )  # create a multi-zone problem with a maximum phylogenetic endemism # objective, where the total expenditure in all zones is 5000. p2 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_max_phylo_end_objective(5000, sim_phylogeny) %>%   add_manual_targets(targets) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s2 <- solve(p2)  # plot solution plot(category_layer(s2), main = \"solution\", axes = FALSE)   # find out which features have their targets met r2 <- eval_target_coverage_summary(p2, s2) print(r2, width = Inf) #> # A tibble: 5 × 11 #>   feature   zone      sense met   total_amount absolute_target absolute_held #>   <chr>     <list>    <chr> <lgl>        <dbl>           <dbl>         <dbl> #> 1 feature_1 <chr [3]> >=    TRUE         250.               10         19.6  #> 2 feature_2 <chr [3]> >=    FALSE         93.6              10          6.72 #> 3 feature_3 <chr [3]> >=    TRUE         216.               10         16.3  #> 4 feature_4 <chr [3]> >=    TRUE         128.               10         10.0  #> 5 feature_5 <chr [3]> >=    TRUE         170.               10         13.7  #>   absolute_shortfall relative_target relative_held relative_shortfall #>                <dbl>           <dbl>         <dbl>              <dbl> #> 1               0             0.0400        0.0786             0      #> 2               3.28          0.107         0.0717             0.0351 #> 3               0             0.0463        0.0753             0      #> 4               0             0.0781        0.0782             0      #> 5               0             0.0588        0.0807             0       # plot the phylogeny and color the adequately represented features in red plot(   sim_phylogeny, main = \"adequately represented features\",   tip.color = replace(     rep(\"black\", terra::nlyr(sim_features)), which(r2$met), \"red\"   ) )   # create a multi-zone problem with a maximum phylogenetic endemism # objective, where each zone has a separate budget. p3 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_max_phylo_end_objective(c(2500, 500, 2000), sim_phylogeny) %>%   add_manual_targets(targets) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s3 <- solve(p3)  # plot solution plot(category_layer(s3), main = \"solution\", axes = FALSE)   # find out which features have their targets met r3 <- eval_target_coverage_summary(p3, s3) print(r3, width = Inf) #> # A tibble: 5 × 11 #>   feature   zone      sense met   total_amount absolute_target absolute_held #>   <chr>     <list>    <chr> <lgl>        <dbl>           <dbl>         <dbl> #> 1 feature_1 <chr [3]> >=    TRUE         250.               10         15.7  #> 2 feature_2 <chr [3]> >=    FALSE         93.6              10          5.73 #> 3 feature_3 <chr [3]> >=    TRUE         216.               10         12.1  #> 4 feature_4 <chr [3]> >=    TRUE         128.               10         10.0  #> 5 feature_5 <chr [3]> >=    TRUE         170.               10         11.4  #>   absolute_shortfall relative_target relative_held relative_shortfall #>                <dbl>           <dbl>         <dbl>              <dbl> #> 1               0             0.0400        0.0628             0      #> 2               4.27          0.107         0.0612             0.0456 #> 3               0             0.0463        0.0559             0      #> 4               0             0.0781        0.0782             0      #> 5               0             0.0588        0.0669             0       # plot the phylogeny and color the adequately represented features in red plot(   sim_phylogeny, main = \"adequately represented features\",   tip.color = replace(     rep(\"black\", terra::nlyr(sim_features)), which(r3$met), \"red\"   ) )  # }"},{"path":"https://prioritizr.net/reference/add_max_utility_objective.html","id":null,"dir":"Reference","previous_headings":"","what":"Add maximum utility objective — add_max_utility_objective","title":"Add maximum utility objective — add_max_utility_objective","text":"Set objective conservation planning problem secure much features possible without exceeding budget. objective use targets, feature weights used instead increase representation certain features solution. Note objective aim maximize much feature possible, often results solutions heavily biased towards just features.","code":""},{"path":"https://prioritizr.net/reference/add_max_utility_objective.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add maximum utility objective — add_max_utility_objective","text":"","code":"add_max_utility_objective(x, budget)"},{"path":"https://prioritizr.net/reference/add_max_utility_objective.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add maximum utility objective — add_max_utility_objective","text":"x problem() object. budget numeric value specifying maximum expenditure prioritization. problems multiple zones, argument budget can () single numeric value specify single budget entire solution (ii) numeric vector specify separate budget management zone.","code":""},{"path":"https://prioritizr.net/reference/add_max_utility_objective.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add maximum utility objective — add_max_utility_objective","text":"updated problem() object objective added .","code":""},{"path":"https://prioritizr.net/reference/add_max_utility_objective.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add maximum utility objective — add_max_utility_objective","text":"maximum utility objective seeks maximize overall level representation across suite conservation features, keeping cost within fixed budget. Additionally, weights can used favor representation certain features features (see add_feature_weights()). essentially calculated weighted sum feature data inside selected planning units.","code":""},{"path":"https://prioritizr.net/reference/add_max_utility_objective.html","id":"mathematical-formulation","dir":"Reference","previous_headings":"","what":"Mathematical formulation","title":"Add maximum utility objective — add_max_utility_objective","text":"objective can expressed mathematically set planning units (\\(\\) indexed \\(\\)) set features (\\(J\\) indexed \\(j\\)) : $$\\mathit{Maximize} \\space \\sum_{= 1}^{} -s \\space c_i \\space x_i + \\sum_{j = 1}^{J} a_j w_j \\\\ \\mathit{subject \\space } \\\\ a_j = \\sum_{= 1}^{} x_i r_{ij} \\space \\forall j \\J \\\\ \\sum_{= 1}^{} x_i c_i \\leq B$$ , \\(x_i\\) decisions variable (e.g., specifying whether planning unit \\(\\) selected (1) (0)), \\(r_{ij}\\) amount feature \\(j\\) planning unit \\(\\), \\(A_j\\) amount feature \\(j\\) represented solution, \\(w_j\\) weight feature \\(j\\) (defaults 1 features; see add_feature_weights() specify weights). Additionally, \\(B\\) budget allocated solution, \\(c_i\\) cost planning unit \\(\\), \\(s\\) scaling factor used shrink costs problem return cheapest solution multiple solutions represent amount features within budget.","code":""},{"path":"https://prioritizr.net/reference/add_max_utility_objective.html","id":"notes","dir":"Reference","previous_headings":"","what":"Notes","title":"Add maximum utility objective — add_max_utility_objective","text":"early versions (< 3.0.0.0), function named add_max_cover_objective function. renamed avoid confusion existing terminology.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_max_utility_objective.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add maximum utility objective — add_max_utility_objective","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_features <- get_sim_zones_features()  # create problem with maximum utility objective p1 <-   problem(sim_pu_raster, sim_features) %>%   add_max_utility_objective(5000) %>%   add_binary_decisions() %>%   add_default_solver(gap = 0, verbose = FALSE)  # solve problem s1 <- solve(p1)  # plot solution plot(s1, main = \"solution\", axes = FALSE)   # create multi-zone problem with maximum utility objective that # has a single budget for all zones p2 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_max_utility_objective(5000) %>%   add_binary_decisions() %>%   add_default_solver(gap = 0, verbose = FALSE)  # solve problem s2 <- solve(p2)  # plot solution plot(category_layer(s2), main = \"solution\", axes = FALSE)   # create multi-zone problem with maximum utility objective that # has separate budgets for each zone p3 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_max_utility_objective(c(1000, 2000, 3000)) %>%   add_binary_decisions() %>%   add_default_solver(gap = 0, verbose = FALSE)  # solve problem s3 <- solve(p3)  # plot solution plot(category_layer(s3), main = \"solution\", axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_min_largest_shortfall_objective.html","id":null,"dir":"Reference","previous_headings":"","what":"Add minimum largest shortfall objective — add_min_largest_shortfall_objective","title":"Add minimum largest shortfall objective — add_min_largest_shortfall_objective","text":"Set objective conservation planning problem minimize largest target shortfall ensuring cost solution exceed budget. Note target shortfall single feature decreased beyond certain point (e.g., remaining planning units occupied feature costly locked ), solutions may use small proportion specified budget.","code":""},{"path":"https://prioritizr.net/reference/add_min_largest_shortfall_objective.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add minimum largest shortfall objective — add_min_largest_shortfall_objective","text":"","code":"add_min_largest_shortfall_objective(x, budget)"},{"path":"https://prioritizr.net/reference/add_min_largest_shortfall_objective.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add minimum largest shortfall objective — add_min_largest_shortfall_objective","text":"x problem() object. budget numeric value specifying maximum expenditure prioritization. problems multiple zones, argument budget can () single numeric value specify single budget entire solution (ii) numeric vector specify separate budget management zone.","code":""},{"path":"https://prioritizr.net/reference/add_min_largest_shortfall_objective.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add minimum largest shortfall objective — add_min_largest_shortfall_objective","text":"updated problem() object objective added .","code":""},{"path":"https://prioritizr.net/reference/add_min_largest_shortfall_objective.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add minimum largest shortfall objective — add_min_largest_shortfall_objective","text":"minimum largest shortfall objective aims find set planning units minimize largest shortfall representation targets---, fraction target remains unmet---many features possible staying within fixed budget. objective different minimum shortfall objective (add_min_shortfall_objective()) objective minimizes largest (maximum) target shortfall, whereas minimum shortfall objective minimizes total (weighted sum) target shortfalls. Note objective function compatible feature weights (add_feature_weights()).","code":""},{"path":"https://prioritizr.net/reference/add_min_largest_shortfall_objective.html","id":"mathematical-formulation","dir":"Reference","previous_headings":"","what":"Mathematical formulation","title":"Add minimum largest shortfall objective — add_min_largest_shortfall_objective","text":"objective can expressed mathematically set planning units (\\(\\) indexed \\(\\)) set features (\\(J\\) indexed \\(j\\)) : $$\\mathit{Minimize} \\space l \\\\ \\mathit{subject \\space } \\\\ \\sum_{= 1}^{} x_i r_{ij} + y_j \\geq t_j \\forall j \\J \\\\ l \\geq \\frac{y_j}{t_j} \\forall j \\J \\\\ \\sum_{= 1}^{} x_i c_i \\leq B$$ , \\(x_i\\) decisions variable (e.g., specifying whether planning unit \\(\\) selected (1) (0)), \\(r_{ij}\\) amount feature \\(j\\) planning unit \\(\\), \\(t_j\\) representation target feature \\(j\\). Additionally, \\(y_j\\) denotes target shortfall target \\(t_j\\) feature \\(j\\), \\(l\\) denotes largest target shortfall. Furthermore, \\(B\\) budget allocated solution, \\(c_i\\) cost planning unit \\(\\). Note \\(y_j\\) \\(s\\) continuous variables bounded zero infinity.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_min_largest_shortfall_objective.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add minimum largest shortfall objective — add_min_largest_shortfall_objective","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_features <- get_sim_zones_features()  # create problem with minimum largest shortfall objective p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_largest_shortfall_objective(1800) %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s1 <- solve(p1)  # plot solution plot(s1, main = \"solution\", axes = FALSE)   # create multi-zone problem with minimum largest shortfall objective, # with 10% representation targets for each feature, and set # a budget such that the total maximum expenditure in all zones # cannot exceed 1800 p2 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_min_largest_shortfall_objective(1800) %>%   add_relative_targets(matrix(0.1, ncol = 3, nrow = 5)) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s2 <- solve(p2)  # plot solution plot(category_layer(s2), main = \"solution\", axes = FALSE)   # create multi-zone problem with minimum largest shortfall objective, # with 10% representation targets for each feature, and set # separate budgets of 1800 for each management zone p3 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_min_largest_shortfall_objective(c(1800, 1800, 1800)) %>%   add_relative_targets(matrix(0.1, ncol = 3, nrow = 5)) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s3 <- solve(p3)  # plot solution plot(category_layer(s3), main = \"solution\", axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_min_set_objective.html","id":null,"dir":"Reference","previous_headings":"","what":"Add minimum set objective — add_min_set_objective","title":"Add minimum set objective — add_min_set_objective","text":"Set objective conservation planning problem minimize cost solution whilst ensuring targets met. objective similar used Marxan detailed Rodrigues et al. (2000).","code":""},{"path":"https://prioritizr.net/reference/add_min_set_objective.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add minimum set objective — add_min_set_objective","text":"","code":"add_min_set_objective(x)"},{"path":"https://prioritizr.net/reference/add_min_set_objective.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add minimum set objective — add_min_set_objective","text":"x problem() object.","code":""},{"path":"https://prioritizr.net/reference/add_min_set_objective.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add minimum set objective — add_min_set_objective","text":"updated problem() object objective added .","code":""},{"path":"https://prioritizr.net/reference/add_min_set_objective.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add minimum set objective — add_min_set_objective","text":"minimum set objective -- context systematic reserve design --  seeks find set planning units minimizes overall cost reserve network, meeting set representation targets conservation features. objective equivalent simplified Marxan reserve design problem Boundary Length Modifier (BLM) set zero. difference objective Marxan software targets features always met (use Species Penalty Factors).","code":""},{"path":"https://prioritizr.net/reference/add_min_set_objective.html","id":"mathematical-formulation","dir":"Reference","previous_headings":"","what":"Mathematical formulation","title":"Add minimum set objective — add_min_set_objective","text":"objective can expressed mathematically set planning units (\\(\\) indexed \\(\\)) set features (\\(J\\) indexed \\(j\\)) : $$\\mathit{Minimize} \\space \\sum_{= 1}^{} x_i c_i \\\\ \\mathit{subject \\space } \\\\ \\sum_{= 1}^{} x_i r_{ij} \\geq T_j \\space \\forall \\space j \\J$$ , \\(x_i\\) decisions variable (e.g., specifying whether planning unit \\(\\) selected (1) (0)), \\(c_i\\) cost planning unit \\(\\), \\(r_{ij}\\) amount feature \\(j\\) planning unit \\(\\), \\(T_j\\) target feature \\(j\\). first term objective function second set constraints. words says find set planning units meets representation targets minimizing overall cost.","code":""},{"path":"https://prioritizr.net/reference/add_min_set_objective.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Add minimum set objective — add_min_set_objective","text":"Rodrigues , Cerdeira OJ, Gaston KJ (2000) Flexibility, efficiency, accountability: adapting reserve selection algorithms complex conservation problems. Ecography, 23: 565--574.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_min_set_objective.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add minimum set objective — add_min_set_objective","text":"","code":"# \\dontrun{ # set seed for reproducibility set.seed(500)  # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_features <- get_sim_zones_features()  # create minimal problem with minimum set objective p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s1 <- solve(p1)  # plot solution plot(s1, main = \"solution\", axes = FALSE)   # create multi-zone problem with minimum set objective targets_matrix <- matrix(rpois(15, 1), nrow = 5, ncol = 3)  p2 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_min_set_objective() %>%   add_absolute_targets(targets_matrix) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s2 <- solve(p2)  # plot solution plot(category_layer(s2), main = \"solution\", axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_min_shortfall_objective.html","id":null,"dir":"Reference","previous_headings":"","what":"Add minimum shortfall objective — add_min_shortfall_objective","title":"Add minimum shortfall objective — add_min_shortfall_objective","text":"Set objective conservation planning problem minimize overall shortfall many targets possible ensuring cost solution exceed budget.","code":""},{"path":"https://prioritizr.net/reference/add_min_shortfall_objective.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add minimum shortfall objective — add_min_shortfall_objective","text":"","code":"add_min_shortfall_objective(x, budget)"},{"path":"https://prioritizr.net/reference/add_min_shortfall_objective.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add minimum shortfall objective — add_min_shortfall_objective","text":"x problem() object. budget numeric value specifying maximum expenditure prioritization. problems multiple zones, argument budget can () single numeric value specify single budget entire solution (ii) numeric vector specify separate budget management zone.","code":""},{"path":"https://prioritizr.net/reference/add_min_shortfall_objective.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add minimum shortfall objective — add_min_shortfall_objective","text":"updated problem() object objective added .","code":""},{"path":"https://prioritizr.net/reference/add_min_shortfall_objective.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add minimum shortfall objective — add_min_shortfall_objective","text":"minimum shortfall objective aims find set planning units minimize overall (weighted sum) shortfall representation targets---, fraction target remains unmet---many features possible staying within fixed budget (inspired Table 1, equation IV, Arponen et al. 2005). Additionally, weights can used favor representation certain features features (see add_feature_weights().","code":""},{"path":"https://prioritizr.net/reference/add_min_shortfall_objective.html","id":"mathematical-formulation","dir":"Reference","previous_headings":"","what":"Mathematical formulation","title":"Add minimum shortfall objective — add_min_shortfall_objective","text":"objective can expressed mathematically set planning units (\\(\\) indexed \\(\\)) set features (\\(J\\) indexed \\(j\\)) : $$\\mathit{Minimize} \\space  \\sum_{j = 1}^{J} w_j \\frac{y_j}{t_j} \\\\ \\mathit{subject \\space } \\\\ \\sum_{= 1}^{} x_i r_{ij} + y_j \\geq t_j \\forall j \\J \\\\ \\sum_{= 1}^{} x_i c_i \\leq B$$ , \\(x_i\\) decisions variable (e.g., specifying whether planning unit \\(\\) selected (1) (0)), \\(r_{ij}\\) amount feature \\(j\\) planning unit \\(\\), \\(t_j\\) representation target feature \\(j\\), \\(y_j\\) denotes representation shortfall target \\(t_j\\) feature \\(j\\), \\(w_j\\) weight feature \\(j\\) (defaults 1 features; see add_feature_weights() specify weights). Additionally, \\(B\\) budget allocated solution, \\(c_i\\) cost planning unit \\(\\). Note \\(y_j\\) continuous variable bounded zero infinity, denotes shortfall target \\(j\\).","code":""},{"path":"https://prioritizr.net/reference/add_min_shortfall_objective.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Add minimum shortfall objective — add_min_shortfall_objective","text":"Arponen , Heikkinen RK, Thomas CD, Moilanen (2005) value biodiversity reserve selection: representation, species weighting, benefit functions. Conservation Biology, 19: 2009--2014.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_min_shortfall_objective.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add minimum shortfall objective — add_min_shortfall_objective","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_features <- get_sim_zones_features()  # create problem with minimum shortfall objective p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_shortfall_objective(1800) %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s1 <- solve(p1)  # plot solution plot(s1, main = \"solution\", axes = FALSE)   # create multi-zone problem with minimum shortfall objective, # with 10% representation targets for each feature, and set # a budget such that the total maximum expenditure in all zones # cannot exceed 3000 p2 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_min_shortfall_objective(3000) %>%   add_relative_targets(matrix(0.1, ncol = 3, nrow = 5)) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s2 <- solve(p2)  # plot solution plot(category_layer(s2), main = \"solution\", axes = FALSE)   # create multi-zone problem with minimum shortfall objective, # with 10% representation targets for each feature, and set # separate budgets for each management zone p3 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_min_shortfall_objective(c(3000, 3000, 3000)) %>%   add_relative_targets(matrix(0.1, ncol = 3, nrow = 5)) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s3 <- solve(p3)  # plot solution plot(category_layer(s3), main = \"solution\", axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_neighbor_constraints.html","id":null,"dir":"Reference","previous_headings":"","what":"Add neighbor constraints — add_neighbor_constraints","title":"Add neighbor constraints — add_neighbor_constraints","text":"Add constraints conservation planning problem ensure selected planning units solution least certain number neighbors also selected solution.","code":""},{"path":"https://prioritizr.net/reference/add_neighbor_constraints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add neighbor constraints — add_neighbor_constraints","text":"","code":"# S4 method for ConservationProblem,ANY,ANY,ANY,ANY add_neighbor_constraints(x, k, clamp, zones, data)  # S4 method for ConservationProblem,ANY,ANY,ANY,data.frame add_neighbor_constraints(x, k, clamp, zones, data)  # S4 method for ConservationProblem,ANY,ANY,ANY,matrix add_neighbor_constraints(x, k, clamp, zones, data)  # S4 method for ConservationProblem,ANY,ANY,ANY,array add_neighbor_constraints(x, k, clamp, zones, data)"},{"path":"https://prioritizr.net/reference/add_neighbor_constraints.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add neighbor constraints — add_neighbor_constraints","text":"x problem() object. k integer minimum number neighbors selected planning units solution. problems multiple zones, argument k must element zone. clamp logical minimum number neighbors selected planning units solution clamped feasibility? example, planning unit two neighbors, k = 3, clamp = FALSE, planning unit ever selected solution. However, clamp = TRUE, planning unit potentially selected solution two neighbors also selected. Defaults TRUE. zones matrix Matrix object describing neighborhood scheme different zones. row column corresponds different zone argument x, cell values must contain binary numeric values (.e., one zero) indicate neighboring planning units (specified argument data) considered neighbors allocated different zones. cell values along diagonal matrix indicate planning units allocated zone considered neighbors . default argument zones identity matrix (.e., matrix ones along matrix diagonal zeros elsewhere), planning units considered neighbors allocated zone. data NULL, matrix, Matrix, data.frame, array object showing planning units neighbors . argument defaults NULL means neighborhood data calculated automatically using adjacency_matrix() function. See Data format section information.","code":""},{"path":"https://prioritizr.net/reference/add_neighbor_constraints.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add neighbor constraints — add_neighbor_constraints","text":"updated problem() object constraints added .","code":""},{"path":"https://prioritizr.net/reference/add_neighbor_constraints.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add neighbor constraints — add_neighbor_constraints","text":"function uses neighborhood data identify solutions surround planning units minimum number neighbors. inspired mathematical formulations detailed Billionnet (2013) Beyer et al. (2016).","code":""},{"path":"https://prioritizr.net/reference/add_neighbor_constraints.html","id":"data-format","dir":"Reference","previous_headings":"","what":"Data format","title":"Add neighbor constraints — add_neighbor_constraints","text":"argument data can specified using following formats: data NULL value neighborhood data calculated automatically using adjacency_matrix() function. default argument. Note neighborhood data must manually defined using one formats planning unit data argument x spatially referenced (e.g., data.frame numeric format). data matrix/Matrix object rows columns represent different planning units value cell indicates two planning units neighbors . Cell values binary numeric values (.e., one zero). Cells occur along matrix diagonal effect solution planning unit neighbor . data data.frame object containing columns named \"id1\", \"id2\", \"boundary\". , row denotes connectivity two planning units following Marxan format. \"boundary\" column contain binary numeric values indicate two planning units specified \"id1\" \"id2\" columns neighbors . data can used describe symmetric asymmetric relationships planning units. default, input data assumed symmetric unless asymmetric data also included (e.g., data present planning units 2 3, amount connectivity expected planning units 3 2, unless connectivity data also provided planning units 3 2). argument x contains multiple zones, \"zone1\" \"zone2\" columns can optionally provided manually specify neighborhood data pertain specific zones. \"zone1\" \"zone2\" columns contain character names zones. columns \"zone1\" \"zone2\" present, argument zones must NULL. data array object containing four-dimensions binary numeric values indicate planning unit treated neighbors every planning unit allocated every combination management zone. first two dimensions (.e., rows columns) correspond planning units, second two dimensions correspond management zones. example, argument data value 1 index data[1, 2, 3, 4] indicate planning unit 1 planning unit 2 treated neighbors allocated zones 3 4 respectively.","code":""},{"path":"https://prioritizr.net/reference/add_neighbor_constraints.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Add neighbor constraints — add_neighbor_constraints","text":"Beyer HL, Dujardin Y, Watts , Possingham HP (2016) Solving conservation planning problems integer linear programming. Ecological Modelling, 228: 14--22. Billionnet (2013) Mathematical optimization ideas biodiversity conservation. European Journal Operational Research, 231: 514--534.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_neighbor_constraints.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add neighbor constraints — add_neighbor_constraints","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_features <- get_sim_zones_features()  # create minimal problem p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_default_solver(verbose = FALSE)  # create problem with constraints that require 1 neighbor # and neighbors are defined using a rook-style neighborhood p2 <- p1 %>% add_neighbor_constraints(1)  # create problem with constraints that require 2 neighbor # and neighbors are defined using a rook-style neighborhood p3 <- p1 %>% add_neighbor_constraints(2)  # create problem with constraints that require 3 neighbor # and neighbors are defined using a queen-style neighborhood p4 <-   p1 %>%   add_neighbor_constraints(     3, data = adjacency_matrix(sim_pu_raster, directions = 8)   )  # solve problems s1 <- terra::rast(list(solve(p1), solve(p2), solve(p3), solve(p4))) names(s1) <- c(\"basic solution\", \"1 neighbor\", \"2 neighbors\", \"3 neighbors\")  # plot solutions plot(s1, axes = FALSE)   # create minimal problem with multiple zones p5 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_min_set_objective() %>%   add_relative_targets(matrix(0.1, ncol = 3, nrow = 5)) %>%   add_default_solver(verbose = FALSE)  # create problem where selected planning units require at least 2 neighbors # for each zone and planning units are only considered neighbors if they # are allocated to the same zone z6 <- diag(3) print(z6) #>      [,1] [,2] [,3] #> [1,]    1    0    0 #> [2,]    0    1    0 #> [3,]    0    0    1 p6 <- p5 %>% add_neighbor_constraints(rep(2, 3), zones = z6)  # create problem where the planning units in zone 1 don't explicitly require # any neighbors, planning units in zone 2 require at least 1 neighbors, and # planning units in zone 3 require at least 2 neighbors. As before, planning # units are still only considered neighbors if they are allocated to the # same zone p7 <- p5 %>% add_neighbor_constraints(c(0, 1, 2), zones = z6)  # create problem given the same constraints as outlined above, except # that when determining which selected planning units are neighbors, # planning units that are allocated to zone 1 and zone 2 can also treated # as being neighbors with each other z8 <- diag(3) z8[1, 2] <- 1 z8[2, 1] <- 1 print(z8) #>      [,1] [,2] [,3] #> [1,]    1    1    0 #> [2,]    1    1    0 #> [3,]    0    0    1 p8 <- p5 %>% add_neighbor_constraints(c(0, 1, 2), zones = z8)  # solve problems s2 <- list(p5, p6, p7, p8) s2 <- lapply(s2, solve) s2 <- lapply(s2, category_layer) s2 <- terra::rast(s2) names(s2) <- c(\"basic problem\", \"p6\", \"p7\", \"p8\")  # plot solutions plot(s2, main = names(s2), axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_proportion_decisions.html","id":null,"dir":"Reference","previous_headings":"","what":"Add proportion decisions — add_proportion_decisions","title":"Add proportion decisions — add_proportion_decisions","text":"Add proportion decision conservation planning problem. relaxed decision part planning unit can prioritized, opposed entire planning unit. Typically, decision assumed action buying fraction planning unit include decisions solve much faster problems use binary-type decisions.","code":""},{"path":"https://prioritizr.net/reference/add_proportion_decisions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add proportion decisions — add_proportion_decisions","text":"","code":"add_proportion_decisions(x)"},{"path":"https://prioritizr.net/reference/add_proportion_decisions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add proportion decisions — add_proportion_decisions","text":"x problem() object.","code":""},{"path":"https://prioritizr.net/reference/add_proportion_decisions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add proportion decisions — add_proportion_decisions","text":"updated problem() object decisions added .","code":""},{"path":"https://prioritizr.net/reference/add_proportion_decisions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add proportion decisions — add_proportion_decisions","text":"Conservation planning problems involve making decisions planning units. decisions associated actions (e.g., turning planning unit protected area). single decision added problem() object. Note multiple decisions added object, last one added used.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_proportion_decisions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add proportion decisions — add_proportion_decisions","text":"","code":"# \\dontrun{ # set seed for reproducibility set.seed(500)  # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_features <- get_sim_zones_features()  # create minimal problem with proportion decisions p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_proportion_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s1 <- solve(p1)  # plot solutions plot(s1, main = \"solution\", axes = FALSE)   # build multi-zone conservation problem with proportion decisions p2 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_min_set_objective() %>%   add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %>%   add_proportion_decisions() %>%   add_default_solver(verbose = FALSE)  # solve the problem s2 <- solve(p2)  # print solution print(s2) #> class       : SpatRaster  #> dimensions  : 10, 10, 3  (nrow, ncol, nlyr) #> resolution  : 0.1, 0.1  (x, y) #> extent      : 0, 1, 0, 1  (xmin, xmax, ymin, ymax) #> coord. ref. : Undefined Cartesian SRS  #> source(s)   : memory #> names       : zone_1, zone_2, zone_3  #> min values  :      0,      0,      0  #> max values  :      1,      1,      1   # plot solution # panels show the proportion of each planning unit allocated to each zone plot(s2, axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_relative_targets.html","id":null,"dir":"Reference","previous_headings":"","what":"Add relative targets — add_relative_targets","title":"Add relative targets — add_relative_targets","text":"Set targets proportion (0 1) maximum level representation features study area. Please note proportions scaled according features' total abundances study area (including locked planning units, planning units NA cost values) using feature_abundances() function.","code":""},{"path":"https://prioritizr.net/reference/add_relative_targets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add relative targets — add_relative_targets","text":"","code":"add_relative_targets(x, targets)  # S4 method for ConservationProblem,numeric add_relative_targets(x, targets)  # S4 method for ConservationProblem,matrix add_relative_targets(x, targets)  # S4 method for ConservationProblem,character add_relative_targets(x, targets)"},{"path":"https://prioritizr.net/reference/add_relative_targets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add relative targets — add_relative_targets","text":"x problem() object. targets Object specifies targets feature. See Targets format section information.","code":""},{"path":"https://prioritizr.net/reference/add_relative_targets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add relative targets — add_relative_targets","text":"updated problem() object targets added .","code":""},{"path":"https://prioritizr.net/reference/add_relative_targets.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add relative targets — add_relative_targets","text":"Targets used specify minimum amount proportion feature's distribution needs protected. conservation planning problems require targets exception maximum cover (see add_max_cover_objective()) maximum utility (see add_max_utility_objective()) problems. Attempting solve problems objectives require targets without specifying targets throw error. problems associated multiple management zones, add_absolute_targets() can used set targets pertain single feature single zone. set targets can met allocating different planning units multiple zones, see add_manual_targets() function. example target met allocations multiple zones might management zone expected result different amount feature target requires total amount feature zones must exceed certain threshold. words, target require single zone secure specific amount feature, total amount held zones must secure specific amount. Thus target , potentially, met allocating planning units specific management zone, allocating planning units different combinations management zones.","code":""},{"path":"https://prioritizr.net/reference/add_relative_targets.html","id":"targets-format","dir":"Reference","previous_headings":"","what":"Targets format","title":"Add relative targets — add_relative_targets","text":"targets problem can specified using following formats. targets numeric vector containing target values feature. Additionally, convenience, format can single value assign target feature. Note format used specify targets problems multiple zones. targets matrix object containing target feature zone. , row corresponds different feature argument x, column corresponds different zone argument x, cell contains target value given feature solution needs secure given zone. targets character vector containing column name(s) feature data associated argument x contain targets. format can used feature data associated x sf::st_sf() data.frame. problems contain single zone, argument targets must contain single column name. Otherwise, problems contain multiple zones, argument targets must contain column name zone.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_relative_targets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add relative targets — add_relative_targets","text":"","code":"# \\dontrun{ # set seed for reproducibility set.seed(500) sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_features <- get_sim_zones_features()  # create base problem p <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # create problem with 10% targets p1 <- p %>% add_relative_targets(0.1)  # create problem with varying targets for each feature targets <- c(0.1, 0.2, 0.3, 0.4, 0.5) p2 <- p %>% add_relative_targets(targets)  # solve problem s3 <- c(solve(p1), solve(p2)) names(s3) <- c(\"10% targets\", \"varying targets\")  # plot solution plot(s3, main = , axes = FALSE)   # create a problem with multiple management zones p4 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_min_set_objective() %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # create a problem with targets that specify an equal amount of each feature # to be represented in each zone p4_targets <- matrix(   0.1, nrow = 5, ncol = 3, dimnames = list(     feature_names(sim_zones_features), zone_names(sim_zones_features)   ) ) print(p4_targets) #>           zone_1 zone_2 zone_3 #> feature_1    0.1    0.1    0.1 #> feature_2    0.1    0.1    0.1 #> feature_3    0.1    0.1    0.1 #> feature_4    0.1    0.1    0.1 #> feature_5    0.1    0.1    0.1  p5 <- p4 %>% add_relative_targets(p4_targets)  # solve problem s5 <- solve(p5)  # plot solution (pixel values correspond to zone identifiers) plot(category_layer(s5), main = \"equal targets\")   # create a problem with targets that require a varying amount of each # feature to be represented in each zone p6_targets <- matrix(   runif(15, 0.01, 0.2), nrow = 5, ncol = 3, dimnames = list(     feature_names(sim_zones_features), zone_names(sim_zones_features)   ) ) print(p6_targets) #>               zone_1     zone_2     zone_3 #> feature_1 0.16838399 0.04908221 0.06359158 #> feature_2 0.14775224 0.10731456 0.17964011 #> feature_3 0.19530969 0.18583855 0.15529418 #> feature_4 0.09884473 0.16747797 0.04122594 #> feature_5 0.16433284 0.14519964 0.14909414  p6 <- p4 %>% add_relative_targets(p6_targets)  # solve problem s6 <- solve(p6)  # plot solution (pixel values correspond to zone identifiers) plot(category_layer(s6), main = \"varying targets\")  # }"},{"path":"https://prioritizr.net/reference/add_rsymphony_solver.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a SYMPHONY solver with Rsymphony — add_rsymphony_solver","title":"Add a SYMPHONY solver with Rsymphony — add_rsymphony_solver","text":"Specify SYMPHONY software -- using Rsymphony package -- used solve conservation planning problem (Ralphs & Güzelsoy 2005). function can also used customize behavior solver. requires Rsymphony package installed.","code":""},{"path":"https://prioritizr.net/reference/add_rsymphony_solver.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a SYMPHONY solver with Rsymphony — add_rsymphony_solver","text":"","code":"add_rsymphony_solver(   x,   gap = 0.1,   time_limit = .Machine$integer.max,   first_feasible = FALSE,   verbose = TRUE )"},{"path":"https://prioritizr.net/reference/add_rsymphony_solver.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a SYMPHONY solver with Rsymphony — add_rsymphony_solver","text":"x problem() object. gap numeric gap optimality. gap relative expresses acceptable deviance optimal objective. example, value 0.01 result solver stopping found solution within 1% optimality. Additionally, value 0 result solver stopping found optimal solution. default value 0.1 (.e., 10% optimality). time_limit numeric time limit (seconds) generating solutions. solver return current best solution time limit exceeded. default value largest integer value (.e., .Machine$integer.max), effectively meaning solver keep running solution within optimality gap found. first_feasible logical first feasible solution returned? first_feasible set TRUE, solver return first solution encounters meets constraints, regardless solution quality. Note first feasible solution arbitrary solution, rather derived relaxed solution, therefore often reasonably close optimality. Defaults FALSE. verbose logical information printed solving optimization problems? Defaults TRUE.","code":""},{"path":"https://prioritizr.net/reference/add_rsymphony_solver.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a SYMPHONY solver with Rsymphony — add_rsymphony_solver","text":"updated problem() object solver added .","code":""},{"path":"https://prioritizr.net/reference/add_rsymphony_solver.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add a SYMPHONY solver with Rsymphony — add_rsymphony_solver","text":"SYMPHONY open-source mixed integer programming solver part Computational Infrastructure Operations Research (COIN-) project. Rsymphony package provides interface COIN--- unlike dependencies solvers -- available CRAN. information performance different solvers, please see Schuster et al. (2020) benchmarks comparing run time solution quality different solvers applied different sized datasets.","code":""},{"path":"https://prioritizr.net/reference/add_rsymphony_solver.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Add a SYMPHONY solver with Rsymphony — add_rsymphony_solver","text":"Ralphs TK Güzelsoy M (2005) SYMPHONY callable library mixed integer programming. Next Wave Computing, Optimization, Decision Technologies (pp. 61--76). Springer, Boston, MA. Schuster R, Hanson JO, Strimas-Mackey M, Bennett JR (2020). Exact integer linear programming solvers outperform simulated annealing solving conservation planning problems. PeerJ, 8: e9258.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_rsymphony_solver.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add a SYMPHONY solver with Rsymphony — add_rsymphony_solver","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features()  # create problem p <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_rsymphony_solver(time_limit = 10, verbose = FALSE)  # generate solution s <- solve(p)  # plot solution plot(s, main = \"solution\", axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_semicontinuous_decisions.html","id":null,"dir":"Reference","previous_headings":"","what":"Add semi-continuous decisions — add_semicontinuous_decisions","title":"Add semi-continuous decisions — add_semicontinuous_decisions","text":"Add semi-continuous decision conservation planning problem. relaxed decision part planning unit can prioritized, opposed entire planning unit. decision similar add_proportion_decisions() function, except upper bound parameter. default, decision can range prioritizing none (0%) (100%) planning unit. However, upper bound can specified ensure , , fraction (e.g., 80%) planning unit can prioritized. type decision may useful practical conserve entire planning units.","code":""},{"path":"https://prioritizr.net/reference/add_semicontinuous_decisions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add semi-continuous decisions — add_semicontinuous_decisions","text":"","code":"add_semicontinuous_decisions(x, upper_limit)"},{"path":"https://prioritizr.net/reference/add_semicontinuous_decisions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add semi-continuous decisions — add_semicontinuous_decisions","text":"x problem() object. upper_limit numeric value specifying maximum proportion planning unit can reserved (e.g., set 0.8 80%).","code":""},{"path":"https://prioritizr.net/reference/add_semicontinuous_decisions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add semi-continuous decisions — add_semicontinuous_decisions","text":"updated problem() object decisions added .","code":""},{"path":"https://prioritizr.net/reference/add_semicontinuous_decisions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add semi-continuous decisions — add_semicontinuous_decisions","text":"Conservation planning problems involve making decisions planning units. decisions associated actions (e.g., turning planning unit protected area). single decision added problem() object. Note multiple decisions added object, last one added used.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_semicontinuous_decisions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add semi-continuous decisions — add_semicontinuous_decisions","text":"","code":"# \\dontrun{ # set seed for reproducibility set.seed(500)  # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_features <- get_sim_zones_features()  # create minimal problem with semi-continuous decisions p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_semicontinuous_decisions(0.5) %>%   add_default_solver(verbose = FALSE)  # solve problem s1 <- solve(p1)  # plot solutions plot(s1, main = \"solution\", axes = FALSE)   # build multi-zone conservation problem with semi-continuous decisions p2 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_min_set_objective() %>%   add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %>%   add_semicontinuous_decisions(0.5) %>%   add_default_solver(verbose = FALSE)  # solve the problem s2 <- solve(p2)  # print solution print(s2) #> class       : SpatRaster  #> dimensions  : 10, 10, 3  (nrow, ncol, nlyr) #> resolution  : 0.1, 0.1  (x, y) #> extent      : 0, 1, 0, 1  (xmin, xmax, ymin, ymax) #> coord. ref. : Undefined Cartesian SRS  #> source(s)   : memory #> names       : zone_1, zone_2, zone_3  #> min values  :    0.0,    0.0,    0.0  #> max values  :    0.5,    0.5,    0.5   # plot solution # panels show the proportion of each planning unit allocated to each zone plot(s2, axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_shuffle_portfolio.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a shuffle portfolio — add_shuffle_portfolio","title":"Add a shuffle portfolio — add_shuffle_portfolio","text":"Generate portfolio solutions conservation planning problem randomly reordering data prior solving problem. recommended replacement add_top_portfolio() Gurobi software available.","code":""},{"path":"https://prioritizr.net/reference/add_shuffle_portfolio.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a shuffle portfolio — add_shuffle_portfolio","text":"","code":"add_shuffle_portfolio(   x,   number_solutions = 10,   threads = 1,   remove_duplicates = TRUE )"},{"path":"https://prioritizr.net/reference/add_shuffle_portfolio.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a shuffle portfolio — add_shuffle_portfolio","text":"x problem() object. number_solutions integer number attempts generate different solutions. Defaults 10. threads integer number threads use generating solution portfolio. Defaults 1. remove_duplicates logical duplicate solutions removed? Defaults TRUE.","code":""},{"path":"https://prioritizr.net/reference/add_shuffle_portfolio.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a shuffle portfolio — add_shuffle_portfolio","text":"updated problem() object portfolio added .","code":""},{"path":"https://prioritizr.net/reference/add_shuffle_portfolio.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add a shuffle portfolio — add_shuffle_portfolio","text":"strategy generating portfolio solutions often results different solutions, depending optimality gap, may return duplicate solutions. general, strategy effective problems quick solve multiple threads available solving problem separately.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_shuffle_portfolio.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add a shuffle portfolio — add_shuffle_portfolio","text":"","code":"# \\dontrun{ # set seed for reproducibility set.seed(500)  # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_features <- get_sim_zones_features()  # create minimal problem with shuffle portfolio p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.2) %>%   add_shuffle_portfolio(10, remove_duplicates = FALSE) %>%   add_default_solver(gap = 0.2, verbose = FALSE)  # solve problem and generate 10 solutions within 20% of optimality s1 <- solve(p1)  # convert portfolio into a multi-layer raster s1 <- terra::rast(s1)  # print number of solutions found print(terra::nlyr(s1)) #> [1] 10  # plot solutions in portfolio plot(s1, axes = FALSE)   # build multi-zone conservation problem with shuffle portfolio p2 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_min_set_objective() %>%   add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %>%   add_binary_decisions() %>%   add_shuffle_portfolio(10, remove_duplicates = FALSE) %>%   add_default_solver(gap = 0.2, verbose = FALSE)  # solve the problem s2 <- solve(p2)  # convert each solution in the portfolio into a single category layer s2 <- terra::rast(lapply(s2, category_layer))  # print number of solutions found print(terra::nlyr(s2)) #> [1] 10  # plot solutions in portfolio plot(s2, axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/add_top_portfolio.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a top portfolio — add_top_portfolio","title":"Add a top portfolio — add_top_portfolio","text":"Generate portfolio solutions conservation planning problem finding pre-specified number solutions closest optimality (.e, top solutions).","code":""},{"path":"https://prioritizr.net/reference/add_top_portfolio.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a top portfolio — add_top_portfolio","text":"","code":"add_top_portfolio(x, number_solutions = 10)"},{"path":"https://prioritizr.net/reference/add_top_portfolio.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a top portfolio — add_top_portfolio","text":"x problem() object. number_solutions integer number solutions required. Defaults 10.","code":""},{"path":"https://prioritizr.net/reference/add_top_portfolio.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a top portfolio — add_top_portfolio","text":"updated problem() object portfolio added .","code":""},{"path":"https://prioritizr.net/reference/add_top_portfolio.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add a top portfolio — add_top_portfolio","text":"strategy generating portfolio requires problems solved using Gurobi software suite (.e., using add_gurobi_solver(). Specifically, version 8.0.0 (greater) gurobi package must installed. Note number solutions returned may less argument number_solutions, total number feasible solutions less number solutions requested.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/add_top_portfolio.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add a top portfolio — add_top_portfolio","text":"","code":"# \\dontrun{ # set seed for reproducibility set.seed(600)  # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_features <- get_sim_zones_features()  # create minimal problem with a portfolio for the top 5 solutions p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.05) %>%   add_top_portfolio(number_solutions = 5) %>%   add_default_solver(gap = 0, verbose = FALSE)  # solve problem and generate portfolio s1 <- solve(p1)  # convert portfolio into a multi-layer raster s1 <- terra::rast(s1)  # print number of solutions found print(terra::nlyr(s1)) #> [1] 5  # plot solutions plot(s1, axes = FALSE)   # create multi-zone problem with a portfolio for the top 5 solutions p2 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_min_set_objective() %>%   add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %>%   add_top_portfolio(number_solutions = 5) %>%   add_default_solver(gap = 0, verbose = FALSE)  # solve problem and generate portfolio s2 <- solve(p2)  # convert each solution in the portfolio into a single category layer s2 <- terra::rast(lapply(s2, category_layer))  # print number of solutions found print(terra::nlyr(s2)) #> [1] 5  # plot solutions in portfolio plot(s2, axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/adjacency_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Adjacency matrix — adjacency_matrix","title":"Adjacency matrix — adjacency_matrix","text":"Create matrix showing planning units spatially adjacent .","code":""},{"path":"https://prioritizr.net/reference/adjacency_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adjacency matrix — adjacency_matrix","text":"","code":"adjacency_matrix(x, ...)  # S3 method for Raster adjacency_matrix(x, directions = 4, ...)  # S3 method for SpatRaster adjacency_matrix(x, directions = 4, ...)  # S3 method for SpatialPolygons adjacency_matrix(x, ...)  # S3 method for SpatialLines adjacency_matrix(x, ...)  # S3 method for SpatialPoints adjacency_matrix(x, ...)  # S3 method for sf adjacency_matrix(x, ...)  # S3 method for default adjacency_matrix(x, ...)"},{"path":"https://prioritizr.net/reference/adjacency_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adjacency matrix — adjacency_matrix","text":"x terra::rast() sf::sf() object representing planning units. ... used. directions integer x terra::rast() object, number directions cells considered adjacent: 4 (rook's case), 8 (queen's case), 16 (knight one-cell queen moves), \"bishop\" cells one-cell diagonal moves.","code":""},{"path":"https://prioritizr.net/reference/adjacency_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Adjacency matrix — adjacency_matrix","text":"dsCMatrix sparse symmetric matrix. row column represents planning unit. Cells values indicate different planning units adjacent (using ones zeros). reduce computational burden, cells among matrix diagonal set zero. Furthermore, argument x terra::rast() object, cells NA values set zero .","code":""},{"path":"https://prioritizr.net/reference/adjacency_matrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Adjacency matrix — adjacency_matrix","text":"Spatial processing completed using sf::st_intersects() sf::sf() objects, terra::adjacent() terra::rast() objects. Note spatially overlapping planning units considered adjacent.","code":""},{"path":"https://prioritizr.net/reference/adjacency_matrix.html","id":"notes","dir":"Reference","previous_headings":"","what":"Notes","title":"Adjacency matrix — adjacency_matrix","text":"earlier versions (< 5.0.0), function named connected_matrix function. renamed consistent spatial association matrix functions.","code":""},{"path":"https://prioritizr.net/reference/adjacency_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Adjacency matrix — adjacency_matrix","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_pu_polygons <- get_sim_pu_polygons()  # create adjacency matrix using raster data ## crop raster to 9 cells r <- terra::crop(sim_pu_raster, terra::ext(c(0, 0.3, 0, 0.3)))  ## make adjacency matrix am_raster <- adjacency_matrix(r)  # create adjacency matrix using polygon data ## subset 9 polygons ply <- sim_pu_polygons[c(1:3, 11:13, 20:22), ]  ## make adjacency matrix am_ply <- adjacency_matrix(ply)  # plot data and the adjacency matrices  ## plot raster and adjacency matrix plot(r, main = \"raster\", axes = FALSE)  Matrix::image(am_raster, main = \"adjacency matrix\")   ## plot polygons and adjacency matrix plot(ply[, 1], main = \"polygons\")  Matrix::image(am_ply, main = \"adjacency matrix\")   # }"},{"path":"https://prioritizr.net/reference/binary_stack.html","id":null,"dir":"Reference","previous_headings":"","what":"Binary stack — binary_stack","title":"Binary stack — binary_stack","text":"Convert terra::rast() object containing integer/categorical values raster object layer corresponds different integer/categorical value pixel values denote presence/absence given integer/categorical values.","code":""},{"path":"https://prioritizr.net/reference/binary_stack.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Binary stack — binary_stack","text":"","code":"binary_stack(x)  # S3 method for Raster binary_stack(x)  # S3 method for SpatRaster binary_stack(x)"},{"path":"https://prioritizr.net/reference/binary_stack.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Binary stack — binary_stack","text":"x terra::rast() object single layer.","code":""},{"path":"https://prioritizr.net/reference/binary_stack.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Binary stack — binary_stack","text":"terra::rast() object.","code":""},{"path":"https://prioritizr.net/reference/binary_stack.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Binary stack — binary_stack","text":"function provided help manage data encompass multiple management zones. instance, function may helpful preparing raster data add_locked_in_constraints() add_locked_out_constraints() since require binary rasters input arguments. essentially wrapper terra::segregate().","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/binary_stack.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Binary stack — binary_stack","text":"","code":"# create raster with categorical values x <- terra::rast(matrix(c(1, 2, 3, 1, NA, 1), nrow = 3))  # plot the raster plot(x, main = \"x\")   # convert to binary stack y <- binary_stack(x)  # plot result # \\dontrun{ plot(y)  # }"},{"path":"https://prioritizr.net/reference/boundary_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Boundary matrix — boundary_matrix","title":"Boundary matrix — boundary_matrix","text":"Generate matrix describing amount shared boundary length different planning units, total amount boundary length planning unit.","code":""},{"path":"https://prioritizr.net/reference/boundary_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Boundary matrix — boundary_matrix","text":"","code":"boundary_matrix(x, ...)  # S3 method for Raster boundary_matrix(x, ...)  # S3 method for SpatRaster boundary_matrix(x, ...)  # S3 method for SpatialPolygons boundary_matrix(x, ...)  # S3 method for SpatialLines boundary_matrix(x, ...)  # S3 method for SpatialPoints boundary_matrix(x, ...)  # S3 method for sf boundary_matrix(x, ...)  # S3 method for default boundary_matrix(x, ...)"},{"path":"https://prioritizr.net/reference/boundary_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Boundary matrix — boundary_matrix","text":"x terra::rast() sf::sf() object representing planning units. ... used.","code":""},{"path":"https://prioritizr.net/reference/boundary_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Boundary matrix — boundary_matrix","text":"dsCMatrix symmetric sparse matrix object. row column represents planning unit. Cell values indicate shared boundary length different pairs planning units. Values along matrix diagonal indicate total perimeter associated planning unit.","code":""},{"path":"https://prioritizr.net/reference/boundary_matrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Boundary matrix — boundary_matrix","text":"function assumes data coordinate system Euclidean distances accurately describe proximity two points earth. Thus spatial data longitude/latitude coordinate system (.e., WGS84) reprojected another coordinate system using function. Note terra::rast() objects boundaries missing cells  missing (NA) values cells.","code":""},{"path":"https://prioritizr.net/reference/boundary_matrix.html","id":"notes","dir":"Reference","previous_headings":"","what":"Notes","title":"Boundary matrix — boundary_matrix","text":"earlier versions, function extra str_tree parameter used leverage STR query trees speed processing planning units vector format. Although functionality improved performance, enabled default underlying function (.e., rgeos:gUnarySTRtreeQuery()) documented experimental. boundary_matrix() function since updated use STR query trees speed processing planning units vector format (using terra::sharedPaths()). Also, note previous versions, cell values along matrix diagonal indicated perimeter associated planning units contain neighbors. now changed values along diagonal now correspond total perimeter associated planning unit.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/boundary_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Boundary matrix — boundary_matrix","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_pu_polygons <- get_sim_pu_polygons()  # subset data to reduce processing time r <- terra::crop(sim_pu_raster, c(0, 0.3, 0, 0.3)) ply <- sim_pu_polygons[c(1:3, 11:13, 20:22), ]  # create boundary matrix using raster data bm_raster <- boundary_matrix(r)  # create boundary matrix using polygon data bm_ply <- boundary_matrix(ply)  # plot raster and boundary matrix plot(r, main = \"raster\", axes = FALSE)  Matrix::image(bm_raster, main = \"boundary matrix\")   # plot polygons and boundary matrices plot(ply[, 1], main = \"polygons\", axes = FALSE)  Matrix::image(bm_ply, main = \"boundary matrix\")  # }"},{"path":"https://prioritizr.net/reference/branch_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Branch matrix — branch_matrix","title":"Branch matrix — branch_matrix","text":"Phylogenetic trees depict evolutionary relationships different species. branch phylogenetic tree represents period evolutionary history. Species connected branch share period evolutionary history. function creates matrix shows species connected branch. words, creates matrix shows periods evolutionary history species experienced.","code":""},{"path":"https://prioritizr.net/reference/branch_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Branch matrix — branch_matrix","text":"","code":"branch_matrix(x)  # S3 method for default branch_matrix(x)  # S3 method for phylo branch_matrix(x)"},{"path":"https://prioritizr.net/reference/branch_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Branch matrix — branch_matrix","text":"x ape::phylo() tree object.","code":""},{"path":"https://prioritizr.net/reference/branch_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Branch matrix — branch_matrix","text":"dgCMatrix sparse matrix object. row corresponds different species. column corresponds different branch. Species inherit given branch denoted one.","code":""},{"path":"https://prioritizr.net/reference/branch_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Branch matrix — branch_matrix","text":"","code":"# load data sim_phylogeny <- get_sim_phylogeny()  # generate species by branch matrix m <- branch_matrix(sim_phylogeny)  # plot data # \\dontrun{ plot(sim_phylogeny, main = \"phylogeny\")  Matrix::image(m, main = \"branch matrix\")  # }"},{"path":"https://prioritizr.net/reference/category_layer.html","id":null,"dir":"Reference","previous_headings":"","what":"Category layer — category_layer","title":"Category layer — category_layer","text":"Convert terra::rast() object layer corresponds different identifier values indicate presence/absence category terra::rast() object containing categorical identifiers.","code":""},{"path":"https://prioritizr.net/reference/category_layer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Category layer — category_layer","text":"","code":"category_layer(x)  # S3 method for Raster category_layer(x)  # S3 method for default category_layer(x)"},{"path":"https://prioritizr.net/reference/category_layer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Category layer — category_layer","text":"x terra::rast() object containing multiple layers. Note pixels must 0, 1 NA values.","code":""},{"path":"https://prioritizr.net/reference/category_layer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Category layer — category_layer","text":"terra::rast() object.","code":""},{"path":"https://prioritizr.net/reference/category_layer.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Category layer — category_layer","text":"function provided help manage data encompass multiple management zones. instance, function may helpful interpreting solutions problems associated multiple zones binary decisions. essentially wrapper terra::.lyr().","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/category_layer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Category layer — category_layer","text":"","code":"# create a binary raster stack x <- terra::rast(list(  terra::rast(matrix(c(1, 0, 0, 1, NA, 0), nrow = 3)),  terra::rast(matrix(c(0, 1, 0, 0, NA, 0), nrow = 3)),  terra::rast(matrix(c(0, 0, 1, 0, NA, 1), nrow = 3)) ))  # plot data plot(x)   # convert to category layer y <- category_layer(x)  # plot result # \\dontrun{ plot(y)  # }"},{"path":"https://prioritizr.net/reference/category_vector.html","id":null,"dir":"Reference","previous_headings":"","what":"Category vector — category_vector","title":"Category vector — category_vector","text":"Convert object containing binary (integer) columns integer vector indicating column index row 1.","code":""},{"path":"https://prioritizr.net/reference/category_vector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Category vector — category_vector","text":"","code":"category_vector(x)  # S3 method for data.frame category_vector(x)  # S3 method for sf category_vector(x)  # S3 method for Spatial category_vector(x)  # S3 method for matrix category_vector(x)"},{"path":"https://prioritizr.net/reference/category_vector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Category vector — category_vector","text":"x matrix, data.frame, sf::sf() object.","code":""},{"path":"https://prioritizr.net/reference/category_vector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Category vector — category_vector","text":"integer vector.","code":""},{"path":"https://prioritizr.net/reference/category_vector.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Category vector — category_vector","text":"function conceptually similar base::max.col() except rows values equal 1 values assigned value zero. Also, note argument x, row must contain single value equal 1.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/category_vector.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Category vector — category_vector","text":"","code":"# create matrix with logical columns x <- matrix(c(1, 0, 0, NA, 0, 1, 0, NA, 0, 0, 0, NA), ncol = 3)  # print matrix print(x) #>      [,1] [,2] [,3] #> [1,]    1    0    0 #> [2,]    0    1    0 #> [3,]    0    0    0 #> [4,]   NA   NA   NA  # convert to category vector y <- category_vector(x)  # print category vector print(y) #> [1]  1  2  0 NA"},{"path":"https://prioritizr.net/reference/compile.html","id":null,"dir":"Reference","previous_headings":"","what":"Compile a problem — compile","title":"Compile a problem — compile","text":"Compile conservation planning problem mixed integer linear programming problem.","code":""},{"path":"https://prioritizr.net/reference/compile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compile a problem — compile","text":"","code":"compile(x, ...)  # S3 method for ConservationProblem compile(x, compressed_formulation = NA, ...)"},{"path":"https://prioritizr.net/reference/compile.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compile a problem — compile","text":"x problem() object. ... used. compressed_formulation logical conservation problem compiled compressed version planning problem? TRUE problem expressed using compressed formulation. FALSE problem expressed using expanded formulation. NA, compressed used unless one constraints requires expanded formulation. argument defaults NA.","code":""},{"path":"https://prioritizr.net/reference/compile.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compile a problem — compile","text":"optimization_problem() object.","code":""},{"path":"https://prioritizr.net/reference/compile.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compile a problem — compile","text":"function might useful interested understanding conservation planning problem() expressed mathematical problem. However, problem just needs solved, solve() function just used. Please note nearly cases, default argument compressed_formulation used. situation manually setting argument formulation desirable testing. Manually setting argument formulation best effect problem. worst, may result error, misspecified problem, unnecessarily long solve times.","code":""},{"path":"https://prioritizr.net/reference/compile.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compile a problem — compile","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features()  # build minimal conservation problem p <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1)  # compile the conservation problem into an optimization problem o <- compile(p)  # print the optimization problem print(o) #> An optimization problem (<OptimizationProblem>) #> • model sense: min #> • dimensions:  5, 90, 450 (rows, columns, cells) #> • variables:   90 (B) # }"},{"path":"https://prioritizr.net/reference/connectivity_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Connectivity matrix — connectivity_matrix","title":"Connectivity matrix — connectivity_matrix","text":"Create matrix showing connectivity planning units. Connectivity calculated average conductance two planning units multiplied amount shared boundary two planning units. Thus planning units higher conductance share greater boundary associated greater connectivity.","code":""},{"path":"https://prioritizr.net/reference/connectivity_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Connectivity matrix — connectivity_matrix","text":"","code":"connectivity_matrix(x, y, ...)  # S4 method for Spatial,Raster connectivity_matrix(x, y, ...)  # S4 method for Spatial,character connectivity_matrix(x, y, ...)  # S4 method for sf,character connectivity_matrix(x, y, ...)  # S4 method for sf,Raster connectivity_matrix(x, y, ...)  # S4 method for sf,SpatRaster connectivity_matrix(x, y, ...)  # S4 method for Raster,Raster connectivity_matrix(x, y, ...)  # S4 method for SpatRaster,SpatRaster connectivity_matrix(x, y, ...)"},{"path":"https://prioritizr.net/reference/connectivity_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Connectivity matrix — connectivity_matrix","text":"x terra::rast() sf::sf() object representing planning units. y terra::rast() object showing conductance different areas across study area, character object denoting column name attribute table x contains conductance values. Note argument y can character object argument x sf::sf() object. Also, note argument x terra::rast() object argument y must spatial properties (.e., coordinate system, extent, resolution). ... additional arguments passed fast_extract() extracting calculating conductance values planning unit. arguments used argument x sf::sf() object argument y terra::rast() object.","code":""},{"path":"https://prioritizr.net/reference/connectivity_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Connectivity matrix — connectivity_matrix","text":"dsCMatrix symmetric sparse matrix object. row column represents planning unit. Cells values indicate connectivity different pairs planning units. reduce computational burden, cells among matrix diagonal set zero. Furthermore, argument x terra::rast() object, cells missing (NA) values set zero .","code":""},{"path":"https://prioritizr.net/reference/connectivity_matrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Connectivity matrix — connectivity_matrix","text":"Shared boundary calculations performed using boundary_matrix().","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/connectivity_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Connectivity matrix — connectivity_matrix","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_pu_polygons <- get_sim_pu_polygons() sim_features <- get_sim_features()  # create connectivity matrix using raster planning unit data using # the raster cost values to represent conductance ## extract 9 planning units r <- terra::crop(sim_pu_raster, terra::ext(c(0, 0.3, 0, 0.3)))  ## extract conductance data for the 9 planning units cd <- terra::crop(sim_features, r)  ## make connectivity matrix using the habitat suitability data for the ## second feature to represent the planning unit conductance data cm_raster <- connectivity_matrix(r, cd[[2]])  ## plot data and matrix plot(r, main = \"planning units (raster)\", axes = FALSE)  plot(cd[[2]], main = \"conductivity\", axes = FALSE)  Matrix::image(cm_raster,  main = \"connectivity matrix\")   # create connectivity matrix using polygon planning unit data using # the habitat suitability data for the second feature to represent # planning unit conductances ## subset data to 9 polygons ply <- sim_pu_polygons[c(1:3, 11:13, 20:22), ]  ## make connectivity matrix cm_ply <- connectivity_matrix(ply, sim_features[[2]])  ## plot data and matrix plot(sf::st_geometry(ply), main = \"planning units (polygons)\")  plot(terra::crop(sim_features[[2]], ply), main = \"connectivity\")  Matrix::image(cm_ply, main = \"connectivity matrix\")   # create connectivity matrix using habitat suitability data for each feature, # this could be useful if prioritizations should spatially clump # together adjacent planning units that have suitable habitat # for the same species (e.g., to maintain functional connectivity)  ## let's use the raster data for this example, and we can generate the ## connectivity matrix that we would use in the prioritization by ## (1) generating a connectivity matrix for each feature separately, and ## and then (2) summing the values together cm_sum <- lapply(as.list(cd), connectivity_matrix, x = r) # make matrices cm_sum <- Reduce(\"+\", cm_sum) # sum matrices together  ## plot data and matrix plot(r, main = \"planning units (raster)\", axes = FALSE)  Matrix::image(cm_sum, main = \"connectivity matrix\")   ## we could take this example one step further, and use weights to indicate ## relative importance of maintaining functional connectivity ## for each feature (i.e., use the weighted sum instead of the sum)  ## let's pretend that the first feature is 20 times more important ## than all the other species weights <- c(20, 1, 1, 1, 1)  ## calculate connectivity matrix using weighted sum cm_wsum <- lapply(as.list(cd), connectivity_matrix, x = r) # make matrices cm_wsum <- Map(\"*\", cm_wsum, weights) # multiply by weights cm_wsum <- Reduce(\"+\", cm_wsum) # sum matrices together  ## plot data and matrix plot(r, main = \"planning units (raster)\", axes = FALSE)  Matrix::image(cm_wsum, main = \"connectivity matrix\")   ## since the statistical distribution of the connectivity values ## for each feature (e.g., the mean and standard deviation of the ## connectivity values) are different, it might make sense -- depending ## on the goal of the conservation planning exercise and the underlying ## data -- to first normalize the conductance values before applying the ## weights and summing the data for feature together  ### calculate functional connectivity matrix using the weighted sum of ### connectivity values that have been normalized by linearly re-scaling ### values cm_lwsum <- lapply(as.list(cd), connectivity_matrix, x = r) # make matrices cm_lwsum <- lapply(cm_lwsum, rescale_matrix, max = 1) # rescale matrices cm_lwsum <- Map(\"*\", cm_lwsum, weights) # multiply by weights cm_lwsum <- Reduce(\"+\", cm_lwsum) # sum matrices together  ## plot data and matrix plot(r, main = \"planning units (raster)\", axes = FALSE)  Matrix::image(cm_lwsum, main = \"connectivity matrix\")   ## another approach for normalizing the data could be using z-scores ## note that after normalizing the data we would need to add a constant ## value so that none of the connectivity values are negative  ### define helper functions zscore <- function(x) {x@x <- (x@x - mean(x@x)) / sd(x@x); x} min_non_zero_value <- function(x) min(x@x) add_non_zero_value <- function(x, y) {x@x <- x@x + y; x}  ### calculate functional connectivity matrix using the weighted sum of ### connectivity values that have been normalized using z-scores, ### and transformed to account for negative values cm_zwsum <- lapply(as.list(cd), connectivity_matrix, x = r) # make matrices cm_zwsum <- lapply(cm_zwsum, zscore) # normalize using z-scores min_value <- min(sapply(cm_zwsum, min_non_zero_value)) # find min value min_value <- abs(min_value) + 0.01 # prepare constant for adding to matrices cm_zwsum <- lapply(cm_zwsum, add_non_zero_value, min_value) # add constant cm_zwsum <- Map(\"*\", cm_zwsum, weights) # multiply by weights cm_zwsum <- Reduce(\"+\", cm_zwsum) # sum matrices together  ## plot data and matrix plot(r, main = \"planning units (raster)\", axes = FALSE)  Matrix::image(cm_zwsum, main = \"connectivity matrix\")  # }"},{"path":"https://prioritizr.net/reference/constraints.html","id":null,"dir":"Reference","previous_headings":"","what":"Conservation problem constraints — constraints","title":"Conservation problem constraints — constraints","text":"constraint can added conservation planning problem ensure solutions exhibit specific characteristic.","code":""},{"path":"https://prioritizr.net/reference/constraints.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Conservation problem constraints — constraints","text":"Constraints can used ensure solutions exhibit range different characteristics. instance, can used lock lock certain planning units solution, protected areas degraded land (respectively). Additionally, similar penalties functions, constraint functions can used increase connectivity solution. key difference penalty constraint, however, constraints work invalidating solutions exhibit specific characteristic, whereas penalty functions work penalizing solutions meet specific characteristic. Thus constraints affect objective function. following constraints available. following constraints can added conservation planning problem(): add_locked_in_constraints() Add constraints ensure certain planning units selected solution. add_locked_out_constraints() Add constraints ensure certain planning units selected solution. add_neighbor_constraints() Add constraints ensure selected planning units least certain number neighbors. add_contiguity_constraints() Add constraints ensure selected planning units spatially connected form single contiguous unit. add_feature_contiguity_constraints() Add constraints ensure feature represented contiguous unit dispersible habitat. constraints advanced version implemented add_contiguity_constraints() function, ensure feature represented contiguous unit entire solution form contiguous unit. add_linear_constraints() Add constraints ensure selected planning units meet certain criteria. example, can used add multiple budgets, limit number planning units selected different administrative areas within study region (e.g., different countries). add_mandatory_allocation_constraints() Add constraints ensure every planning unit allocated management zone solution. function can used problems contain multiple zones.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/constraints.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conservation problem constraints — constraints","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features() sim_locked_in_raster <- get_sim_locked_in_raster() sim_locked_out_raster <- get_sim_locked_in_raster()  # create minimal problem with only targets and no additional constraints p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.2) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # create problem with locked in constraints p2 <- p1 %>% add_locked_in_constraints(sim_locked_in_raster)  # create problem with locked in constraints p3 <- p1 %>% add_locked_out_constraints(sim_locked_out_raster)  # create problem with neighbor constraints p4 <- p1 %>% add_neighbor_constraints(2)  # create problem with contiguity constraints p5 <- p1 %>% add_contiguity_constraints()  # create problem with feature contiguity constraints p6 <- p1 %>% add_feature_contiguity_constraints()  # solve problems s <- terra::rast(lapply(list(p1, p2, p3, p4, p5, p6), solve)) names(s) <- c(   \"minimal problem\", \"locked in\", \"locked out\",   \"neighbor\", \"contiguity\", \"feature contiguity\" )  # plot solutions plot(s, axes = FALSE, nr = 2)  # }"},{"path":"https://prioritizr.net/reference/decisions.html","id":null,"dir":"Reference","previous_headings":"","what":"Add decision types — decisions","title":"Add decision types — decisions","text":"Conservation planning problems involve making decisions different planning units managed. decisions might involve turning entire planning unit protected area, turning part planning unit protected area, allocating planning unit specific management zone. decision explicitly added problem, binary decisions used default.","code":""},{"path":"https://prioritizr.net/reference/decisions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add decision types — decisions","text":"single type decision can added conservation planning problem(). Note multiple decisions added problem, last one added used. following decisions can added conservation planning problem(): add_binary_decisions() Add binary decision conservation planning problem. classic decision either prioritizing prioritizing planning unit. Typically, decision assumed action buying planning unit include protected area network. decision added problem object decision class used default. add_proportion_decisions() Add proportion decision conservation planning problem. relaxed decision part planning unit can prioritized, opposed default entire planning unit. Typically, decision assumed action buying fraction planning unit include protected area network. add_semicontinuous_decisions() Add semi-continuous decision conservation planning problem. decision similar add_proportion_decision except upper bound parameter. default, decision can range prioritizing none (0%) (100%) planning unit. However, upper bound can specified ensure fraction (e.g., 80%) planning unit can preserved. type decision may useful practical conserve entire area encompassed single planning unit.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/decisions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add decision types — decisions","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features()  # create basic problem and using the default decision types (binary) p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_default_solver(verbose = FALSE)  # create problem with manually specified binary decisions p2 <- p1 %>% add_binary_decisions()  # create problem with proportion decisions p3 <- p1 %>% add_proportion_decisions()  # create problem with semicontinuous decisions p4 <- p1 %>% add_semicontinuous_decisions(upper_limit = 0.5)  # solve problem s <- c(solve(p1), solve(p2), solve(p3), solve(p4)) names(s) <- c(   \"default (binary)\", \"binary\", \"proportion\", \"semicontinuous (upper = 0.5)\" ) # plot solutions plot(s)  # }"},{"path":"https://prioritizr.net/reference/eval_asym_connectivity_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate asymmetric connectivity of solution — eval_asym_connectivity_summary","title":"Evaluate asymmetric connectivity of solution — eval_asym_connectivity_summary","text":"Calculate connectivity held within solution conservation planning problem. summary statistic evaluates connectivity solution using pair-wise connectivity values combinations planning units. specifically designed asymmetric connectivity data.","code":""},{"path":"https://prioritizr.net/reference/eval_asym_connectivity_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate asymmetric connectivity of solution — eval_asym_connectivity_summary","text":"","code":"# S4 method for ConservationProblem,ANY,ANY,matrix eval_asym_connectivity_summary(x, solution, zones, data)  # S4 method for ConservationProblem,ANY,ANY,Matrix eval_asym_connectivity_summary(x, solution, zones, data)  # S4 method for ConservationProblem,ANY,ANY,data.frame eval_asym_connectivity_summary(x, solution, zones, data)  # S4 method for ConservationProblem,ANY,ANY,dgCMatrix eval_asym_connectivity_summary(x, solution, zones, data)  # S4 method for ConservationProblem,ANY,ANY,array eval_asym_connectivity_summary(x, solution, zones, data)"},{"path":"https://prioritizr.net/reference/eval_asym_connectivity_summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate asymmetric connectivity of solution — eval_asym_connectivity_summary","text":"x problem() object. solution numeric, matrix, data.frame, terra::rast(), sf::sf() object. argument format planning unit cost data argument x. See Solution format section information. zones matrix Matrix object describing level connectivity different zones. row column corresponds different zone argument x, cell values indicate level connectivity combination zones. Cell values along diagonal matrix represent level connectivity planning units allocated zone. Cell values must lay 1 -1, negative values favor solutions weak connectivity. default argument zones identity matrix (.e., matrix ones along matrix diagonal zeros elsewhere), planning units considered connected allocated zone. argument required working multiple zones argument data matrix Matrix object. argument data array data.frame data multiple zones (e.g., using \"zone1\" \"zone2\" column names), argument must explicitly set NULL otherwise error thrown. data matrix, Matrix, data.frame, array object containing connectivity data. connectivity values correspond strength connectivity different planning units. Thus connections planning units associated higher values favorable solution. See Data format section information.","code":""},{"path":"https://prioritizr.net/reference/eval_asym_connectivity_summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate asymmetric connectivity of solution — eval_asym_connectivity_summary","text":"tibble::tibble() object describing connectivity solution. contains following columns: summary character description summary statistic. statistic associated \"overall\" value column calculated using entire solution (including management zones multiple zones). multiple management zones present, summary statistics also provided zone separately (indicated using zone names). asym_connectivity numeric connectivity value. Greater values correspond solutions associated greater connectivity. Thus conservation planning exercises typically prefer solutions greater values.","code":""},{"path":"https://prioritizr.net/reference/eval_asym_connectivity_summary.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Evaluate asymmetric connectivity of solution — eval_asym_connectivity_summary","text":"summary statistic comparable Connectivity metric reported Marxan software (Ball et al. 2009). calculated using equations used penalize solutions asymmetric connectivity data (.e., add_asym_connectivity_penalties()). Specifically, calculated sum connectivity values (argument data) correspond pairs planning units, wherein one planning unit selected solution planning unit selected solution.","code":""},{"path":"https://prioritizr.net/reference/eval_asym_connectivity_summary.html","id":"solution-format","dir":"Reference","previous_headings":"","what":"Solution format","title":"Evaluate asymmetric connectivity of solution — eval_asym_connectivity_summary","text":"Broadly speaking, argument solution must format planning unit data argument x. details correct format listed separately different planning unit data formats: x numeric planning units argument solution must numeric vector element corresponding different planning unit. number planning units argument x. Additionally, planning units missing cost (NA) values also missing (NA) values argument solution. x matrix planning units argument solution must matrix vector row corresponding different planning unit, column correspond different management zone. number planning units zones argument x. Additionally, planning units missing cost (NA) values particular zone also missing (NA) values argument solution. x terra::rast() planning units argument solution terra::rast() object different grid cells (pixels) correspond different planning units layers correspond different management zones. dimensionality (rows, columns, layers), resolution, extent, coordinate reference system planning units argument x. Additionally, planning units missing cost (NA) values particular zone also missing (NA)  values argument solution. x data.frame planning units argument solution must data.frame column corresponding different zone, row corresponding different planning unit, cell values corresponding solution value. means data.frame object containing solution also contains additional columns, columns need subsetted prior using function (see example sf::sf() data). Additionally, planning units missing cost (NA) values particular zone also missing (NA) values argument solution. x sf::sf() planning units argument solution must sf::sf() object column corresponding different zone, row corresponding different planning unit, cell values corresponding solution value. means sf::sf() object containing solution also contains additional columns, columns need subsetted prior using function (see example). Additionally, argument solution must also coordinate reference system planning unit data. Furthermore, planning units missing cost (NA) values particular zone also missing (NA) values argument solution.","code":""},{"path":"https://prioritizr.net/reference/eval_asym_connectivity_summary.html","id":"data-format","dir":"Reference","previous_headings":"","what":"Data format","title":"Evaluate asymmetric connectivity of solution — eval_asym_connectivity_summary","text":"argument data can specified using several different formats. data matrix/Matrix object rows columns represent different planning units value cell represents strength connectivity two different planning units. Cells occur along matrix diagonal treated weights indicate planning units desirable solution. argument zones can used control strength connectivity planning units different zones. default argument zones treat planning units allocated different zones zero connectivity. data data.frame object containing columns named \"id1\", \"id2\", \"boundary\". , row denotes connectivity pair planning units (per values \"id1\" \"id2\" columns) following Marxan format. argument x contains multiple zones, \"zone1\" \"zone2\" columns can optionally provided manually specify connectivity values planning units allocated specific zones. \"zone1\" \"zone2\" columns present, argument zones must NULL. data array object containing four-dimensions cell values indicate strength connectivity planning units assigned specific management zones. first two dimensions (.e., rows columns) indicate strength connectivity different planning units second two dimensions indicate different management zones. Thus data[1, 2, 3, 4] indicates strength connectivity planning unit 1 planning unit 2 planning unit 1 assigned zone 3 planning unit 2 assigned zone 4.","code":""},{"path":"https://prioritizr.net/reference/eval_asym_connectivity_summary.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Evaluate asymmetric connectivity of solution — eval_asym_connectivity_summary","text":"Ball IR, Possingham HP, Watts M (2009) Marxan relatives: Software spatial conservation prioritisation Spatial conservation prioritisation: Quantitative methods computational tools. Eds Moilanen , Wilson KA, Possingham HP. Oxford University Press, Oxford, UK.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/eval_asym_connectivity_summary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate asymmetric connectivity of solution — eval_asym_connectivity_summary","text":"","code":"# \\dontrun{ # set seed for reproducibility set.seed(500)  # load data sim_pu_polygons <- get_sim_pu_polygons() sim_features <- get_sim_features() sim_zones_pu_polygons <- get_sim_zones_pu_polygons() sim_zones_features <- get_sim_zones_features()  # build minimal conservation problem with polygon data p1 <-   problem(sim_pu_polygons, sim_features, cost_column = \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve the problem s1 <- solve(p1)  # print solution print(s1) #> Simple feature collection with 90 features and 4 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 0 ymin: 0 xmax: 1 ymax: 1 #> Projected CRS: Undefined Cartesian SRS #> # A tibble: 90 × 5 #>     cost locked_in locked_out solution_1                                    geom #>    <dbl> <lgl>     <lgl>           <dbl>                           <POLYGON [m]> #>  1  216. FALSE     FALSE               0     ((0 1, 0.1 1, 0.1 0.9, 0 0.9, 0 1)) #>  2  213. FALSE     FALSE               0 ((0.1 1, 0.2 1, 0.2 0.9, 0.1 0.9, 0.1 … #>  3  207. FALSE     FALSE               0 ((0.2 1, 0.3 1, 0.3 0.9, 0.2 0.9, 0.2 … #>  4  209. FALSE     TRUE                0 ((0.3 1, 0.4 1, 0.4 0.9, 0.3 0.9, 0.3 … #>  5  214. FALSE     FALSE               0 ((0.4 1, 0.5 1, 0.5 0.9, 0.4 0.9, 0.4 … #>  6  214. FALSE     FALSE               0 ((0.5 1, 0.6 1, 0.6 0.9, 0.5 0.9, 0.5 … #>  7  210. FALSE     FALSE               0 ((0.6 1, 0.7 1, 0.7 0.9, 0.6 0.9, 0.6 … #>  8  211. FALSE     TRUE                0 ((0.7 1, 0.8 1, 0.8 0.9, 0.7 0.9, 0.7 … #>  9  210. FALSE     FALSE               0 ((0.8 1, 0.9 1, 0.9 0.9, 0.8 0.9, 0.8 … #> 10  204. FALSE     FALSE               0   ((0.9 1, 1 1, 1 0.9, 0.9 0.9, 0.9 1)) #> # ℹ 80 more rows  # plot solution plot(s1[, \"solution_1\"])   # simulate connectivity matrix # here, we will generate connectivity values randomly # between all pairs of planning units acm1 <- matrix(   runif(nrow(sim_pu_polygons) ^ 2),   nrow = nrow(sim_pu_polygons) )  # calculate connectivity associated with the solution r1 <- eval_asym_connectivity_summary(p1, s1[, \"solution_1\"], data = acm1) print(r1) #> # A tibble: 1 × 2 #>   summary asym_connectivity #>   <chr>               <dbl> #> 1 overall              36.8  # build multi-zone conservation problem with polygon data p2 <-   problem(     sim_zones_pu_polygons, sim_zones_features,      cost_column = c(\"cost_1\", \"cost_2\", \"cost_3\")   ) %>%   add_min_set_objective() %>%   add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve the problem s2 <- solve(p2)  # print solution print(s2) #> Simple feature collection with 90 features and 9 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 0 ymin: 0 xmax: 1 ymax: 1 #> Projected CRS: Undefined Cartesian SRS #> # A tibble: 90 × 10 #>    cost_1 cost_2 cost_3 locked_1 locked_2 locked_3 solution_1_zone_1 #>     <dbl>  <dbl>  <dbl> <lgl>    <lgl>    <lgl>                <dbl> #>  1   216.   183.   205. FALSE    FALSE    FALSE                    0 #>  2   213.   189.   210. FALSE    FALSE    FALSE                    0 #>  3   207.   194.   215. TRUE     FALSE    FALSE                    0 #>  4   209.   198.   219. FALSE    FALSE    FALSE                    0 #>  5   214.   200.   221. FALSE    FALSE    FALSE                    0 #>  6   214.   203.   225. FALSE    FALSE    FALSE                    0 #>  7   211.   209.   223. FALSE    FALSE    FALSE                    0 #>  8   210.   212.   222. TRUE     FALSE    FALSE                    0 #>  9   204.   218.   214. FALSE    FALSE    FALSE                    1 #> 10   213.   183.   206. FALSE    FALSE    FALSE                    0 #> # ℹ 80 more rows #> # ℹ 3 more variables: solution_1_zone_2 <dbl>, solution_1_zone_3 <dbl>, #> #   geom <POLYGON [m]>  # create new column representing the zone id that each planning unit # was allocated to in the solution s2$solution <- category_vector(   s2[, c(\"solution_1_zone_1\", \"solution_1_zone_2\", \"solution_1_zone_3\")] ) s2$solution <- factor(s2$solution)  # plot solution plot(s2[, \"solution\"])   # simulate asymmetric connectivity matrix acm2 <- matrix(   runif(nrow(sim_zones_pu_polygons) ^ 2),   nrow = nrow(sim_zones_pu_polygons) )  # calculate connectivity associated with the solution r2 <- eval_asym_connectivity_summary(   p2,   s2[, c(\"solution_1_zone_1\", \"solution_1_zone_2\", \"solution_1_zone_3\")],   data = acm2 ) print(r2) #> # A tibble: 4 × 2 #>   summary asym_connectivity #>   <chr>               <dbl> #> 1 overall              360. #> 2 zone_1               154. #> 3 zone_2               104. #> 4 zone_3               103.  # }"},{"path":"https://prioritizr.net/reference/eval_boundary_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate boundary length of solution — eval_boundary_summary","title":"Evaluate boundary length of solution — eval_boundary_summary","text":"Calculate exposed boundary length (.e., perimeter) associated solution conservation planning problem. summary statistic useful evaluating spatial fragmentation planning units selected within solution.","code":""},{"path":"https://prioritizr.net/reference/eval_boundary_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate boundary length of solution — eval_boundary_summary","text":"","code":"eval_boundary_summary(   x,   solution,   edge_factor = rep(0.5, number_of_zones(x)),   zones = diag(number_of_zones(x)),   data = NULL )"},{"path":"https://prioritizr.net/reference/eval_boundary_summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate boundary length of solution — eval_boundary_summary","text":"x problem() object. solution numeric, matrix, data.frame, terra::rast(), sf::sf() object. argument format planning unit cost data argument x. See Solution format section information. edge_factor numeric proportion scale planning unit edges (borders) neighboring planning units. example, edge factor 0.5 commonly used avoid overly penalizing planning units along coastline. Note argument must element zone argument x. zones matrix Matrix object describing clumping scheme different zones. row column corresponds different zone argument x, cell values indicate relative importance clumping planning units allocated combination zones. Cell values along diagonal matrix represent relative importance clumping planning units allocated zone. Cell values must range 1 -1, negative values favor solutions spread planning units. default argument zones identity matrix (.e., matrix ones along matrix diagonal zeros elsewhere), penalties incurred neighboring planning units assigned zone. cells along matrix diagonal contain markedly smaller values found elsewhere matrix, solutions preferred surround planning units allocated different zones (.e., greater spatial fragmentation). data NULL, data.frame, matrix, Matrix object containing boundary data. data describe total amount boundary (perimeter) length  planning unit, amount boundary (perimeter) length shared different planning units (.e., planning units adjacent ). See Data format section information.","code":""},{"path":"https://prioritizr.net/reference/eval_boundary_summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate boundary length of solution — eval_boundary_summary","text":"tibble::tibble() object containing boundary length solution. contains following columns: summary character description summary statistic. statistic associated \"overall\" value column calculated using entire solution (including management zones multiple zones). multiple management zones present, summary statistics also provided zone separately (indicated using zone names). boundary numeric exposed boundary length value. Greater values correspond solutions greater boundary length , turn, greater spatial fragmentation. Thus conservation planning exercises typically prefer solutions smaller values.","code":""},{"path":"https://prioritizr.net/reference/eval_boundary_summary.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Evaluate boundary length of solution — eval_boundary_summary","text":"summary statistic equivalent Connectivity_Edge metric reported Marxan software (Ball et al. 2009). calculated using equations used penalize solutions according total exposed boundary (.e., add_boundary_penalties()). See Examples section examples differences zone arguments can used calculate boundaries different combinations zones.","code":""},{"path":"https://prioritizr.net/reference/eval_boundary_summary.html","id":"data-format","dir":"Reference","previous_headings":"","what":"Data format","title":"Evaluate boundary length of solution — eval_boundary_summary","text":"argument data can specified using following formats. Note boundary data must always describe symmetric relationships planning units. data NULL value indicating data automatically calculated using boundary_matrix() function. argument default. Note boundary data must supplied using one formats planning unit data argument x explicitly contain spatial information (e.g., planning unit data data.frame numeric class). data matrix/Matrix object rows columns represent different planning units value cell represents amount shared boundary length two different planning units. Cells occur along matrix diagonal denote total boundary length associated planning unit. data data.frame object columns \"id1\", \"id2\", \"boundary\". \"id1\" \"id2\" columns contain identifiers (indices) pair planning units, \"boundary\" column contains amount shared boundary length two planning units. Additionally, values \"id1\" \"id2\" columns contain values, value denotes amount exposed boundary length (total boundary). format follows standard Marxan format boundary data (.e., per \"bound.dat\" file).","code":""},{"path":"https://prioritizr.net/reference/eval_boundary_summary.html","id":"solution-format","dir":"Reference","previous_headings":"","what":"Solution format","title":"Evaluate boundary length of solution — eval_boundary_summary","text":"Broadly speaking, argument solution must format planning unit data argument x. details correct format listed separately different planning unit data formats: x numeric planning units argument solution must numeric vector element corresponding different planning unit. number planning units argument x. Additionally, planning units missing cost (NA) values also missing (NA) values argument solution. x matrix planning units argument solution must matrix vector row corresponding different planning unit, column correspond different management zone. number planning units zones argument x. Additionally, planning units missing cost (NA) values particular zone also missing (NA) values argument solution. x terra::rast() planning units argument solution terra::rast() object different grid cells (pixels) correspond different planning units layers correspond different management zones. dimensionality (rows, columns, layers), resolution, extent, coordinate reference system planning units argument x. Additionally, planning units missing cost (NA) values particular zone also missing (NA)  values argument solution. x data.frame planning units argument solution must data.frame column corresponding different zone, row corresponding different planning unit, cell values corresponding solution value. means data.frame object containing solution also contains additional columns, columns need subsetted prior using function (see example sf::sf() data). Additionally, planning units missing cost (NA) values particular zone also missing (NA) values argument solution. x sf::sf() planning units argument solution must sf::sf() object column corresponding different zone, row corresponding different planning unit, cell values corresponding solution value. means sf::sf() object containing solution also contains additional columns, columns need subsetted prior using function (see example). Additionally, argument solution must also coordinate reference system planning unit data. Furthermore, planning units missing cost (NA) values particular zone also missing (NA) values argument solution.","code":""},{"path":"https://prioritizr.net/reference/eval_boundary_summary.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Evaluate boundary length of solution — eval_boundary_summary","text":"Ball IR, Possingham HP, Watts M (2009) Marxan relatives: Software spatial conservation prioritisation Spatial conservation prioritisation: Quantitative methods computational tools. Eds Moilanen , Wilson KA, Possingham HP. Oxford University Press, Oxford, UK.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/eval_boundary_summary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate boundary length of solution — eval_boundary_summary","text":"","code":"# \\dontrun{ # set seed for reproducibility set.seed(500)  # load data sim_pu_raster <- get_sim_pu_raster() sim_pu_polygons <- get_sim_pu_polygons() sim_features <- get_sim_features() sim_zones_pu_polygons <- get_sim_zones_pu_polygons() sim_zones_features <- get_sim_zones_features()  # build minimal conservation problem with raster data p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve the problem s1 <- solve(p1)  # print solution print(s1) #> class       : SpatRaster  #> dimensions  : 10, 10, 1  (nrow, ncol, nlyr) #> resolution  : 0.1, 0.1  (x, y) #> extent      : 0, 1, 0, 1  (xmin, xmax, ymin, ymax) #> coord. ref. : Undefined Cartesian SRS  #> source(s)   : memory #> name        : layer  #> min value   :     0  #> max value   :     1   # plot solution plot(s1, main = \"solution\", axes = FALSE)   # calculate boundary associated with the solution r1 <- eval_boundary_summary(p1, s1) print(r1) #> # A tibble: 1 × 2 #>   summary boundary #>   <chr>      <dbl> #> 1 overall     2.25  # build minimal conservation problem with polygon data p2 <-   problem(sim_pu_polygons, sim_features, cost_column = \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve the problem s2 <- solve(p2)  # print solution print(s2) #> Simple feature collection with 90 features and 4 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 0 ymin: 0 xmax: 1 ymax: 1 #> Projected CRS: Undefined Cartesian SRS #> # A tibble: 90 × 5 #>     cost locked_in locked_out solution_1                                    geom #>    <dbl> <lgl>     <lgl>           <dbl>                           <POLYGON [m]> #>  1  216. FALSE     FALSE               0     ((0 1, 0.1 1, 0.1 0.9, 0 0.9, 0 1)) #>  2  213. FALSE     FALSE               0 ((0.1 1, 0.2 1, 0.2 0.9, 0.1 0.9, 0.1 … #>  3  207. FALSE     FALSE               0 ((0.2 1, 0.3 1, 0.3 0.9, 0.2 0.9, 0.2 … #>  4  209. FALSE     TRUE                0 ((0.3 1, 0.4 1, 0.4 0.9, 0.3 0.9, 0.3 … #>  5  214. FALSE     FALSE               0 ((0.4 1, 0.5 1, 0.5 0.9, 0.4 0.9, 0.4 … #>  6  214. FALSE     FALSE               0 ((0.5 1, 0.6 1, 0.6 0.9, 0.5 0.9, 0.5 … #>  7  210. FALSE     FALSE               0 ((0.6 1, 0.7 1, 0.7 0.9, 0.6 0.9, 0.6 … #>  8  211. FALSE     TRUE                0 ((0.7 1, 0.8 1, 0.8 0.9, 0.7 0.9, 0.7 … #>  9  210. FALSE     FALSE               0 ((0.8 1, 0.9 1, 0.9 0.9, 0.8 0.9, 0.8 … #> 10  204. FALSE     FALSE               0   ((0.9 1, 1 1, 1 0.9, 0.9 0.9, 0.9 1)) #> # ℹ 80 more rows  # plot solution plot(s2[, \"solution_1\"])   # calculate boundary associated with the solution r2 <- eval_boundary_summary(p2, s2[, \"solution_1\"]) print(r2) #> # A tibble: 1 × 2 #>   summary boundary #>   <chr>      <dbl> #> 1 overall     2.05  # build multi-zone conservation problem with polygon data p3 <-   problem(     sim_zones_pu_polygons, sim_zones_features,     cost_column = c(\"cost_1\", \"cost_2\", \"cost_3\")   ) %>%   add_min_set_objective() %>%   add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve the problem s3 <- solve(p3)  # print solution print(s3) #> Simple feature collection with 90 features and 9 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 0 ymin: 0 xmax: 1 ymax: 1 #> Projected CRS: Undefined Cartesian SRS #> # A tibble: 90 × 10 #>    cost_1 cost_2 cost_3 locked_1 locked_2 locked_3 solution_1_zone_1 #>     <dbl>  <dbl>  <dbl> <lgl>    <lgl>    <lgl>                <dbl> #>  1   216.   183.   205. FALSE    FALSE    FALSE                    0 #>  2   213.   189.   210. FALSE    FALSE    FALSE                    0 #>  3   207.   194.   215. TRUE     FALSE    FALSE                    0 #>  4   209.   198.   219. FALSE    FALSE    FALSE                    0 #>  5   214.   200.   221. FALSE    FALSE    FALSE                    0 #>  6   214.   203.   225. FALSE    FALSE    FALSE                    0 #>  7   211.   209.   223. FALSE    FALSE    FALSE                    0 #>  8   210.   212.   222. TRUE     FALSE    FALSE                    0 #>  9   204.   218.   214. FALSE    FALSE    FALSE                    0 #> 10   213.   183.   206. FALSE    FALSE    FALSE                    0 #> # ℹ 80 more rows #> # ℹ 3 more variables: solution_1_zone_2 <dbl>, solution_1_zone_3 <dbl>, #> #   geom <POLYGON [m]>  # create new column representing the zone id that each planning unit # was allocated to in the solution s3$solution <- category_vector(   s3[, c(\"solution_1_zone_1\", \"solution_1_zone_2\", \"solution_1_zone_3\")] ) s3$solution <- factor(s3$solution)  # plot solution plot(s3[, \"solution\"])   # calculate boundary associated with the solution # here we will use the default argument for zones which treats each # zone as completely separate, meaning that the \"overall\" # boundary is just the sum of the boundaries for each zone r3 <- eval_boundary_summary(   p3, s3[, c(\"solution_1_zone_1\", \"solution_1_zone_2\", \"solution_1_zone_3\")] ) print(r3) #> # A tibble: 4 × 2 #>   summary boundary #>   <chr>      <dbl> #> 1 overall     14.2 #> 2 zone_1       4.7 #> 3 zone_2       4.9 #> 4 zone_3       4.6  # let's calculate the overall exposed boundary across the entire # solution, assuming that the shared boundaries between planning # units allocated to different zones \"count\" just as much # as those for planning units allocated to the same zone  # in other words, let's calculate the overall exposed boundary # across the entire solution by \"combining\" all selected planning units # together (regardless of which zone they are allocated to in the solution) r3_combined <- eval_boundary_summary(   p3, zones = matrix(1, ncol = 3, nrow = 3),   s3[, c(\"solution_1_zone_1\", \"solution_1_zone_2\", \"solution_1_zone_3\")] ) print(r3_combined) #> # A tibble: 4 × 2 #>   summary boundary #>   <chr>      <dbl> #> 1 overall     8.80 #> 2 zone_1      4.7  #> 3 zone_2      4.9  #> 4 zone_3      4.6   # we can see that the \"overall\" boundary is now less than the # sum of the individual zone boundaries, because it does not # consider the shared boundary between two planning units allocated to # different zones as \"exposed\" when performing the calculations # }"},{"path":"https://prioritizr.net/reference/eval_connectivity_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate connectivity of solution — eval_connectivity_summary","title":"Evaluate connectivity of solution — eval_connectivity_summary","text":"Calculate connectivity held within solution conservation planning problem. summary statistic evaluates connectivity solution using pair-wise connectivity values combinations planning units. specifically designed symmetric connectivity data.","code":""},{"path":"https://prioritizr.net/reference/eval_connectivity_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate connectivity of solution — eval_connectivity_summary","text":"","code":"# S4 method for ConservationProblem,ANY,ANY,matrix eval_connectivity_summary(x, solution, zones, data)  # S4 method for ConservationProblem,ANY,ANY,Matrix eval_connectivity_summary(x, solution, zones, data)  # S4 method for ConservationProblem,ANY,ANY,data.frame eval_connectivity_summary(x, solution, zones, data)  # S4 method for ConservationProblem,ANY,ANY,dgCMatrix eval_connectivity_summary(x, solution, zones, data)  # S4 method for ConservationProblem,ANY,ANY,array eval_connectivity_summary(x, solution, zones, data)"},{"path":"https://prioritizr.net/reference/eval_connectivity_summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate connectivity of solution — eval_connectivity_summary","text":"x problem() object. solution numeric, matrix, data.frame, terra::rast(), sf::sf() object. argument format planning unit cost data argument x. See Solution format section information. zones matrix Matrix object describing level connectivity different zones. row column corresponds different zone argument x, cell values indicate level connectivity combination zones. Cell values along diagonal matrix represent level connectivity planning units allocated zone. Cell values must lay 1 -1, negative values favor solutions weak connectivity. default argument zones identity matrix (.e., matrix ones along matrix diagonal zeros elsewhere), planning units considered connected allocated zone. argument required working multiple zones argument data matrix Matrix object. argument data array data.frame data multiple zones (e.g., using \"zone1\" \"zone2\" column names), argument must explicitly set NULL otherwise error thrown. data matrix, Matrix, data.frame, array object containing connectivity data. connectivity values correspond strength connectivity different planning units. Thus connections planning units associated higher values favorable solution. See Data format section information.","code":""},{"path":"https://prioritizr.net/reference/eval_connectivity_summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate connectivity of solution — eval_connectivity_summary","text":"tibble::tibble() object describing connectivity solution. contains following columns: summary character description summary statistic. statistic associated \"overall\" value column calculated using entire solution (including management zones multiple zones). multiple management zones present, summary statistics also provided zone separately (indicated using zone names). connectivity numeric connectivity value. Greater values correspond solutions associated greater connectivity. Thus conservation planning exercises typically prefer solutions greater values.","code":""},{"path":"https://prioritizr.net/reference/eval_connectivity_summary.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Evaluate connectivity of solution — eval_connectivity_summary","text":"summary statistic comparable Connectivity_In metric reported Marxan software (Ball et al. 2009). calculated using equations used penalize solutions connectivity data (.e., add_connectivity_penalties()). Specifically, calculated sum pair-wise connectivity values argument data, weighted value planning units solution.","code":""},{"path":"https://prioritizr.net/reference/eval_connectivity_summary.html","id":"solution-format","dir":"Reference","previous_headings":"","what":"Solution format","title":"Evaluate connectivity of solution — eval_connectivity_summary","text":"Broadly speaking, argument solution must format planning unit data argument x. details correct format listed separately different planning unit data formats: x numeric planning units argument solution must numeric vector element corresponding different planning unit. number planning units argument x. Additionally, planning units missing cost (NA) values also missing (NA) values argument solution. x matrix planning units argument solution must matrix vector row corresponding different planning unit, column correspond different management zone. number planning units zones argument x. Additionally, planning units missing cost (NA) values particular zone also missing (NA) values argument solution. x terra::rast() planning units argument solution terra::rast() object different grid cells (pixels) correspond different planning units layers correspond different management zones. dimensionality (rows, columns, layers), resolution, extent, coordinate reference system planning units argument x. Additionally, planning units missing cost (NA) values particular zone also missing (NA)  values argument solution. x data.frame planning units argument solution must data.frame column corresponding different zone, row corresponding different planning unit, cell values corresponding solution value. means data.frame object containing solution also contains additional columns, columns need subsetted prior using function (see example sf::sf() data). Additionally, planning units missing cost (NA) values particular zone also missing (NA) values argument solution. x sf::sf() planning units argument solution must sf::sf() object column corresponding different zone, row corresponding different planning unit, cell values corresponding solution value. means sf::sf() object containing solution also contains additional columns, columns need subsetted prior using function (see example). Additionally, argument solution must also coordinate reference system planning unit data. Furthermore, planning units missing cost (NA) values particular zone also missing (NA) values argument solution.","code":""},{"path":"https://prioritizr.net/reference/eval_connectivity_summary.html","id":"data-format","dir":"Reference","previous_headings":"","what":"Data format","title":"Evaluate connectivity of solution — eval_connectivity_summary","text":"argument data can specified using several different formats. data matrix/Matrix object rows columns represent different planning units value cell represents strength connectivity two different planning units. Cells occur along matrix diagonal treated weights indicate planning units desirable solution. argument zones can used control strength connectivity planning units different zones. default argument zones treat planning units allocated different zones zero connectivity. data data.frame object containing columns named \"id1\", \"id2\", \"boundary\". , row denotes connectivity pair planning units (per values \"id1\" \"id2\" columns) following Marxan format. argument x contains multiple zones, \"zone1\" \"zone2\" columns can optionally provided manually specify connectivity values planning units allocated specific zones. \"zone1\" \"zone2\" columns present, argument zones must NULL. data array object containing four-dimensions cell values indicate strength connectivity planning units assigned specific management zones. first two dimensions (.e., rows columns) indicate strength connectivity different planning units second two dimensions indicate different management zones. Thus data[1, 2, 3, 4] indicates strength connectivity planning unit 1 planning unit 2 planning unit 1 assigned zone 3 planning unit 2 assigned zone 4.","code":""},{"path":"https://prioritizr.net/reference/eval_connectivity_summary.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Evaluate connectivity of solution — eval_connectivity_summary","text":"Ball IR, Possingham HP, Watts M (2009) Marxan relatives: Software spatial conservation prioritisation Spatial conservation prioritisation: Quantitative methods computational tools. Eds Moilanen , Wilson KA, Possingham HP. Oxford University Press, Oxford, UK.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/eval_connectivity_summary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate connectivity of solution — eval_connectivity_summary","text":"","code":"# \\dontrun{ # set seed for reproducibility set.seed(500)  # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features() sim_zones_pu_polygons <- get_sim_zones_pu_polygons() sim_zones_features <- get_sim_zones_features()  # build minimal conservation problem with raster data p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve the problem s1 <- solve(p1)  # print solution print(s1) #> class       : SpatRaster  #> dimensions  : 10, 10, 1  (nrow, ncol, nlyr) #> resolution  : 0.1, 0.1  (x, y) #> extent      : 0, 1, 0, 1  (xmin, xmax, ymin, ymax) #> coord. ref. : Undefined Cartesian SRS  #> source(s)   : memory #> name        : layer  #> min value   :     0  #> max value   :     1   # plot solution plot(s1, main = \"solution\", axes = FALSE)   # simulate a connectivity matrix to describe the relative strength # of connectivity between different planning units # for brevity, we will use cost data here so that pairs # of adjacent planning units with higher cost values will have a # higher connectivity value # (but see ?connectivity_matrix for more information) cm1 <- connectivity_matrix(sim_pu_raster, sim_pu_raster)  # calculate connectivity associated with the solution r1 <- eval_connectivity_summary(p1, s1, data = cm1) print(r1) #> # A tibble: 1 × 2 #>   summary connectivity #>   <chr>          <dbl> #> 1 overall         198.  # build multi-zone conservation problem with polygon data p2 <-   problem(     sim_zones_pu_polygons, sim_zones_features,     cost_column = c(\"cost_1\", \"cost_2\", \"cost_3\")   ) %>%   add_min_set_objective() %>%   add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve the problem s2 <- solve(p2)  # print solution print(s2) #> Simple feature collection with 90 features and 9 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 0 ymin: 0 xmax: 1 ymax: 1 #> Projected CRS: Undefined Cartesian SRS #> # A tibble: 90 × 10 #>    cost_1 cost_2 cost_3 locked_1 locked_2 locked_3 solution_1_zone_1 #>     <dbl>  <dbl>  <dbl> <lgl>    <lgl>    <lgl>                <dbl> #>  1   216.   183.   205. FALSE    FALSE    FALSE                    0 #>  2   213.   189.   210. FALSE    FALSE    FALSE                    0 #>  3   207.   194.   215. TRUE     FALSE    FALSE                    0 #>  4   209.   198.   219. FALSE    FALSE    FALSE                    0 #>  5   214.   200.   221. FALSE    FALSE    FALSE                    0 #>  6   214.   203.   225. FALSE    FALSE    FALSE                    0 #>  7   211.   209.   223. FALSE    FALSE    FALSE                    0 #>  8   210.   212.   222. TRUE     FALSE    FALSE                    0 #>  9   204.   218.   214. FALSE    FALSE    FALSE                    0 #> 10   213.   183.   206. FALSE    FALSE    FALSE                    0 #> # ℹ 80 more rows #> # ℹ 3 more variables: solution_1_zone_2 <dbl>, solution_1_zone_3 <dbl>, #> #   geom <POLYGON [m]>  # create new column representing the zone id that each planning unit # was allocated to in the solution s2$solution <- category_vector(   s2[, c(\"solution_1_zone_1\", \"solution_1_zone_2\", \"solution_1_zone_3\")] ) s2$solution <- factor(s2$solution)  # plot solution plot(s2[, \"solution\"])   # simulate connectivity matrix # here, we will add a new column to sim_zones_pu_polygons with # randomly simulated values and create a connectivity matrix # based on the average simulated values of adjacent planning units sim_zones_pu_polygons$con <- runif(nrow(sim_zones_pu_polygons)) cm2 <- connectivity_matrix(sim_zones_pu_polygons, \"con\")  # calculate connectivity associated with the solution r2 <- eval_connectivity_summary(   p2, s2[, c(\"solution_1_zone_1\", \"solution_1_zone_2\", \"solution_1_zone_3\")],   data = cm2 ) print(r2) #> # A tibble: 4 × 2 #>   summary connectivity #>   <chr>          <dbl> #> 1 overall        2.06  #> 2 zone_1         0.775 #> 3 zone_2         0.516 #> 4 zone_3         0.771  # }"},{"path":"https://prioritizr.net/reference/eval_cost_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate cost of solution — eval_cost_summary","title":"Evaluate cost of solution — eval_cost_summary","text":"Calculate total cost solution conservation planning problem. example, planning unit cost data describe land acquisition costs (USD), total cost net cost (USD) needed acquire planning units selected within solution.","code":""},{"path":"https://prioritizr.net/reference/eval_cost_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate cost of solution — eval_cost_summary","text":"","code":"eval_cost_summary(x, solution)"},{"path":"https://prioritizr.net/reference/eval_cost_summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate cost of solution — eval_cost_summary","text":"x problem() object. solution numeric, matrix, data.frame, terra::rast(), sf::sf() object. argument format planning unit cost data argument x. See Solution format section information.","code":""},{"path":"https://prioritizr.net/reference/eval_cost_summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate cost of solution — eval_cost_summary","text":"tibble::tibble() object containing solution cost. contains following columns: summary character description summary statistic. statistic associated \"overall\" value column calculated using entire solution (including management zones multiple zones). multiple management zones present, summary statistics also provided zone separately (indicated using zone names). cost numeric cost value. Greater values correspond solutions costly implement. Thus conservation planning exercises typically prefer solutions smaller values, cheaper implement (assuming relevant factors, feature representation, equal).","code":""},{"path":"https://prioritizr.net/reference/eval_cost_summary.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Evaluate cost of solution — eval_cost_summary","text":"metric equivalent Cost metric reported Marxan software (Ball et al. 2009). Specifically, cost solution defined sum cost values, supplied creating problem() object (e.g., using cost_column argument), weighted status planning unit solution.","code":""},{"path":"https://prioritizr.net/reference/eval_cost_summary.html","id":"solution-format","dir":"Reference","previous_headings":"","what":"Solution format","title":"Evaluate cost of solution — eval_cost_summary","text":"Broadly speaking, argument solution must format planning unit data argument x. details correct format listed separately different planning unit data formats: x numeric planning units argument solution must numeric vector element corresponding different planning unit. number planning units argument x. Additionally, planning units missing cost (NA) values also missing (NA) values argument solution. x matrix planning units argument solution must matrix vector row corresponding different planning unit, column correspond different management zone. number planning units zones argument x. Additionally, planning units missing cost (NA) values particular zone also missing (NA) values argument solution. x terra::rast() planning units argument solution terra::rast() object different grid cells (pixels) correspond different planning units layers correspond different management zones. dimensionality (rows, columns, layers), resolution, extent, coordinate reference system planning units argument x. Additionally, planning units missing cost (NA) values particular zone also missing (NA)  values argument solution. x data.frame planning units argument solution must data.frame column corresponding different zone, row corresponding different planning unit, cell values corresponding solution value. means data.frame object containing solution also contains additional columns, columns need subsetted prior using function (see example sf::sf() data). Additionally, planning units missing cost (NA) values particular zone also missing (NA) values argument solution. x sf::sf() planning units argument solution must sf::sf() object column corresponding different zone, row corresponding different planning unit, cell values corresponding solution value. means sf::sf() object containing solution also contains additional columns, columns need subsetted prior using function (see example). Additionally, argument solution must also coordinate reference system planning unit data. Furthermore, planning units missing cost (NA) values particular zone also missing (NA) values argument solution.","code":""},{"path":"https://prioritizr.net/reference/eval_cost_summary.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Evaluate cost of solution — eval_cost_summary","text":"Ball IR, Possingham HP, Watts M (2009) Marxan relatives: Software spatial conservation prioritisation Spatial conservation prioritisation: Quantitative methods computational tools. Eds Moilanen , Wilson KA, Possingham HP. Oxford University Press, Oxford, UK.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/eval_cost_summary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate cost of solution — eval_cost_summary","text":"","code":"# \\dontrun{ # set seed for reproducibility set.seed(500)  # load data sim_pu_raster <- get_sim_pu_raster() sim_pu_polygons <- get_sim_pu_polygons() sim_features <- get_sim_features() sim_zones_pu_polygons <- get_sim_zones_pu_polygons() sim_zones_features <- get_sim_zones_features()  # build minimal conservation problem with raster data p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve the problem s1 <- solve(p1)  # print solution print(s1) #> class       : SpatRaster  #> dimensions  : 10, 10, 1  (nrow, ncol, nlyr) #> resolution  : 0.1, 0.1  (x, y) #> extent      : 0, 1, 0, 1  (xmin, xmax, ymin, ymax) #> coord. ref. : Undefined Cartesian SRS  #> source(s)   : memory #> name        : layer  #> min value   :     0  #> max value   :     1   # plot solution plot(s1, main = \"solution\", axes = FALSE)   # calculate cost of the solution r1 <- eval_cost_summary(p1, s1) print(r1) #> # A tibble: 1 × 2 #>   summary  cost #>   <chr>   <dbl> #> 1 overall 1987.  # build minimal conservation problem with polygon data p2 <-   problem(sim_pu_polygons, sim_features, cost_column = \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve the problem s2 <- solve(p2)  # plot solution plot(s2[, \"solution_1\"])   # print solution print(s2) #> Simple feature collection with 90 features and 4 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 0 ymin: 0 xmax: 1 ymax: 1 #> Projected CRS: Undefined Cartesian SRS #> # A tibble: 90 × 5 #>     cost locked_in locked_out solution_1                                    geom #>    <dbl> <lgl>     <lgl>           <dbl>                           <POLYGON [m]> #>  1  216. FALSE     FALSE               0     ((0 1, 0.1 1, 0.1 0.9, 0 0.9, 0 1)) #>  2  213. FALSE     FALSE               0 ((0.1 1, 0.2 1, 0.2 0.9, 0.1 0.9, 0.1 … #>  3  207. FALSE     FALSE               0 ((0.2 1, 0.3 1, 0.3 0.9, 0.2 0.9, 0.2 … #>  4  209. FALSE     TRUE                0 ((0.3 1, 0.4 1, 0.4 0.9, 0.3 0.9, 0.3 … #>  5  214. FALSE     FALSE               0 ((0.4 1, 0.5 1, 0.5 0.9, 0.4 0.9, 0.4 … #>  6  214. FALSE     FALSE               0 ((0.5 1, 0.6 1, 0.6 0.9, 0.5 0.9, 0.5 … #>  7  210. FALSE     FALSE               0 ((0.6 1, 0.7 1, 0.7 0.9, 0.6 0.9, 0.6 … #>  8  211. FALSE     TRUE                0 ((0.7 1, 0.8 1, 0.8 0.9, 0.7 0.9, 0.7 … #>  9  210. FALSE     FALSE               0 ((0.8 1, 0.9 1, 0.9 0.9, 0.8 0.9, 0.8 … #> 10  204. FALSE     FALSE               0   ((0.9 1, 1 1, 1 0.9, 0.9 0.9, 0.9 1)) #> # ℹ 80 more rows  # calculate cost of the solution r2 <- eval_cost_summary(p2, s2[, \"solution_1\"]) print(r2) #> # A tibble: 1 × 2 #>   summary  cost #>   <chr>   <dbl> #> 1 overall 1793.  # manually calculate cost of the solution r2_manual <- sum(s2$solution_1 * sim_pu_polygons$cost, na.rm = TRUE) print(r2_manual) #> [1] 1792.535  # build multi-zone conservation problem with polygon data p3 <-   problem(     sim_zones_pu_polygons, sim_zones_features,     cost_column = c(\"cost_1\", \"cost_2\", \"cost_3\")   ) %>%   add_min_set_objective() %>%   add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve the problem s3 <- solve(p3)  # print solution print(s3) #> Simple feature collection with 90 features and 9 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 0 ymin: 0 xmax: 1 ymax: 1 #> Projected CRS: Undefined Cartesian SRS #> # A tibble: 90 × 10 #>    cost_1 cost_2 cost_3 locked_1 locked_2 locked_3 solution_1_zone_1 #>     <dbl>  <dbl>  <dbl> <lgl>    <lgl>    <lgl>                <dbl> #>  1   216.   183.   205. FALSE    FALSE    FALSE                    0 #>  2   213.   189.   210. FALSE    FALSE    FALSE                    0 #>  3   207.   194.   215. TRUE     FALSE    FALSE                    0 #>  4   209.   198.   219. FALSE    FALSE    FALSE                    0 #>  5   214.   200.   221. FALSE    FALSE    FALSE                    0 #>  6   214.   203.   225. FALSE    FALSE    FALSE                    0 #>  7   211.   209.   223. FALSE    FALSE    FALSE                    0 #>  8   210.   212.   222. TRUE     FALSE    FALSE                    0 #>  9   204.   218.   214. FALSE    FALSE    FALSE                    0 #> 10   213.   183.   206. FALSE    FALSE    FALSE                    0 #> # ℹ 80 more rows #> # ℹ 3 more variables: solution_1_zone_2 <dbl>, solution_1_zone_3 <dbl>, #> #   geom <POLYGON [m]>  # create new column representing the zone id that each planning unit # was allocated to in the solution s3$solution <- category_vector(   s3[, c(\"solution_1_zone_1\", \"solution_1_zone_2\", \"solution_1_zone_3\")] ) s3$solution <- factor(s3$solution)  # plot solution plot(s3[, \"solution\"])   # calculate cost of the solution r3 <- eval_cost_summary(   p3, s3[, c(\"solution_1_zone_1\", \"solution_1_zone_2\", \"solution_1_zone_3\")] ) print(r3) #> # A tibble: 4 × 2 #>   summary   cost #>   <chr>    <dbl> #> 1 overall 10559. #> 2 zone_1   3409. #> 3 zone_2   3513. #> 4 zone_3   3638. # }"},{"path":"https://prioritizr.net/reference/eval_feature_representation_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate feature representation by solution — eval_feature_representation_summary","title":"Evaluate feature representation by solution — eval_feature_representation_summary","text":"Calculate well features represented solution conservation planning problem. summary statistics reported every feature, every zone, within conservation planning problem.","code":""},{"path":"https://prioritizr.net/reference/eval_feature_representation_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate feature representation by solution — eval_feature_representation_summary","text":"","code":"eval_feature_representation_summary(x, solution)"},{"path":"https://prioritizr.net/reference/eval_feature_representation_summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate feature representation by solution — eval_feature_representation_summary","text":"x problem() object. solution numeric, matrix, data.frame, terra::rast(), sf::sf() object. argument format planning unit cost data argument x. See Solution format section information.","code":""},{"path":"https://prioritizr.net/reference/eval_feature_representation_summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate feature representation by solution — eval_feature_representation_summary","text":"tibble::tibble() object describing feature representation. , row describes specific summary statistic (e.g., different management zone) specific feature. contains following columns: summary character description summary statistic. statistic associated \"overall\" value column calculated using entire solution (including management zones multiple zones). multiple management zones present, summary statistics also provided zone separately (indicated using zone names). feature character name feature. total_amount numeric total amount feature available entire conservation planning problem (just planning units selected within solution). calculated sum feature data, supplied creating problem() object (e.g., presence/absence values). absolute_held numeric total amount feature secured within solution. calculated sum feature data, supplied creating problem() object (e.g., presence/absence values), weighted status planning unit solution (e.g., selected prioritization). relative_held numeric proportion feature secured within solution. calculated dividing values \"absolute_held\" column \"total_amount\" column.","code":""},{"path":"https://prioritizr.net/reference/eval_feature_representation_summary.html","id":"solution-format","dir":"Reference","previous_headings":"","what":"Solution format","title":"Evaluate feature representation by solution — eval_feature_representation_summary","text":"Broadly speaking, argument solution must format planning unit data argument x. details correct format listed separately different planning unit data formats: x numeric planning units argument solution must numeric vector element corresponding different planning unit. number planning units argument x. Additionally, planning units missing cost (NA) values also missing (NA) values argument solution. x matrix planning units argument solution must matrix vector row corresponding different planning unit, column correspond different management zone. number planning units zones argument x. Additionally, planning units missing cost (NA) values particular zone also missing (NA) values argument solution. x terra::rast() planning units argument solution terra::rast() object different grid cells (pixels) correspond different planning units layers correspond different management zones. dimensionality (rows, columns, layers), resolution, extent, coordinate reference system planning units argument x. Additionally, planning units missing cost (NA) values particular zone also missing (NA)  values argument solution. x data.frame planning units argument solution must data.frame column corresponding different zone, row corresponding different planning unit, cell values corresponding solution value. means data.frame object containing solution also contains additional columns, columns need subsetted prior using function (see example sf::sf() data). Additionally, planning units missing cost (NA) values particular zone also missing (NA) values argument solution. x sf::sf() planning units argument solution must sf::sf() object column corresponding different zone, row corresponding different planning unit, cell values corresponding solution value. means sf::sf() object containing solution also contains additional columns, columns need subsetted prior using function (see example). Additionally, argument solution must also coordinate reference system planning unit data. Furthermore, planning units missing cost (NA) values particular zone also missing (NA) values argument solution.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/eval_feature_representation_summary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate feature representation by solution — eval_feature_representation_summary","text":"","code":"# \\dontrun{ # set seed for reproducibility set.seed(500)  # load data sim_pu_raster <- get_sim_pu_raster() sim_pu_polygons <- get_sim_pu_polygons() sim_features <- get_sim_features() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_pu_polygons <- get_sim_zones_pu_polygons() sim_zones_features <- get_sim_zones_features()  # create a simple conservation planning dataset so we can see exactly # how feature representation is calculated pu <- data.frame(   id = seq_len(10),   cost = c(0.2, NA, runif(8)),   spp1 = runif(10),   spp2 = c(rpois(9, 4), NA) )  # create problem p1 <-   problem(pu, c(\"spp1\", \"spp2\"), cost_column = \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # create a solution # specifically, a data.frame with a single column that contains # binary values indicating if each planning units was selected or not s1 <- data.frame(s = c(1, NA, rep(c(1, 0), 4))) print(s1) #>     s #> 1   1 #> 2  NA #> 3   1 #> 4   0 #> 5   1 #> 6   0 #> 7   1 #> 8   0 #> 9   1 #> 10  0  # calculate feature representation r1 <- eval_feature_representation_summary(p1, s1) print(r1) #> # A tibble: 2 × 5 #>   summary feature total_amount absolute_held relative_held #>   <chr>   <chr>          <dbl>         <dbl>         <dbl> #> 1 overall spp1            5.76          3.12         0.541 #> 2 overall spp2           33            14            0.424  # let's verify that feature representation calculations are correct # by manually performing the calculations and compare the results with r1 ## calculate total amount for each feature print(   setNames(     c(sum(pu$spp1, na.rm = TRUE), sum(pu$spp2, na.rm = TRUE)),     c(\"spp1\", \"spp2\")   ) ) #>      spp1      spp2  #>  5.755739 33.000000   ## calculate absolute amount held for each feature print(   setNames(     c(sum(pu$spp1 * s1$s, na.rm = TRUE), sum(pu$spp2 * s1$s, na.rm = TRUE)),     c(\"spp1\", \"spp2\")   ) ) #>      spp1      spp2  #>  3.116052 14.000000   ## calculate relative amount held for each feature print(   setNames(     c(       sum(pu$spp1 * s1$s, na.rm = TRUE) / sum(pu$spp1, na.rm = TRUE),       sum(pu$spp2 * s1$s, na.rm = TRUE) / sum(pu$spp2, na.rm = TRUE)     ),     c(\"spp1\", \"spp2\")   ) ) #>      spp1      spp2  #> 0.5413818 0.4242424   # solve problem using an exact algorithm solver s1_2 <- solve(p1) print(s1_2) #>    id      cost      spp1 spp2 solution_1 #> 1   1 0.2000000 0.8288314    4          1 #> 2   2        NA 0.7115770    3         NA #> 3   3 0.8336000 0.2820609    1          0 #> 4   4 0.7250118 0.8928427    6          0 #> 5   5 0.9753142 0.7647062    1          0 #> 6   6 0.4676038 0.1643470    4          0 #> 7   7 0.8122781 0.7320744    3          0 #> 8   8 0.2056958 0.2531062    6          0 #> 9   9 0.5121819 0.5083795    5          0 #> 10 10 0.9254660 0.6178138   NA          0  # calculate feature representation in this solution r1_2 <- eval_feature_representation_summary(   p1, s1_2[, \"solution_1\", drop = FALSE] ) print(r1_2) #> # A tibble: 2 × 5 #>   summary feature total_amount absolute_held relative_held #>   <chr>   <chr>          <dbl>         <dbl>         <dbl> #> 1 overall spp1            5.76         0.829         0.144 #> 2 overall spp2           33            4             0.121  # build minimal conservation problem with raster data p2 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s2 <- solve(p2)  # print solution print(s2) #> class       : SpatRaster  #> dimensions  : 10, 10, 1  (nrow, ncol, nlyr) #> resolution  : 0.1, 0.1  (x, y) #> extent      : 0, 1, 0, 1  (xmin, xmax, ymin, ymax) #> coord. ref. : Undefined Cartesian SRS  #> source(s)   : memory #> name        : layer  #> min value   :     0  #> max value   :     1   # calculate feature representation in the solution r2 <- eval_feature_representation_summary(p2, s2) print(r2) #> # A tibble: 5 × 5 #>   summary feature   total_amount absolute_held relative_held #>   <chr>   <chr>            <dbl>         <dbl>         <dbl> #> 1 overall feature_1         83.3          8.91         0.107 #> 2 overall feature_2         31.2          3.13         0.100 #> 3 overall feature_3         72.0          7.34         0.102 #> 4 overall feature_4         42.7          4.35         0.102 #> 5 overall feature_5         56.7          6.01         0.106  # plot solution plot(s2, main = \"solution\", axes = FALSE)   # build minimal conservation problem with polygon data p3 <-   problem(sim_pu_polygons, sim_features, cost_column = \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s3 <- solve(p3)  # print first six rows of the attribute table print(head(s3)) #> Simple feature collection with 6 features and 4 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 0 ymin: 0.9 xmax: 0.6 ymax: 1 #> Projected CRS: Undefined Cartesian SRS #> # A tibble: 6 × 5 #>    cost locked_in locked_out solution_1                                     geom #>   <dbl> <lgl>     <lgl>           <dbl>                            <POLYGON [m]> #> 1  216. FALSE     FALSE               0      ((0 1, 0.1 1, 0.1 0.9, 0 0.9, 0 1)) #> 2  213. FALSE     FALSE               0 ((0.1 1, 0.2 1, 0.2 0.9, 0.1 0.9, 0.1 1… #> 3  207. FALSE     FALSE               0 ((0.2 1, 0.3 1, 0.3 0.9, 0.2 0.9, 0.2 1… #> 4  209. FALSE     TRUE                0 ((0.3 1, 0.4 1, 0.4 0.9, 0.3 0.9, 0.3 1… #> 5  214. FALSE     FALSE               0 ((0.4 1, 0.5 1, 0.5 0.9, 0.4 0.9, 0.4 1… #> 6  214. FALSE     FALSE               0 ((0.5 1, 0.6 1, 0.6 0.9, 0.5 0.9, 0.5 1…  # calculate feature representation in the solution r3 <- eval_feature_representation_summary(p3, s3[, \"solution_1\"]) print(r3) #> # A tibble: 5 × 5 #>   summary feature   total_amount absolute_held relative_held #>   <chr>   <chr>            <dbl>         <dbl>         <dbl> #> 1 overall feature_1         74.5          8.05         0.108 #> 2 overall feature_2         28.1          2.83         0.101 #> 3 overall feature_3         64.9          6.65         0.103 #> 4 overall feature_4         38.2          3.87         0.101 #> 5 overall feature_5         50.7          5.41         0.107  # plot solution plot(s3[, \"solution_1\"], main = \"solution\", axes = FALSE)   # build multi-zone conservation problem with raster data p4 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_min_set_objective() %>%   add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s4 <- solve(p4)  # print solution print(s4) #> class       : SpatRaster  #> dimensions  : 10, 10, 3  (nrow, ncol, nlyr) #> resolution  : 0.1, 0.1  (x, y) #> extent      : 0, 1, 0, 1  (xmin, xmax, ymin, ymax) #> coord. ref. : Undefined Cartesian SRS  #> source(s)   : memory #> names       : zone_1, zone_2, zone_3  #> min values  :      0,      0,      0  #> max values  :      1,      1,      1   # calculate feature representation in the solution r4 <- eval_feature_representation_summary(p4, s4) print(r4) #> # A tibble: 20 × 5 #>    summary feature   total_amount absolute_held relative_held #>    <chr>   <chr>            <dbl>         <dbl>         <dbl> #>  1 overall feature_1        250.          45.8          0.183 #>  2 overall feature_2         93.6         17.7          0.189 #>  3 overall feature_3        216.          40.2          0.186 #>  4 overall feature_4        128.          23.7          0.186 #>  5 overall feature_5        170.          31.2          0.183 #>  6 zone_1  feature_1         83.3         16.0          0.192 #>  7 zone_1  feature_2         31.2          5.07         0.162 #>  8 zone_1  feature_3         72.0         13.2          0.183 #>  9 zone_1  feature_4         42.7          7.04         0.165 #> 10 zone_1  feature_5         56.7         11.2          0.197 #> 11 zone_2  feature_1         83.3         16.0          0.192 #> 12 zone_2  feature_2         31.2          6.45         0.207 #> 13 zone_2  feature_3         72.0         15.1          0.210 #> 14 zone_2  feature_4         42.7          8.22         0.193 #> 15 zone_2  feature_5         56.7         10.4          0.184 #> 16 zone_3  feature_1         83.3         13.8          0.166 #> 17 zone_3  feature_2         31.2          6.16         0.197 #> 18 zone_3  feature_3         72.0         11.9          0.165 #> 19 zone_3  feature_4         42.7          8.49         0.199 #> 20 zone_3  feature_5         56.7          9.58         0.169  # plot solution plot(category_layer(s4), main = \"solution\", axes = FALSE)   # build multi-zone conservation problem with polygon data p5 <-   problem(     sim_zones_pu_polygons, sim_zones_features,     cost_column = c(\"cost_1\", \"cost_2\", \"cost_3\")   ) %>%   add_min_set_objective() %>%   add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s5 <- solve(p5)  # print first six rows of the attribute table print(head(s5)) #> Simple feature collection with 6 features and 9 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 0 ymin: 0.9 xmax: 0.6 ymax: 1 #> Projected CRS: Undefined Cartesian SRS #> # A tibble: 6 × 10 #>   cost_1 cost_2 cost_3 locked_1 locked_2 locked_3 solution_1_zone_1 #>    <dbl>  <dbl>  <dbl> <lgl>    <lgl>    <lgl>                <dbl> #> 1   216.   183.   205. FALSE    FALSE    FALSE                    0 #> 2   213.   189.   210. FALSE    FALSE    FALSE                    0 #> 3   207.   194.   215. TRUE     FALSE    FALSE                    0 #> 4   209.   198.   219. FALSE    FALSE    FALSE                    0 #> 5   214.   200.   221. FALSE    FALSE    FALSE                    0 #> 6   214.   203.   225. FALSE    FALSE    FALSE                    0 #> # ℹ 3 more variables: solution_1_zone_2 <dbl>, solution_1_zone_3 <dbl>, #> #   geom <POLYGON [m]>  # calculate feature representation in the solution r5 <- eval_feature_representation_summary(   p5, s5[, c(\"solution_1_zone_1\", \"solution_1_zone_2\", \"solution_1_zone_3\")] ) print(r5) #> # A tibble: 20 × 5 #>    summary feature   total_amount absolute_held relative_held #>    <chr>   <chr>            <dbl>         <dbl>         <dbl> #>  1 overall feature_1        225.          40.9          0.182 #>  2 overall feature_2         83.9         13.8          0.164 #>  3 overall feature_3        195.          34.3          0.176 #>  4 overall feature_4        114.          18.7          0.164 #>  5 overall feature_5        154.          28.3          0.184 #>  6 zone_1  feature_1         75.1         14.9          0.198 #>  7 zone_1  feature_2         28.0          4.77         0.170 #>  8 zone_1  feature_3         65.0         12.7          0.195 #>  9 zone_1  feature_4         38.0          6.39         0.168 #> 10 zone_1  feature_5         51.2         10.2          0.200 #> 11 zone_2  feature_1         75.1         15.0          0.199 #> 12 zone_2  feature_2         28.0          5.02         0.179 #> 13 zone_2  feature_3         65.0         12.9          0.199 #> 14 zone_2  feature_4         38.0          6.03         0.158 #> 15 zone_2  feature_5         51.2         10.2          0.199 #> 16 zone_3  feature_1         75.1         11.1          0.148 #> 17 zone_3  feature_2         28.0          3.98         0.142 #> 18 zone_3  feature_3         65.0          8.71         0.134 #> 19 zone_3  feature_4         38.0          6.33         0.166 #> 20 zone_3  feature_5         51.2          7.84         0.153  # create new column representing the zone id that each planning unit # was allocated to in the solution s5$solution <- category_vector(   s5[, c(\"solution_1_zone_1\", \"solution_1_zone_2\", \"solution_1_zone_3\")] ) s5$solution <- factor(s5$solution)  # plot solution plot(s5[, \"solution\"])  # }"},{"path":"https://prioritizr.net/reference/eval_ferrier_importance.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate solution importance using Ferrier scores — eval_ferrier_importance","title":"Evaluate solution importance using Ferrier scores — eval_ferrier_importance","text":"Calculate importance scores planning units selected solution following Ferrier et al. (2000).","code":""},{"path":"https://prioritizr.net/reference/eval_ferrier_importance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate solution importance using Ferrier scores — eval_ferrier_importance","text":"","code":"eval_ferrier_importance(x, solution)  # S4 method for ConservationProblem,numeric eval_ferrier_importance(x, solution)  # S4 method for ConservationProblem,matrix eval_ferrier_importance(x, solution)  # S4 method for ConservationProblem,data.frame eval_ferrier_importance(x, solution)  # S4 method for ConservationProblem,Spatial eval_ferrier_importance(x, solution)  # S4 method for ConservationProblem,sf eval_ferrier_importance(x, solution)  # S4 method for ConservationProblem,Raster eval_ferrier_importance(x, solution)  # S4 method for ConservationProblem,SpatRaster eval_ferrier_importance(x, solution)"},{"path":"https://prioritizr.net/reference/eval_ferrier_importance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate solution importance using Ferrier scores — eval_ferrier_importance","text":"x problem() object. solution numeric, matrix, data.frame, terra::rast(), sf::sf() object. argument format planning unit cost data argument x. See Solution format section information.","code":""},{"path":"https://prioritizr.net/reference/eval_ferrier_importance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate solution importance using Ferrier scores — eval_ferrier_importance","text":"matrix, tibble::tibble(), terra::rast(), sf::st_sf() object containing scores planning unit selected solution. Specifically, returned object format (except planning units numeric vector) planning unit data argument x.","code":""},{"path":"https://prioritizr.net/reference/eval_ferrier_importance.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Evaluate solution importance using Ferrier scores — eval_ferrier_importance","text":"Importance scores reported separately feature within planning unit. Additionally, total importance score also calculated sum scores feature. Note function works problems use targets single zone. throw error problems meet criteria.","code":""},{"path":"https://prioritizr.net/reference/eval_ferrier_importance.html","id":"notes","dir":"Reference","previous_headings":"","what":"Notes","title":"Evaluate solution importance using Ferrier scores — eval_ferrier_importance","text":"previous versions, documentation function warning indicating mathematical formulation function required verification. mathematical formulation function since corrected verified, now function recommended general use.","code":""},{"path":"https://prioritizr.net/reference/eval_ferrier_importance.html","id":"solution-format","dir":"Reference","previous_headings":"","what":"Solution format","title":"Evaluate solution importance using Ferrier scores — eval_ferrier_importance","text":"Broadly speaking, argument solution must format planning unit data argument x. details correct format listed separately different planning unit data formats: x numeric planning units argument solution must numeric vector element corresponding different planning unit. number planning units argument x. Additionally, planning units missing cost (NA) values also missing (NA) values argument solution. x matrix planning units argument solution must matrix vector row corresponding different planning unit, column correspond different management zone. number planning units zones argument x. Additionally, planning units missing cost (NA) values particular zone also missing (NA) values argument solution. x terra::rast() planning units argument solution terra::rast() object different grid cells (pixels) correspond different planning units layers correspond different management zones. dimensionality (rows, columns, layers), resolution, extent, coordinate reference system planning units argument x. Additionally, planning units missing cost (NA) values particular zone also missing (NA)  values argument solution. x data.frame planning units argument solution must data.frame column corresponding different zone, row corresponding different planning unit, cell values corresponding solution value. means data.frame object containing solution also contains additional columns, columns need subsetted prior using function (see example sf::sf() data). Additionally, planning units missing cost (NA) values particular zone also missing (NA) values argument solution. x sf::sf() planning units argument solution must sf::sf() object column corresponding different zone, row corresponding different planning unit, cell values corresponding solution value. means sf::sf() object containing solution also contains additional columns, columns need subsetted prior using function (see example). Additionally, argument solution must also coordinate reference system planning unit data. Furthermore, planning units missing cost (NA) values particular zone also missing (NA) values argument solution.","code":""},{"path":"https://prioritizr.net/reference/eval_ferrier_importance.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Evaluate solution importance using Ferrier scores — eval_ferrier_importance","text":"Ferrier S, Pressey RL, Barrett TW (2000) new predictor irreplaceability areas achieving conservation goal, application real-world planning, research agenda refinement. Biological Conservation, 93: 303--325.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/eval_ferrier_importance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate solution importance using Ferrier scores — eval_ferrier_importance","text":"","code":"# \\dontrun{ # seed seed for reproducibility set.seed(600)  # load data sim_pu_raster <- get_sim_pu_raster() sim_pu_polygons <- get_sim_pu_polygons() sim_features <- get_sim_features()  # create minimal problem with binary decisions p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_default_solver(gap = 0, verbose = FALSE)  # solve problem s1 <- solve(p1)  # print solution print(s1) #> class       : SpatRaster  #> dimensions  : 10, 10, 1  (nrow, ncol, nlyr) #> resolution  : 0.1, 0.1  (x, y) #> extent      : 0, 1, 0, 1  (xmin, xmax, ymin, ymax) #> coord. ref. : Undefined Cartesian SRS  #> source(s)   : memory #> name        : layer  #> min value   :     0  #> max value   :     1   # plot solution plot(s1, main = \"solution\", axes = FALSE)   # calculate importance scores using Ferrier et al. 2000 method fs1 <- eval_ferrier_importance(p1, s1)  # print importance scores, # each planning unit has an importance score for each feature # (as indicated by the column names) and each planning unit also # has an overall total importance score (in the \"total\" column) print(fs1) #> class       : SpatRaster  #> dimensions  : 10, 10, 6  (nrow, ncol, nlyr) #> resolution  : 0.1, 0.1  (x, y) #> extent      : 0, 1, 0, 1  (xmin, xmax, ymin, ymax) #> coord. ref. : Undefined Cartesian SRS  #> source(s)   : memory #> varnames    : sim_pu_raster  #>               sim_pu_raster  #>               sim_pu_raster  #>               ... #> names       :   feature_1,   feature_2,   feature_3,   feature_4,   feature_5,      total  #> min values  : 0.000000000, 0.000000000, 0.000000000, 0.000000000, 0.000000000, 0.00000000  #> max values  : 0.003472042, 0.003596401, 0.003341572, 0.003768489, 0.003504223, 0.01641719   # plot total importance scores plot(fs1, main = names(fs1), axes = FALSE)   # create minimal problem with polygon planning units p2 <-   problem(sim_pu_polygons, sim_features, cost_column = \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.05) %>%   add_binary_decisions() %>%   add_default_solver(gap = 0, verbose = FALSE)  # solve problem s2 <- solve(p2)  # print solution print(s2) #> Simple feature collection with 90 features and 4 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 0 ymin: 0 xmax: 1 ymax: 1 #> Projected CRS: Undefined Cartesian SRS #> # A tibble: 90 × 5 #>     cost locked_in locked_out solution_1                                    geom #>    <dbl> <lgl>     <lgl>           <dbl>                           <POLYGON [m]> #>  1  216. FALSE     FALSE               0     ((0 1, 0.1 1, 0.1 0.9, 0 0.9, 0 1)) #>  2  213. FALSE     FALSE               0 ((0.1 1, 0.2 1, 0.2 0.9, 0.1 0.9, 0.1 … #>  3  207. FALSE     FALSE               0 ((0.2 1, 0.3 1, 0.3 0.9, 0.2 0.9, 0.2 … #>  4  209. FALSE     TRUE                0 ((0.3 1, 0.4 1, 0.4 0.9, 0.3 0.9, 0.3 … #>  5  214. FALSE     FALSE               0 ((0.4 1, 0.5 1, 0.5 0.9, 0.4 0.9, 0.4 … #>  6  214. FALSE     FALSE               0 ((0.5 1, 0.6 1, 0.6 0.9, 0.5 0.9, 0.5 … #>  7  210. FALSE     FALSE               0 ((0.6 1, 0.7 1, 0.7 0.9, 0.6 0.9, 0.6 … #>  8  211. FALSE     TRUE                0 ((0.7 1, 0.8 1, 0.8 0.9, 0.7 0.9, 0.7 … #>  9  210. FALSE     FALSE               0 ((0.8 1, 0.9 1, 0.9 0.9, 0.8 0.9, 0.8 … #> 10  204. FALSE     FALSE               0   ((0.9 1, 1 1, 1 0.9, 0.9 0.9, 0.9 1)) #> # ℹ 80 more rows  # plot solution plot(s2[, \"solution_1\"], main = \"solution\")   # calculate importance scores fs2 <- eval_ferrier_importance(p2, s2[, \"solution_1\"])  # plot importance scores plot(fs2)   # }"},{"path":"https://prioritizr.net/reference/eval_n_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate number of planning units selected by solution — eval_n_summary","title":"Evaluate number of planning units selected by solution — eval_n_summary","text":"Calculate number planning units selected within solution conservation planning problem.","code":""},{"path":"https://prioritizr.net/reference/eval_n_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate number of planning units selected by solution — eval_n_summary","text":"","code":"eval_n_summary(x, solution)"},{"path":"https://prioritizr.net/reference/eval_n_summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate number of planning units selected by solution — eval_n_summary","text":"x problem() object. solution numeric, matrix, data.frame, terra::rast(), sf::sf() object. argument format planning unit cost data argument x. See Solution format section information.","code":""},{"path":"https://prioritizr.net/reference/eval_n_summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate number of planning units selected by solution — eval_n_summary","text":"tibble::tibble() object containing number planning units selected within solution. contains following columns: summary character description summary statistic. statistic associated \"overall\" value column calculated using entire solution (including management zones multiple zones). multiple management zones present, summary statistics also provided zone separately (indicated using zone names). n numeric number selected planning units.","code":""},{"path":"https://prioritizr.net/reference/eval_n_summary.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Evaluate number of planning units selected by solution — eval_n_summary","text":"summary statistic calculated sum values solution. consequence, metric can produce non-integer value (e.g., 4.3) solutions containing proportion values (e.g., generated solving problem() built using add_proportion_decisions() function).","code":""},{"path":"https://prioritizr.net/reference/eval_n_summary.html","id":"solution-format","dir":"Reference","previous_headings":"","what":"Solution format","title":"Evaluate number of planning units selected by solution — eval_n_summary","text":"Broadly speaking, argument solution must format planning unit data argument x. details correct format listed separately different planning unit data formats: x numeric planning units argument solution must numeric vector element corresponding different planning unit. number planning units argument x. Additionally, planning units missing cost (NA) values also missing (NA) values argument solution. x matrix planning units argument solution must matrix vector row corresponding different planning unit, column correspond different management zone. number planning units zones argument x. Additionally, planning units missing cost (NA) values particular zone also missing (NA) values argument solution. x terra::rast() planning units argument solution terra::rast() object different grid cells (pixels) correspond different planning units layers correspond different management zones. dimensionality (rows, columns, layers), resolution, extent, coordinate reference system planning units argument x. Additionally, planning units missing cost (NA) values particular zone also missing (NA)  values argument solution. x data.frame planning units argument solution must data.frame column corresponding different zone, row corresponding different planning unit, cell values corresponding solution value. means data.frame object containing solution also contains additional columns, columns need subsetted prior using function (see example sf::sf() data). Additionally, planning units missing cost (NA) values particular zone also missing (NA) values argument solution. x sf::sf() planning units argument solution must sf::sf() object column corresponding different zone, row corresponding different planning unit, cell values corresponding solution value. means sf::sf() object containing solution also contains additional columns, columns need subsetted prior using function (see example). Additionally, argument solution must also coordinate reference system planning unit data. Furthermore, planning units missing cost (NA) values particular zone also missing (NA) values argument solution.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/eval_n_summary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate number of planning units selected by solution — eval_n_summary","text":"","code":"# \\dontrun{ # set seed for reproducibility set.seed(500)  # load data sim_pu_raster <- get_sim_pu_raster() sim_pu_polygons <- get_sim_pu_polygons() sim_features <- get_sim_features() sim_zones_pu_polygons <- get_sim_zones_pu_polygons() sim_zones_features <- get_sim_zones_features()  # build minimal conservation problem with raster data p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve the problem s1 <- solve(p1)  # print solution print(s1) #> class       : SpatRaster  #> dimensions  : 10, 10, 1  (nrow, ncol, nlyr) #> resolution  : 0.1, 0.1  (x, y) #> extent      : 0, 1, 0, 1  (xmin, xmax, ymin, ymax) #> coord. ref. : Undefined Cartesian SRS  #> source(s)   : memory #> name        : layer  #> min value   :     0  #> max value   :     1   # plot solution plot(s1, main = \"solution\", axes = FALSE)   # calculate number of selected planning units within solution r1 <- eval_n_summary(p1, s1) print(r1) #> # A tibble: 1 × 2 #>   summary     n #>   <chr>   <dbl> #> 1 overall    10  # build minimal conservation problem with polygon data p2 <-   problem(sim_pu_polygons, sim_features, cost_column = \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve the problem s2 <- solve(p2)  # plot solution plot(s2[, \"solution_1\"])   # print solution print(s2) #> Simple feature collection with 90 features and 4 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 0 ymin: 0 xmax: 1 ymax: 1 #> Projected CRS: Undefined Cartesian SRS #> # A tibble: 90 × 5 #>     cost locked_in locked_out solution_1                                    geom #>    <dbl> <lgl>     <lgl>           <dbl>                           <POLYGON [m]> #>  1  216. FALSE     FALSE               0     ((0 1, 0.1 1, 0.1 0.9, 0 0.9, 0 1)) #>  2  213. FALSE     FALSE               0 ((0.1 1, 0.2 1, 0.2 0.9, 0.1 0.9, 0.1 … #>  3  207. FALSE     FALSE               0 ((0.2 1, 0.3 1, 0.3 0.9, 0.2 0.9, 0.2 … #>  4  209. FALSE     TRUE                0 ((0.3 1, 0.4 1, 0.4 0.9, 0.3 0.9, 0.3 … #>  5  214. FALSE     FALSE               0 ((0.4 1, 0.5 1, 0.5 0.9, 0.4 0.9, 0.4 … #>  6  214. FALSE     FALSE               0 ((0.5 1, 0.6 1, 0.6 0.9, 0.5 0.9, 0.5 … #>  7  210. FALSE     FALSE               0 ((0.6 1, 0.7 1, 0.7 0.9, 0.6 0.9, 0.6 … #>  8  211. FALSE     TRUE                0 ((0.7 1, 0.8 1, 0.8 0.9, 0.7 0.9, 0.7 … #>  9  210. FALSE     FALSE               0 ((0.8 1, 0.9 1, 0.9 0.9, 0.8 0.9, 0.8 … #> 10  204. FALSE     FALSE               0   ((0.9 1, 1 1, 1 0.9, 0.9 0.9, 0.9 1)) #> # ℹ 80 more rows  # calculate number of selected planning units within solution r2 <- eval_n_summary(p2, s2[, \"solution_1\"]) print(r2) #> # A tibble: 1 × 2 #>   summary     n #>   <chr>   <dbl> #> 1 overall     9  # manually calculate number of selected planning units r2_manual <- sum(s2$solution_1, na.rm = TRUE) print(r2_manual) #> [1] 9  # build multi-zone conservation problem with polygon data p3 <-   problem(     sim_zones_pu_polygons, sim_zones_features,     cost_column = c(\"cost_1\", \"cost_2\", \"cost_3\")   ) %>%   add_min_set_objective() %>%   add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve the problem s3 <- solve(p3)  # print solution print(s3) #> Simple feature collection with 90 features and 9 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 0 ymin: 0 xmax: 1 ymax: 1 #> Projected CRS: Undefined Cartesian SRS #> # A tibble: 90 × 10 #>    cost_1 cost_2 cost_3 locked_1 locked_2 locked_3 solution_1_zone_1 #>     <dbl>  <dbl>  <dbl> <lgl>    <lgl>    <lgl>                <dbl> #>  1   216.   183.   205. FALSE    FALSE    FALSE                    0 #>  2   213.   189.   210. FALSE    FALSE    FALSE                    0 #>  3   207.   194.   215. TRUE     FALSE    FALSE                    0 #>  4   209.   198.   219. FALSE    FALSE    FALSE                    0 #>  5   214.   200.   221. FALSE    FALSE    FALSE                    0 #>  6   214.   203.   225. FALSE    FALSE    FALSE                    0 #>  7   211.   209.   223. FALSE    FALSE    FALSE                    0 #>  8   210.   212.   222. TRUE     FALSE    FALSE                    0 #>  9   204.   218.   214. FALSE    FALSE    FALSE                    0 #> 10   213.   183.   206. FALSE    FALSE    FALSE                    0 #> # ℹ 80 more rows #> # ℹ 3 more variables: solution_1_zone_2 <dbl>, solution_1_zone_3 <dbl>, #> #   geom <POLYGON [m]>  # create new column representing the zone id that each planning unit # was allocated to in the solution s3$solution <- category_vector(   s3[, c(\"solution_1_zone_1\", \"solution_1_zone_2\", \"solution_1_zone_3\")] ) s3$solution <- factor(s3$solution)  # plot solution plot(s3[, \"solution\"])   # calculate number of selected planning units within solution r3 <- eval_n_summary(   p3, s3[, c(\"solution_1_zone_1\", \"solution_1_zone_2\", \"solution_1_zone_3\")] ) print(r3) #> # A tibble: 4 × 2 #>   summary     n #>   <chr>   <dbl> #> 1 overall    52 #> 2 zone_1     17 #> 3 zone_2     18 #> 4 zone_3     17 # }"},{"path":"https://prioritizr.net/reference/eval_rare_richness_importance.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate solution importance using rarity weighted richness scores — eval_rare_richness_importance","title":"Evaluate solution importance using rarity weighted richness scores — eval_rare_richness_importance","text":"Calculate importance scores planning units selected solution using rarity weighted richness scores (based Williams et al. 1996). method recommended large-scaled conservation planning exercises (.e., 100,000 planning units) importance scores calculated using methods feasible period time. rarity weighted richness scores () account cost different planning units, (ii) account multiple management zones, (iii) identify truly irreplaceable planning units --- unlike replacement cost metric suffer limitations.","code":""},{"path":"https://prioritizr.net/reference/eval_rare_richness_importance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate solution importance using rarity weighted richness scores — eval_rare_richness_importance","text":"","code":"eval_rare_richness_importance(x, solution, ...)  # S4 method for ConservationProblem,numeric eval_rare_richness_importance(x, solution, rescale, ...)  # S4 method for ConservationProblem,matrix eval_rare_richness_importance(x, solution, rescale, ...)  # S4 method for ConservationProblem,data.frame eval_rare_richness_importance(x, solution, rescale, ...)  # S4 method for ConservationProblem,Spatial eval_rare_richness_importance(x, solution, rescale, ...)  # S4 method for ConservationProblem,sf eval_rare_richness_importance(x, solution, rescale, ...)  # S4 method for ConservationProblem,Raster eval_rare_richness_importance(x, solution, rescale, ...)  # S4 method for ConservationProblem,SpatRaster eval_rare_richness_importance(x, solution, rescale, ...)"},{"path":"https://prioritizr.net/reference/eval_rare_richness_importance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate solution importance using rarity weighted richness scores — eval_rare_richness_importance","text":"x problem() object. solution numeric, matrix, data.frame, terra::rast(), sf::sf() object. argument format planning unit cost data argument x. See Solution format section information. ... used. rescale logical flag indicating replacement cost values -- excepting infinite (Inf) zero values -- rescaled range 0.01 1. Defaults TRUE.","code":""},{"path":"https://prioritizr.net/reference/eval_rare_richness_importance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate solution importance using rarity weighted richness scores — eval_rare_richness_importance","text":"numeric, matrix, data.frame, terra::rast(), sf::sf() object containing importance scores planning unit solution. Specifically, returned object format planning unit data argument x.","code":""},{"path":"https://prioritizr.net/reference/eval_rare_richness_importance.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Evaluate solution importance using rarity weighted richness scores — eval_rare_richness_importance","text":"Rarity weighted richness scores calculated using following terms. Let \\(\\) denote set planning units (indexed \\(\\)), let \\(J\\) denote set conservation features (indexed \\(j\\)), let \\(r_{ij}\\) denote amount feature \\(j\\) associated planning unit \\(\\), let \\(m_j\\) denote maximum value feature \\(j\\) \\(r_{ij}\\) planning units \\(\\\\). calculate rarity weighted richness (RWR) planning unit \\(k\\): $$   \\mathit{RWR}_{k} = \\sum_{j}^{J} \\frac{ \\frac{r_{ik}}{m_j} }{                                           \\sum_{}^{}r_{ij}}   $$","code":""},{"path":"https://prioritizr.net/reference/eval_rare_richness_importance.html","id":"solution-format","dir":"Reference","previous_headings":"","what":"Solution format","title":"Evaluate solution importance using rarity weighted richness scores — eval_rare_richness_importance","text":"Broadly speaking, argument solution must format planning unit data argument x. details correct format listed separately different planning unit data formats: x numeric planning units argument solution must numeric vector element corresponding different planning unit. number planning units argument x. Additionally, planning units missing cost (NA) values also missing (NA) values argument solution. x matrix planning units argument solution must matrix vector row corresponding different planning unit, column correspond different management zone. number planning units zones argument x. Additionally, planning units missing cost (NA) values particular zone also missing (NA) values argument solution. x terra::rast() planning units argument solution terra::rast() object different grid cells (pixels) correspond different planning units layers correspond different management zones. dimensionality (rows, columns, layers), resolution, extent, coordinate reference system planning units argument x. Additionally, planning units missing cost (NA) values particular zone also missing (NA)  values argument solution. x data.frame planning units argument solution must data.frame column corresponding different zone, row corresponding different planning unit, cell values corresponding solution value. means data.frame object containing solution also contains additional columns, columns need subsetted prior using function (see example sf::sf() data). Additionally, planning units missing cost (NA) values particular zone also missing (NA) values argument solution. x sf::sf() planning units argument solution must sf::sf() object column corresponding different zone, row corresponding different planning unit, cell values corresponding solution value. means sf::sf() object containing solution also contains additional columns, columns need subsetted prior using function (see example). Additionally, argument solution must also coordinate reference system planning unit data. Furthermore, planning units missing cost (NA) values particular zone also missing (NA) values argument solution.","code":""},{"path":"https://prioritizr.net/reference/eval_rare_richness_importance.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Evaluate solution importance using rarity weighted richness scores — eval_rare_richness_importance","text":"Williams P, Gibbons D, Margules C, Rebelo , Humphries C, Pressey RL (1996) comparison richness hotspots, rarity hotspots complementary areas conserving diversity using British birds. Conservation Biology, 10: 155--174.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/eval_rare_richness_importance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate solution importance using rarity weighted richness scores — eval_rare_richness_importance","text":"","code":"# \\dontrun{ # seed seed for reproducibility set.seed(600)  # load data sim_pu_raster <- get_sim_pu_raster() sim_pu_polygons <- get_sim_pu_polygons() sim_features <- get_sim_features()  # create minimal problem with raster planning units p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_default_solver(gap = 0, verbose = FALSE)  # solve problem s1 <- solve(p1)  # print solution print(s1) #> class       : SpatRaster  #> dimensions  : 10, 10, 1  (nrow, ncol, nlyr) #> resolution  : 0.1, 0.1  (x, y) #> extent      : 0, 1, 0, 1  (xmin, xmax, ymin, ymax) #> coord. ref. : Undefined Cartesian SRS  #> source(s)   : memory #> name        : layer  #> min value   :     0  #> max value   :     1   # plot solution plot(s1, main = \"solution\", axes = FALSE)   # calculate importance scores rwr1 <- eval_rare_richness_importance(p1, s1)  # print importance scores print(rwr1) #> class       : SpatRaster  #> dimensions  : 10, 10, 1  (nrow, ncol, nlyr) #> resolution  : 0.1, 0.1  (x, y) #> extent      : 0, 1, 0, 1  (xmin, xmax, ymin, ymax) #> coord. ref. : Undefined Cartesian SRS  #> source(s)   : memory #> varname     : sim_pu_raster  #> name        : rwr  #> min value   :   0  #> max value   :   1   # plot importance scores plot(rwr1, main = \"rarity weighted richness\", axes = FALSE)   # create minimal problem with polygon planning units p2 <-   problem(sim_pu_polygons, sim_features, cost_column = \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.05) %>%   add_binary_decisions() %>%   add_default_solver(gap = 0, verbose = FALSE)  # solve problem s2 <- solve(p2)  # print solution print(s2) #> Simple feature collection with 90 features and 4 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 0 ymin: 0 xmax: 1 ymax: 1 #> Projected CRS: Undefined Cartesian SRS #> # A tibble: 90 × 5 #>     cost locked_in locked_out solution_1                                    geom #>    <dbl> <lgl>     <lgl>           <dbl>                           <POLYGON [m]> #>  1  216. FALSE     FALSE               0     ((0 1, 0.1 1, 0.1 0.9, 0 0.9, 0 1)) #>  2  213. FALSE     FALSE               0 ((0.1 1, 0.2 1, 0.2 0.9, 0.1 0.9, 0.1 … #>  3  207. FALSE     FALSE               0 ((0.2 1, 0.3 1, 0.3 0.9, 0.2 0.9, 0.2 … #>  4  209. FALSE     TRUE                0 ((0.3 1, 0.4 1, 0.4 0.9, 0.3 0.9, 0.3 … #>  5  214. FALSE     FALSE               0 ((0.4 1, 0.5 1, 0.5 0.9, 0.4 0.9, 0.4 … #>  6  214. FALSE     FALSE               0 ((0.5 1, 0.6 1, 0.6 0.9, 0.5 0.9, 0.5 … #>  7  210. FALSE     FALSE               0 ((0.6 1, 0.7 1, 0.7 0.9, 0.6 0.9, 0.6 … #>  8  211. FALSE     TRUE                0 ((0.7 1, 0.8 1, 0.8 0.9, 0.7 0.9, 0.7 … #>  9  210. FALSE     FALSE               0 ((0.8 1, 0.9 1, 0.9 0.9, 0.8 0.9, 0.8 … #> 10  204. FALSE     FALSE               0   ((0.9 1, 1 1, 1 0.9, 0.9 0.9, 0.9 1)) #> # ℹ 80 more rows  # plot solution plot(s2[, \"solution_1\"], main = \"solution\")   # calculate importance scores rwr2 <- eval_rare_richness_importance(p2, s2[, \"solution_1\"])  # plot importance scores plot(rwr2, main = \"rarity weighted richness\")  # }"},{"path":"https://prioritizr.net/reference/eval_replacement_importance.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate solution importance using replacement cost scores — eval_replacement_importance","title":"Evaluate solution importance using replacement cost scores — eval_replacement_importance","text":"Calculate importance scores planning units selected solution based replacement cost method (Cabeza Moilanen 2006).","code":""},{"path":"https://prioritizr.net/reference/eval_replacement_importance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate solution importance using replacement cost scores — eval_replacement_importance","text":"","code":"eval_replacement_importance(x, solution, ...)  # S4 method for ConservationProblem,numeric eval_replacement_importance(x, solution, rescale, run_checks, force, threads, ...)  # S4 method for ConservationProblem,matrix eval_replacement_importance(x, solution, rescale, run_checks, force, threads, ...)  # S4 method for ConservationProblem,data.frame eval_replacement_importance(x, solution, rescale, run_checks, force, threads, ...)  # S4 method for ConservationProblem,Spatial eval_replacement_importance(x, solution, rescale, run_checks, force, threads, ...)  # S4 method for ConservationProblem,sf eval_replacement_importance(x, solution, rescale, run_checks, force, threads, ...)  # S4 method for ConservationProblem,Raster eval_replacement_importance(x, solution, rescale, run_checks, force, threads, ...)  # S4 method for ConservationProblem,SpatRaster eval_replacement_importance(x, solution, rescale, run_checks, force, threads, ...)"},{"path":"https://prioritizr.net/reference/eval_replacement_importance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate solution importance using replacement cost scores — eval_replacement_importance","text":"x problem() object. solution numeric, matrix, data.frame, terra::rast(), sf::sf() object. argument format planning unit cost data argument x. See Solution format section information. ... used. rescale logical flag indicating replacement cost values -- excepting infinite (Inf) zero values -- rescaled range 0.01 1. Defaults TRUE. run_checks logical flag indicating whether presolve checks run prior solving problem. checks performed using presolve_check() function. Defaults TRUE. Skipping checks may reduce run time large problems. force logical flag indicating attempt made solve problem even potential issues detected presolve checks. Defaults FALSE. threads integer number threads use optimization algorithm. Defaults 1 single thread used.","code":""},{"path":"https://prioritizr.net/reference/eval_replacement_importance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate solution importance using replacement cost scores — eval_replacement_importance","text":"numeric, matrix, data.frame, terra::rast(), sf::sf() object containing importance scores planning unit solution. Specifically, returned object format planning unit data argument x.","code":""},{"path":"https://prioritizr.net/reference/eval_replacement_importance.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Evaluate solution importance using replacement cost scores — eval_replacement_importance","text":"function implements modified version replacement cost method (Cabeza Moilanen 2006). Specifically, score planning unit calculated difference objective value solution planning unit locked optimization processes rerun selected planning units locked . words, replacement cost metric corresponds change solution quality incurred given planning unit acquired implementing solution next best planning unit (set planning units) need considered instead. Thus planning units higher score important (irreplaceable). example, using minimum set objective function (add_min_set_objective()), replacement cost scores correspond additional costs needed meet targets planning unit locked . using maximum utility objective function (add_max_utility_objective(), replacement cost scores correspond reduction utility planning unit locked . Infinite values mean feasible solution exists planning units locked ---absolutely essential obtaining solution (e.g., contain rare species found planning units locked ). Zeros values mean planning units can swapped planning units effect performance solution (e.g., selected due spatial fragmentation penalties). calculations can take long time complete large complex conservation planning problems. , recommend using method small moderate-sized conservation planning problems (e.g., < 30,000 planning units). reduce run time, recommend calculating scores without additional penalties (e.g., add_boundary_penalties()) spatial constraints (e.g., add_contiguity_constraints()). reduce run time, recommend using proportion-type decisions calculating scores (see example).","code":""},{"path":"https://prioritizr.net/reference/eval_replacement_importance.html","id":"solution-format","dir":"Reference","previous_headings":"","what":"Solution format","title":"Evaluate solution importance using replacement cost scores — eval_replacement_importance","text":"Broadly speaking, argument solution must format planning unit data argument x. details correct format listed separately different planning unit data formats: x numeric planning units argument solution must numeric vector element corresponding different planning unit. number planning units argument x. Additionally, planning units missing cost (NA) values also missing (NA) values argument solution. x matrix planning units argument solution must matrix vector row corresponding different planning unit, column correspond different management zone. number planning units zones argument x. Additionally, planning units missing cost (NA) values particular zone also missing (NA) values argument solution. x terra::rast() planning units argument solution terra::rast() object different grid cells (pixels) correspond different planning units layers correspond different management zones. dimensionality (rows, columns, layers), resolution, extent, coordinate reference system planning units argument x. Additionally, planning units missing cost (NA) values particular zone also missing (NA)  values argument solution. x data.frame planning units argument solution must data.frame column corresponding different zone, row corresponding different planning unit, cell values corresponding solution value. means data.frame object containing solution also contains additional columns, columns need subsetted prior using function (see example sf::sf() data). Additionally, planning units missing cost (NA) values particular zone also missing (NA) values argument solution. x sf::sf() planning units argument solution must sf::sf() object column corresponding different zone, row corresponding different planning unit, cell values corresponding solution value. means sf::sf() object containing solution also contains additional columns, columns need subsetted prior using function (see example). Additionally, argument solution must also coordinate reference system planning unit data. Furthermore, planning units missing cost (NA) values particular zone also missing (NA) values argument solution.","code":""},{"path":"https://prioritizr.net/reference/eval_replacement_importance.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Evaluate solution importance using replacement cost scores — eval_replacement_importance","text":"Cabeza M Moilanen (2006) Replacement cost: practical measure site value cost-effective reserve planning. Biological Conservation, 132: 336--342.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/eval_replacement_importance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate solution importance using replacement cost scores — eval_replacement_importance","text":"","code":"# \\dontrun{ # seed seed for reproducibility set.seed(600)  # load data sim_pu_raster <- get_sim_pu_raster() sim_pu_polygons <- get_sim_pu_polygons() sim_features <- get_sim_features() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_features <- get_sim_zones_features()  # create minimal problem with binary decisions p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_default_solver(gap = 0, verbose = FALSE)  # solve problem s1 <- solve(p1)  # print solution print(s1) #> class       : SpatRaster  #> dimensions  : 10, 10, 1  (nrow, ncol, nlyr) #> resolution  : 0.1, 0.1  (x, y) #> extent      : 0, 1, 0, 1  (xmin, xmax, ymin, ymax) #> coord. ref. : Undefined Cartesian SRS  #> source(s)   : memory #> name        : layer  #> min value   :     0  #> max value   :     1   # plot solution plot(s1, main = \"solution\", axes = FALSE)   # calculate importance scores rc1 <- eval_replacement_importance(p1, s1)  # print importance scores print(rc1) #> class       : SpatRaster  #> dimensions  : 10, 10, 1  (nrow, ncol, nlyr) #> resolution  : 0.1, 0.1  (x, y) #> extent      : 0, 1, 0, 1  (xmin, xmax, ymin, ymax) #> coord. ref. : Undefined Cartesian SRS  #> source(s)   : memory #> name        : rc  #> min value   :  0  #> max value   :  1   # plot importance scores plot(rc1, main = \"replacement cost\", axes = FALSE)   # since replacement cost scores can take a long time to calculate with # binary decisions, we can calculate them using proportion-type # decision variables. Note we are still calculating the scores for our # previous solution (s1), we are just using a different optimization # problem when calculating the scores. p2 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_proportion_decisions() %>%   add_default_solver(gap = 0, verbose = FALSE)  # calculate importance scores using proportion type decisions rc2 <- eval_replacement_importance(p2, s1)  # print importance scores based on proportion type decisions print(rc2) #> class       : SpatRaster  #> dimensions  : 10, 10, 1  (nrow, ncol, nlyr) #> resolution  : 0.1, 0.1  (x, y) #> extent      : 0, 1, 0, 1  (xmin, xmax, ymin, ymax) #> coord. ref. : Undefined Cartesian SRS  #> source(s)   : memory #> name        : rc  #> min value   :  0  #> max value   :  1   # plot importance scores based on proportion type decisions # we can see that the importance values in rc1 and rc2 are similar, # and this confirms that the proportion type decisions are a good # approximation plot(rc2, main = \"replacement cost\", axes = FALSE)   # create minimal problem with polygon planning units p3 <-   problem(sim_pu_polygons, sim_features, cost_column = \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.05) %>%   add_binary_decisions() %>%   add_default_solver(gap = 0, verbose = FALSE)  # solve problem s3 <- solve(p3)  # print solution print(s3) #> Simple feature collection with 90 features and 4 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 0 ymin: 0 xmax: 1 ymax: 1 #> Projected CRS: Undefined Cartesian SRS #> # A tibble: 90 × 5 #>     cost locked_in locked_out solution_1                                    geom #>    <dbl> <lgl>     <lgl>           <dbl>                           <POLYGON [m]> #>  1  216. FALSE     FALSE               0     ((0 1, 0.1 1, 0.1 0.9, 0 0.9, 0 1)) #>  2  213. FALSE     FALSE               0 ((0.1 1, 0.2 1, 0.2 0.9, 0.1 0.9, 0.1 … #>  3  207. FALSE     FALSE               0 ((0.2 1, 0.3 1, 0.3 0.9, 0.2 0.9, 0.2 … #>  4  209. FALSE     TRUE                0 ((0.3 1, 0.4 1, 0.4 0.9, 0.3 0.9, 0.3 … #>  5  214. FALSE     FALSE               0 ((0.4 1, 0.5 1, 0.5 0.9, 0.4 0.9, 0.4 … #>  6  214. FALSE     FALSE               0 ((0.5 1, 0.6 1, 0.6 0.9, 0.5 0.9, 0.5 … #>  7  210. FALSE     FALSE               0 ((0.6 1, 0.7 1, 0.7 0.9, 0.6 0.9, 0.6 … #>  8  211. FALSE     TRUE                0 ((0.7 1, 0.8 1, 0.8 0.9, 0.7 0.9, 0.7 … #>  9  210. FALSE     FALSE               0 ((0.8 1, 0.9 1, 0.9 0.9, 0.8 0.9, 0.8 … #> 10  204. FALSE     FALSE               0   ((0.9 1, 1 1, 1 0.9, 0.9 0.9, 0.9 1)) #> # ℹ 80 more rows  # plot solution plot(s3[, \"solution_1\"], main = \"solution\")   # calculate importance scores rc3 <- eval_rare_richness_importance(p3, s3[, \"solution_1\"])  # plot importance scores plot(rc3, main = \"replacement cost\")   # build multi-zone conservation problem with raster data p4 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_min_set_objective() %>%   add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %>%   add_binary_decisions() %>%   add_default_solver(gap = 0, verbose = FALSE)  # solve the problem s4 <- solve(p4) names(s4) <- paste0(\"zone \", seq_len(terra::nlyr(s4)))  # print solution print(s4) #> class       : SpatRaster  #> dimensions  : 10, 10, 3  (nrow, ncol, nlyr) #> resolution  : 0.1, 0.1  (x, y) #> extent      : 0, 1, 0, 1  (xmin, xmax, ymin, ymax) #> coord. ref. : Undefined Cartesian SRS  #> source(s)   : memory #> names       : zone 1, zone 2, zone 3  #> min values  :      0,      0,      0  #> max values  :      1,      1,      1   # plot solution # each panel corresponds to a different zone, and data show the # status of each planning unit in a given zone plot(s4, axes = FALSE)   # calculate importance scores rc4 <- eval_replacement_importance(p4, s4) names(rc4) <- paste0(\"zone \", seq_len(terra::nlyr(s4)))  # plot importance # each panel corresponds to a different zone, and data show the # importance of each planning unit in a given zone plot(rc4, axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/eval_target_coverage_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate target coverage by solution — eval_target_coverage_summary","title":"Evaluate target coverage by solution — eval_target_coverage_summary","text":"Calculate well feature representation targets met solution conservation planning problem. useful understanding features adequately represented solution. Note function can used problems contain targets.","code":""},{"path":"https://prioritizr.net/reference/eval_target_coverage_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate target coverage by solution — eval_target_coverage_summary","text":"","code":"eval_target_coverage_summary(   x,   solution,   include_zone = number_of_zones(x) > 1,   include_sense = number_of_zones(x) > 1 )"},{"path":"https://prioritizr.net/reference/eval_target_coverage_summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate target coverage by solution — eval_target_coverage_summary","text":"x problem() object. solution numeric, matrix, data.frame, terra::rast(), sf::sf() object. argument format planning unit cost data argument x. See Solution format section information. include_zone logical include zone column output? Defaults TRUE problems contain multiple zones. include_sense logical include sense column output? Defaults TRUE problems contain multiple zones.","code":""},{"path":"https://prioritizr.net/reference/eval_target_coverage_summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate target coverage by solution — eval_target_coverage_summary","text":"tibble::tibble() object. , row describes information different target. contains following columns: feature character name feature associated target. zone list character zone names associated target. column list-column format single target can correspond multiple zones (see add_manual_targets() details examples). example converting list-column format standard character column format, please see Examples section. column included argument include_zones TRUE. sense character sense associated target. Sense values specify nature target. Typically (e.g., using add_absolute_targets() add_relative_targets() functions), targets specified using sense values indicating total amount feature held within solution (ideally) greater equal threshold amount (.e.,  sense value \">=\"). Additionally, targets (.e., using add_manual_targets() function) can also specified using sense values indicating total amount feature held within solution must equal threshold amount (.e., sense value \"=\") smaller equal threshold amount (.e., sense value \"<=\"). column included argument include_sense TRUE. total_amount numeric total amount feature available across entire conservation planning problem meeting target (just planning units selected within solution). problems involving single zone, column calculated sum values given feature (similar values total_amount column produced eval_feature_representation_summary() function). problems involving multiple zones, column calculated sum values feature associated target (per \"feature\" column), across zones associated target (per \"zone\" column). absolute_target numeric total threshold amount associated target. absolute_held numeric total amount held within solution feature (relevant) zones associated target (per \"feature\" \"zone\" columns, respectively). column calculated sum feature data, supplied creating problem() object (e.g., presence/absence values), weighted status planning unit solution (e.g., selected prioritization). absolute_shortfall numeric total amount solution fails meet target. column calculated difference total amount held within solution feature (relevant) zones associated target (.e., \"absolute_held\" column) target total threshold amount (.e., \"absolute_target\" column), values set zero depending sense specified target (e.g., target sense >= difference set zero value \"absolute_held\" smaller \"absolute_target\" column). relative_target numeric proportion threshold amount associated target. column calculated dividing total threshold amount associated target (.e., \"absolute_target\" column) total amount associated target (.e., \"total_amount\" column). relative_held numeric proportion held within solution feature (relevant) zones associated target (per \"feature\" \"zone\" columns, respectively). column calculated dividing total amount held target (.e., \"absolute_held\" column) total amount target (.e., \"total_amount\" column). relative_shortfall numeric proportion solution fails meet target. column calculated dividing total shortfall target (.e., \"absolute_shortfall\" column) total amount target (.e., \"total_amount\" column). met logical indicating target met solution. column calculated checking total shortfall associated target (.e., \"absolute_shortfall\" column) equal zero.","code":""},{"path":"https://prioritizr.net/reference/eval_target_coverage_summary.html","id":"solution-format","dir":"Reference","previous_headings":"","what":"Solution format","title":"Evaluate target coverage by solution — eval_target_coverage_summary","text":"Broadly speaking, argument solution must format planning unit data argument x. details correct format listed separately different planning unit data formats: x numeric planning units argument solution must numeric vector element corresponding different planning unit. number planning units argument x. Additionally, planning units missing cost (NA) values also missing (NA) values argument solution. x matrix planning units argument solution must matrix vector row corresponding different planning unit, column correspond different management zone. number planning units zones argument x. Additionally, planning units missing cost (NA) values particular zone also missing (NA) values argument solution. x terra::rast() planning units argument solution terra::rast() object different grid cells (pixels) correspond different planning units layers correspond different management zones. dimensionality (rows, columns, layers), resolution, extent, coordinate reference system planning units argument x. Additionally, planning units missing cost (NA) values particular zone also missing (NA)  values argument solution. x data.frame planning units argument solution must data.frame column corresponding different zone, row corresponding different planning unit, cell values corresponding solution value. means data.frame object containing solution also contains additional columns, columns need subsetted prior using function (see example sf::sf() data). Additionally, planning units missing cost (NA) values particular zone also missing (NA) values argument solution. x sf::sf() planning units argument solution must sf::sf() object column corresponding different zone, row corresponding different planning unit, cell values corresponding solution value. means sf::sf() object containing solution also contains additional columns, columns need subsetted prior using function (see example). Additionally, argument solution must also coordinate reference system planning unit data. Furthermore, planning units missing cost (NA) values particular zone also missing (NA) values argument solution.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/eval_target_coverage_summary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate target coverage by solution — eval_target_coverage_summary","text":"","code":"# \\dontrun{ # set seed for reproducibility set.seed(500)  # load data sim_pu_raster <- get_sim_pu_raster() sim_pu_polygons <- get_sim_pu_polygons() sim_features <- get_sim_features() sim_zones_pu_polygons <- get_sim_zones_pu_polygons() sim_zones_features <- get_sim_zones_features()  # build minimal conservation problem with raster data p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve the problem s1 <- solve(p1)  # print solution print(s1) #> class       : SpatRaster  #> dimensions  : 10, 10, 1  (nrow, ncol, nlyr) #> resolution  : 0.1, 0.1  (x, y) #> extent      : 0, 1, 0, 1  (xmin, xmax, ymin, ymax) #> coord. ref. : Undefined Cartesian SRS  #> source(s)   : memory #> name        : layer  #> min value   :     0  #> max value   :     1   # plot solution plot(s1, main = \"solution\", axes = FALSE)   # calculate target coverage by the solution r1 <- eval_target_coverage_summary(p1, s1) print(r1, width = Inf) # note: `width = Inf` tells R to print all columns #> # A tibble: 5 × 9 #>   feature   met   total_amount absolute_target absolute_held absolute_shortfall #>   <chr>     <lgl>        <dbl>           <dbl>         <dbl>              <dbl> #> 1 feature_1 TRUE          83.3            8.33          8.91                  0 #> 2 feature_2 TRUE          31.2            3.12          3.13                  0 #> 3 feature_3 TRUE          72.0            7.20          7.34                  0 #> 4 feature_4 TRUE          42.7            4.27          4.35                  0 #> 5 feature_5 TRUE          56.7            5.67          6.01                  0 #>   relative_target relative_held relative_shortfall #>             <dbl>         <dbl>              <dbl> #> 1             0.1         0.107                  0 #> 2             0.1         0.100                  0 #> 3             0.1         0.102                  0 #> 4             0.1         0.102                  0 #> 5             0.1         0.106                  0  # build minimal conservation problem with polygon data p2 <-   problem(sim_pu_polygons, sim_features, cost_column = \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve the problem s2 <- solve(p2)  # print first six rows of the attribute table print(head(s2)) #> Simple feature collection with 6 features and 4 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 0 ymin: 0.9 xmax: 0.6 ymax: 1 #> Projected CRS: Undefined Cartesian SRS #> # A tibble: 6 × 5 #>    cost locked_in locked_out solution_1                                     geom #>   <dbl> <lgl>     <lgl>           <dbl>                            <POLYGON [m]> #> 1  216. FALSE     FALSE               0      ((0 1, 0.1 1, 0.1 0.9, 0 0.9, 0 1)) #> 2  213. FALSE     FALSE               0 ((0.1 1, 0.2 1, 0.2 0.9, 0.1 0.9, 0.1 1… #> 3  207. FALSE     FALSE               0 ((0.2 1, 0.3 1, 0.3 0.9, 0.2 0.9, 0.2 1… #> 4  209. FALSE     TRUE                0 ((0.3 1, 0.4 1, 0.4 0.9, 0.3 0.9, 0.3 1… #> 5  214. FALSE     FALSE               0 ((0.4 1, 0.5 1, 0.5 0.9, 0.4 0.9, 0.4 1… #> 6  214. FALSE     FALSE               0 ((0.5 1, 0.6 1, 0.6 0.9, 0.5 0.9, 0.5 1…  # plot solution plot(s2[, \"solution_1\"])   # calculate target coverage by the solution r2 <- eval_target_coverage_summary(p2, s2[, \"solution_1\"]) print(r2, width = Inf) #> # A tibble: 5 × 9 #>   feature   met   total_amount absolute_target absolute_held absolute_shortfall #>   <chr>     <lgl>        <dbl>           <dbl>         <dbl>              <dbl> #> 1 feature_1 TRUE          74.5            7.45          8.05                  0 #> 2 feature_2 TRUE          28.1            2.81          2.83                  0 #> 3 feature_3 TRUE          64.9            6.49          6.65                  0 #> 4 feature_4 TRUE          38.2            3.82          3.87                  0 #> 5 feature_5 TRUE          50.7            5.07          5.41                  0 #>   relative_target relative_held relative_shortfall #>             <dbl>         <dbl>              <dbl> #> 1             0.1         0.108                  0 #> 2             0.1         0.101                  0 #> 3             0.1         0.103                  0 #> 4             0.1         0.101                  0 #> 5             0.1         0.107                  0  # build multi-zone conservation problem with polygon data p3 <-   problem(     sim_zones_pu_polygons, sim_zones_features,     cost_column = c(\"cost_1\", \"cost_2\", \"cost_3\")   ) %>%   add_min_set_objective() %>%   add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve the problem s3 <- solve(p3)  # print solution print(s3) #> Simple feature collection with 90 features and 9 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 0 ymin: 0 xmax: 1 ymax: 1 #> Projected CRS: Undefined Cartesian SRS #> # A tibble: 90 × 10 #>    cost_1 cost_2 cost_3 locked_1 locked_2 locked_3 solution_1_zone_1 #>     <dbl>  <dbl>  <dbl> <lgl>    <lgl>    <lgl>                <dbl> #>  1   216.   183.   205. FALSE    FALSE    FALSE                    0 #>  2   213.   189.   210. FALSE    FALSE    FALSE                    0 #>  3   207.   194.   215. TRUE     FALSE    FALSE                    0 #>  4   209.   198.   219. FALSE    FALSE    FALSE                    0 #>  5   214.   200.   221. FALSE    FALSE    FALSE                    0 #>  6   214.   203.   225. FALSE    FALSE    FALSE                    0 #>  7   211.   209.   223. FALSE    FALSE    FALSE                    0 #>  8   210.   212.   222. TRUE     FALSE    FALSE                    0 #>  9   204.   218.   214. FALSE    FALSE    FALSE                    0 #> 10   213.   183.   206. FALSE    FALSE    FALSE                    0 #> # ℹ 80 more rows #> # ℹ 3 more variables: solution_1_zone_2 <dbl>, solution_1_zone_3 <dbl>, #> #   geom <POLYGON [m]>  # create new column representing the zone id that each planning unit # was allocated to in the solution s3$solution <- category_vector(   s3[, c(\"solution_1_zone_1\", \"solution_1_zone_2\", \"solution_1_zone_3\")] ) s3$solution <- factor(s3$solution)  # plot solution plot(s3[, \"solution\"])   # calculate target coverage by the solution r3 <- eval_target_coverage_summary(   p3, s3[, c(\"solution_1_zone_1\", \"solution_1_zone_2\", \"solution_1_zone_3\")] ) print(r3, width = Inf) #> # A tibble: 15 × 11 #>    feature   zone      sense met   total_amount absolute_target absolute_held #>    <chr>     <list>    <chr> <lgl>        <dbl>           <dbl>         <dbl> #>  1 feature_1 <chr [1]> >=    TRUE          75.1           13.8          14.9  #>  2 feature_2 <chr [1]> >=    TRUE          28.0            4.82          5.14 #>  3 feature_3 <chr [1]> >=    TRUE          65.0           12.8          12.8  #>  4 feature_4 <chr [1]> >=    TRUE          38.0            5.58          6.64 #>  5 feature_5 <chr [1]> >=    TRUE          51.2            9.27          9.96 #>  6 feature_1 <chr [1]> >=    TRUE          75.1            9.06         15.0  #>  7 feature_2 <chr [1]> >=    TRUE          28.0            4.23          5.58 #>  8 feature_3 <chr [1]> >=    TRUE          65.0           12.5          13.6  #>  9 feature_4 <chr [1]> >=    TRUE          38.0            6.96          7.14 #> 10 feature_5 <chr [1]> >=    TRUE          51.2            8.76          9.96 #> 11 feature_1 <chr [1]> >=    TRUE          75.1            9.63         13.3  #> 12 feature_2 <chr [1]> >=    TRUE          28.0            5.29          5.65 #> 13 feature_3 <chr [1]> >=    TRUE          65.0           11.5          11.8  #> 14 feature_4 <chr [1]> >=    TRUE          38.0            4.43          7.71 #> 15 feature_5 <chr [1]> >=    TRUE          51.2            8.86          9.04 #>    absolute_shortfall relative_target relative_held relative_shortfall #>                 <dbl>           <dbl>         <dbl>              <dbl> #>  1                  0           0.183         0.198                  0 #>  2                  0           0.173         0.184                  0 #>  3                  0           0.198         0.198                  0 #>  4                  0           0.147         0.175                  0 #>  5                  0           0.181         0.195                  0 #>  6                  0           0.121         0.200                  0 #>  7                  0           0.151         0.200                  0 #>  8                  0           0.193         0.210                  0 #>  9                  0           0.183         0.188                  0 #> 10                  0           0.171         0.195                  0 #> 11                  0           0.128         0.177                  0 #> 12                  0           0.189         0.202                  0 #> 13                  0           0.176         0.181                  0 #> 14                  0           0.116         0.203                  0 #> 15                  0           0.173         0.177                  0  # create a new column with character values containing the zone names, # by extracting these data out of the zone column # (which is in list-column format) r3$zone2 <- vapply(r3$zone, FUN.VALUE = character(1), paste, sep = \" & \")  # print r3 again to show the new column print(r3, width = Inf) #> # A tibble: 15 × 12 #>    feature   zone      sense met   total_amount absolute_target absolute_held #>    <chr>     <list>    <chr> <lgl>        <dbl>           <dbl>         <dbl> #>  1 feature_1 <chr [1]> >=    TRUE          75.1           13.8          14.9  #>  2 feature_2 <chr [1]> >=    TRUE          28.0            4.82          5.14 #>  3 feature_3 <chr [1]> >=    TRUE          65.0           12.8          12.8  #>  4 feature_4 <chr [1]> >=    TRUE          38.0            5.58          6.64 #>  5 feature_5 <chr [1]> >=    TRUE          51.2            9.27          9.96 #>  6 feature_1 <chr [1]> >=    TRUE          75.1            9.06         15.0  #>  7 feature_2 <chr [1]> >=    TRUE          28.0            4.23          5.58 #>  8 feature_3 <chr [1]> >=    TRUE          65.0           12.5          13.6  #>  9 feature_4 <chr [1]> >=    TRUE          38.0            6.96          7.14 #> 10 feature_5 <chr [1]> >=    TRUE          51.2            8.76          9.96 #> 11 feature_1 <chr [1]> >=    TRUE          75.1            9.63         13.3  #> 12 feature_2 <chr [1]> >=    TRUE          28.0            5.29          5.65 #> 13 feature_3 <chr [1]> >=    TRUE          65.0           11.5          11.8  #> 14 feature_4 <chr [1]> >=    TRUE          38.0            4.43          7.71 #> 15 feature_5 <chr [1]> >=    TRUE          51.2            8.86          9.04 #>    absolute_shortfall relative_target relative_held relative_shortfall zone2  #>                 <dbl>           <dbl>         <dbl>              <dbl> <chr>  #>  1                  0           0.183         0.198                  0 zone_1 #>  2                  0           0.173         0.184                  0 zone_1 #>  3                  0           0.198         0.198                  0 zone_1 #>  4                  0           0.147         0.175                  0 zone_1 #>  5                  0           0.181         0.195                  0 zone_1 #>  6                  0           0.121         0.200                  0 zone_2 #>  7                  0           0.151         0.200                  0 zone_2 #>  8                  0           0.193         0.210                  0 zone_2 #>  9                  0           0.183         0.188                  0 zone_2 #> 10                  0           0.171         0.195                  0 zone_2 #> 11                  0           0.128         0.177                  0 zone_3 #> 12                  0           0.189         0.202                  0 zone_3 #> 13                  0           0.176         0.181                  0 zone_3 #> 14                  0           0.116         0.203                  0 zone_3 #> 15                  0           0.173         0.177                  0 zone_3 # }"},{"path":"https://prioritizr.net/reference/fast_extract.html","id":null,"dir":"Reference","previous_headings":"","what":"Fast extract — fast_extract","title":"Fast extract — fast_extract","text":"Extract data terra::rast() object.","code":""},{"path":"https://prioritizr.net/reference/fast_extract.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fast extract — fast_extract","text":"","code":"fast_extract(x, y, ...)  # S4 method for Raster,Spatial fast_extract(x, y, fun = \"mean\", ...)  # S4 method for Raster,sfc fast_extract(x, y, fun = \"mean\", ...)  # S4 method for SpatRaster,sfc fast_extract(x, y, fun = \"mean\", ...)  # S4 method for Raster,sf fast_extract(x, y, fun = \"mean\", ...)  # S4 method for SpatRaster,sf fast_extract(x, y, fun = \"mean\", ...)"},{"path":"https://prioritizr.net/reference/fast_extract.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fast extract — fast_extract","text":"x terra::rast() object. y sf::sf() object. ... used. fun character name statistic summarize data. Defaults \"mean\". Available options include \"sum\" \"mean\". Defaults \"mean\".","code":""},{"path":"https://prioritizr.net/reference/fast_extract.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fast extract — fast_extract","text":"matrix containing summary amount feature within planning unit. Rows correspond different spatial features argument y columns correspond different raster layers argument x.","code":""},{"path":"https://prioritizr.net/reference/fast_extract.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fast extract — fast_extract","text":"performance function large terra::rast() objects can improved increasing GDAL cache size. default cache size 25 MB. example, following code can used set cache size 4 GB.   function simply wrapper uses exactextractr::exact_extract() polygon geometries, terra::extract() geometry types.","code":"terra::gdalCache(size = 4000)"},{"path":[]},{"path":"https://prioritizr.net/reference/fast_extract.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fast extract — fast_extract","text":"","code":"# load data sim_pu_polygons <- get_sim_pu_polygons() sim_features <- get_sim_features()  # extract data result <- fast_extract(sim_features, sim_pu_polygons)  # show result print(head(result)) #>           [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 0.7150548 0.2900901 0.8178213 0.2199663 0.4533809 #> [2,] 0.6990429 0.3052216 0.8064534 0.2713800 0.4413639 #> [3,] 0.6859317 0.3266036 0.7852441 0.3296247 0.4343547 #> [4,] 0.6783193 0.3510977 0.7541320 0.3900085 0.4355628 #> [5,] 0.6782107 0.3750470 0.7131559 0.4468281 0.4474871 #> [6,] 0.6863253 0.3950113 0.6628435 0.4946333 0.4714105"},{"path":"https://prioritizr.net/reference/feature_abundances.html","id":null,"dir":"Reference","previous_headings":"","what":"Feature abundances — feature_abundances","title":"Feature abundances — feature_abundances","text":"Calculate total abundance feature found planning units conservation planning problem.","code":""},{"path":"https://prioritizr.net/reference/feature_abundances.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Feature abundances — feature_abundances","text":"","code":"feature_abundances(x, na.rm)  # S3 method for ConservationProblem feature_abundances(x, na.rm = FALSE)"},{"path":"https://prioritizr.net/reference/feature_abundances.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Feature abundances — feature_abundances","text":"x problem() object. na.rm logical planning units NA cost data excluded abundance calculations? default argument FALSE.","code":""},{"path":"https://prioritizr.net/reference/feature_abundances.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Feature abundances — feature_abundances","text":"tibble::tibble() object containing total amount (\"absolute_abundance\") proportion (\"relative_abundance\") distribution feature planning units. , row contains data pertain specific feature specific management zone (multiple zones present). object contains following columns: feature character name feature. zone character name zone (included argument x contains one management zone). absolute_abundance numeric amount feature planning units. problem contains multiple zones, column shows well feature represented zone. relative_abundance numeric proportion feature's distribution planning units. argument na.rm FALSE, column contain values equal one. Otherwise, argument na.rm TRUE planning units NA cost data contain non-zero amounts feature, column contain values zero one.","code":""},{"path":"https://prioritizr.net/reference/feature_abundances.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Feature abundances — feature_abundances","text":"Planning units can cost data finite values (e.g., 0.1, 3, 100) NA values. functionality provided locations available protected area acquisition can included calculating targets conservation features (e.g., targets specified using add_relative_targets()). total amount feature planning units required---including planning units NA cost data---na.rm argument set FALSE. However, planning units NA cost data excluded---instance, calculate highest feasible targets feature---na.rm argument set TRUE.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/feature_abundances.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Feature abundances — feature_abundances","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features()  # create a simple conservation planning dataset so we can see exactly # how the feature abundances are calculated pu <- data.frame(   id = seq_len(10),   cost = c(0.2, NA, runif(8)),   spp1 = runif(10),   spp2 = c(rpois(9, 4), NA) )  # create problem p1 <- problem(pu, c(\"spp1\", \"spp2\"), cost_column = \"cost\")  # calculate feature abundances; including planning units with NA costs a1 <- feature_abundances(p1, na.rm = FALSE) # (default) print(a1) #> # A tibble: 2 × 3 #>   feature absolute_abundance relative_abundance #>   <chr>                <dbl>              <dbl> #> 1 spp1                  4.10                  1 #> 2 spp2                 31                     1  # calculate feature abundances; excluding planning units with NA costs a2 <- feature_abundances(p1, na.rm = TRUE) print(a2) #> # A tibble: 2 × 3 #>   feature absolute_abundance relative_abundance #>   <chr>                <dbl>              <dbl> #> 1 spp1                  3.84              0.935 #> 2 spp2                 28                 0.903  # verify correctness of feature abundance calculations all.equal(   a1$absolute_abundance,   c(sum(pu$spp1), sum(pu$spp2, na.rm = TRUE)) ) #> [1] TRUE  all.equal(   a1$relative_abundance,   c(sum(pu$spp1) / sum(pu$spp1),   sum(pu$spp2, na.rm = TRUE) / sum(pu$spp2, na.rm = TRUE)) ) #> [1] TRUE  all.equal(   a2$absolute_abundance,   c(     sum(pu$spp1[!is.na(pu$cost)]),     sum(pu$spp2[!is.na(pu$cost)], na.rm = TRUE)   ) ) #> [1] TRUE  all.equal(   a2$relative_abundance,   c(     sum(pu$spp1[!is.na(pu$cost)]) / sum(pu$spp1, na.rm = TRUE),     sum(pu$spp2[!is.na(pu$cost)], na.rm = TRUE) /       sum(pu$spp2, na.rm = TRUE)   ) ) #> [1] TRUE  # initialize conservation problem with raster data p3 <- problem(sim_pu_raster, sim_features)  # calculate feature abundances; including planning units with NA costs a3 <- feature_abundances(p3, na.rm = FALSE) # (default) print(a3) #> # A tibble: 5 × 3 #>   feature   absolute_abundance relative_abundance #>   <chr>                  <dbl>              <dbl> #> 1 feature_1               83.3                  1 #> 2 feature_2               31.2                  1 #> 3 feature_3               72.0                  1 #> 4 feature_4               42.7                  1 #> 5 feature_5               56.7                  1  # create problem using total amounts of features in all the planning units # (including units with NA cost data) p4 <-   p3 %>%   add_min_set_objective() %>%   add_relative_targets(a3$relative_abundance) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # attempt to solve the problem, but we will see that this problem is # infeasible because the targets cannot be met using only the planning units # with finite cost data s4 <- try(solve(p4)) #> Error in solve(p4) : Can't find a solution! #> ℹ This is because it is impossible to meet the targets, budgets, or #>   constraints.  # calculate feature abundances; excluding planning units with NA costs a5 <- feature_abundances(p3, na.rm = TRUE) print(a5) #> # A tibble: 5 × 3 #>   feature   absolute_abundance relative_abundance #>   <chr>                  <dbl>              <dbl> #> 1 feature_1               74.5              0.895 #> 2 feature_2               28.1              0.900 #> 3 feature_3               64.9              0.902 #> 4 feature_4               38.2              0.895 #> 5 feature_5               50.7              0.893  # create problem using total amounts of features in the planning units with # finite cost data p5 <-   p3 %>%   add_min_set_objective() %>%   add_relative_targets(a5$relative_abundance) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve the problem s5 <- solve(p5)  # plot the solution # this solution contains all the planning units with finite cost data # (i.e., cost data that do not have NA values) plot(s5)  # }"},{"path":"https://prioritizr.net/reference/feature_names.html","id":null,"dir":"Reference","previous_headings":"","what":"Feature names — feature_names","title":"Feature names — feature_names","text":"Extract names features object.","code":""},{"path":"https://prioritizr.net/reference/feature_names.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Feature names — feature_names","text":"","code":"feature_names(x, ...)  # S3 method for ConservationProblem feature_names(x, ...)  # S3 method for ZonesRaster feature_names(x, ...)  # S3 method for ZonesSpatRaster feature_names(x, ...)  # S3 method for ZonesCharacter feature_names(x, ...)"},{"path":"https://prioritizr.net/reference/feature_names.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Feature names — feature_names","text":"x problem() Zones() object. ... used.","code":""},{"path":"https://prioritizr.net/reference/feature_names.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Feature names — feature_names","text":"character vector feature names.","code":""},{"path":"https://prioritizr.net/reference/feature_names.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Feature names — feature_names","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features()  # create problem p <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.2) %>%   add_binary_decisions()  # print feature names print(feature_names(p)) #> [1] \"feature_1\" \"feature_2\" \"feature_3\" \"feature_4\" \"feature_5\" # }"},{"path":"https://prioritizr.net/reference/importance.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate solution importance — importance","title":"Evaluate solution importance — importance","text":"Importance scores (also known irreplaceability scores) can used assess relative importance planning units selected solution conservation planning problem.","code":""},{"path":"https://prioritizr.net/reference/importance.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Evaluate solution importance — importance","text":"following methods available calculating importance scores solution conservation planning problem(): eval_replacement_importance() Calculate importance scores using replacement costs (based Cabeza Moilanen 2006). scores quantify change objective function (e.g., additional costs required meet feature targets) optimal solution given planning unit solution acquired. can () account cost different planning units, (ii) account multiple management zones, (iii) apply objective function, (iv) identify truly irreplaceable planning units (denoted infinite values). eval_ferrier_importance() Calculate importance scores following Ferrier et al. (2000). scores measure importance based critical planning units meeting targets. can applied conservation problems use targets single zone (e.g., classic Marxan-type problem). Furthermore -- unlike replacement cost scores -- scores provide score feature within planning unit, providing insight certain planning units important planning units. eval_rare_richness_importance() Calculate importance scores using rarity weighted richness metric (based Williams et al. 1996). score simply measure biodiversity. account planning costs, multiple management zones, objective functions, feature targets (weightings). merely describe spatial patterns biodiversity, account many factors needed quantify importance planning unit achieving conservation goals. Broadly speaking, recommend using replacement cost scores possible. can applied type conservation planning problem -- regardless objective function number zones considered problem -- measure planning unit importance based degradation prioritization. Although replacement cost scores can calculated small moderate sized problems (e.g., less 30,000 planning units), may feasible particularly large problems (e.g., 100,000 planning units). cases, recommend calculating importance scores using Ferrier method. Ferrier method can calculated relatively quickly large-sized problems explicitly accounts representation targets. recommend using rarity weighted richness metric neither two methods can used.","code":""},{"path":"https://prioritizr.net/reference/importance.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Evaluate solution importance — importance","text":"Cabeza M Moilanen (2006) Replacement cost: practical measure site value cost-effective reserve planning. Biological Conservation, 132:  336--342. Ferrier S, Pressey RL, Barrett TW (2000) new predictor irreplaceability areas achieving conservation goal, application real-world planning, research agenda refinement. Biological Conservation, 93: 303--325. Williams P, Gibbons D, Margules C, Rebelo , Humphries C, Pressey RL (1996) comparison richness hotspots, rarity hotspots complementary areas conserving diversity using British birds. Conservation Biology, 10: 155--174.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/importance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate solution importance — importance","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features()  # build minimal conservation problem with raster data p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_default_solver(gap = 0, verbose = FALSE)  # solve the problem s1 <- solve(p1)  # plot solution plot(s1, main = \"solution\", axes = FALSE)   # calculate importance scores using replacement cost scores ir1 <- eval_replacement_importance(p1, s1)  # calculate importance scores using Ferrier et al 2000 method, # and extract the total importance scores ir2 <- eval_ferrier_importance(p1, s1)[[\"total\"]]  # calculate importance scores using rarity weighted richness scores ir3 <- eval_rare_richness_importance(p1, s1)  # create multi-band raster with different importance scores ir <- c(ir1, ir2, ir3) names(ir) <- c(   \"replacement cost\", \"Ferrier score\", \"rarity weighted richness\" )  # plot importance scores plot(ir, axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/intersecting_units.html","id":null,"dir":"Reference","previous_headings":"","what":"Find intersecting units — intersecting_units","title":"Find intersecting units — intersecting_units","text":"Find units spatial data object intersect units another spatial data object.","code":""},{"path":"https://prioritizr.net/reference/intersecting_units.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find intersecting units — intersecting_units","text":"","code":"intersecting_units(x, y)  # S4 method for Raster,ANY intersecting_units(x, y)  # S4 method for ANY,Raster intersecting_units(x, y)  # S4 method for Spatial,ANY intersecting_units(x, y)  # S4 method for ANY,Spatial intersecting_units(x, y)  # S4 method for SpatRaster,SpatRaster intersecting_units(x, y)  # S4 method for sf,sf intersecting_units(x, y)  # S4 method for SpatRaster,sf intersecting_units(x, y)  # S4 method for sf,SpatRaster intersecting_units(x, y)"},{"path":"https://prioritizr.net/reference/intersecting_units.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find intersecting units — intersecting_units","text":"x sf::st_sf() terra::rast() object. y sf::st_sf() terra::rast() object.","code":""},{"path":"https://prioritizr.net/reference/intersecting_units.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find intersecting units — intersecting_units","text":"integer vector indices units x intersect y.","code":""},{"path":"https://prioritizr.net/reference/intersecting_units.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find intersecting units — intersecting_units","text":"performance function large terra::rast() objects can improved increasing GDAL cache size. default cache size 25 MB. example, following code can used set cache size 4 GB.","code":"terra::gdalCache(size = 4000)"},{"path":[]},{"path":"https://prioritizr.net/reference/intersecting_units.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find intersecting units — intersecting_units","text":"","code":"# \\dontrun{ # create data r <- terra::rast(matrix(1:9, byrow = TRUE, ncol = 3)) r_with_holes <- r r_with_holes[c(1, 5, 9)] <- NA ply <- sf::st_as_sf(terra::as.polygons(r)) ply_with_holes <- sf::st_as_sf(terra::as.polygons(r_with_holes))  # intersect raster with raster par(mfrow = c(1, 2)) plot(r, main = \"x = SpatRaster\", axes = FALSE) plot(r_with_holes, main = \"y = SpatRaster\", axes = FALSE)  print(intersecting_units(r, r_with_holes)) #> [1] 2 3 4 6 7 8  # intersect raster with sf par(mfrow = c(1, 2)) plot(r, main = \"x = SpatRaster\", axes = FALSE) plot(ply_with_holes, main = \"y = sf\", key.pos = NULL, reset = FALSE)  print(intersecting_units(r, ply_with_holes)) #> [1] 2 3 4 6 7 8  # intersect sf with raster par(mfrow = c(1, 2)) plot(ply, main = \"x = sf\", key.pos = NULL, reset = FALSE) plot(r_with_holes, main = \"y = SpatRaster\")  print(intersecting_units(ply, r_with_holes)) #> [1] 2 3 4 6 7 8  # intersect sf with sf par(mfrow = c(1, 2)) plot(ply, main = \"x = sf\", key.pos = NULL, reset = FALSE) plot(ply_with_holes, main = \"y = sf\", key.pos = NULL, reset = FALSE)  print(intersecting_units(ply, ply_with_holes)) #> [1] 2 3 4 6 7 8 # }"},{"path":"https://prioritizr.net/reference/knit_print.html","id":null,"dir":"Reference","previous_headings":"","what":"Print an object for knitr package. — knit_print","title":"Print an object for knitr package. — knit_print","text":"function used ensure problem() new_optimization_problem() objects displayed correctly rmarkdown reports.","code":""},{"path":"https://prioritizr.net/reference/knit_print.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print an object for knitr package. — knit_print","text":"","code":"knit_print.ConservationProblem(x, ...)  knit_print.OptimizationProblem(x, ...)"},{"path":"https://prioritizr.net/reference/knit_print.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print an object for knitr package. — knit_print","text":"x Object. ... used.","code":""},{"path":"https://prioritizr.net/reference/knit_print.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print an object for knitr package. — knit_print","text":"character vector knitting.","code":""},{"path":"https://prioritizr.net/reference/knit_print.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Print an object for knitr package. — knit_print","text":"function called directly. intended used knitr package displaying objects.","code":""},{"path":"https://prioritizr.net/reference/loglinear_interpolation.html","id":null,"dir":"Reference","previous_headings":"","what":"Log-linear interpolation — loglinear_interpolation","title":"Log-linear interpolation — loglinear_interpolation","text":"Log-linearly interpolate values two thresholds.","code":""},{"path":"https://prioritizr.net/reference/loglinear_interpolation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log-linear interpolation — loglinear_interpolation","text":"","code":"loglinear_interpolation(   x,   coordinate_one_x,   coordinate_one_y,   coordinate_two_x,   coordinate_two_y )"},{"path":"https://prioritizr.net/reference/loglinear_interpolation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Log-linear interpolation — loglinear_interpolation","text":"x numeric x values interpolate y values. coordinate_one_x numeric value lower x-coordinate. coordinate_one_y numeric value lower y-coordinate. coordinate_two_x numeric value upper x-coordinate. coordinate_two_y numeric value upper y-coordinate.","code":""},{"path":"https://prioritizr.net/reference/loglinear_interpolation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Log-linear interpolation — loglinear_interpolation","text":"numeric vector.","code":""},{"path":"https://prioritizr.net/reference/loglinear_interpolation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Log-linear interpolation — loglinear_interpolation","text":"Values log-linearly interpolated x-coordinates specified x using lower upper coordinate arguments define line. Values lesser greater numbers assigned minimum maximum y coordinates.","code":""},{"path":"https://prioritizr.net/reference/loglinear_interpolation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Log-linear interpolation — loglinear_interpolation","text":"","code":"# \\dontrun{ # create series of x-values x <- seq(0, 1000)  # interpolate y-values for the x-values given the two reference points: # (200, 100) and (900, 15) y <- loglinear_interpolation(x, 200, 100, 900, 15)  # plot the interpolated values plot(y ~ x)  # add the reference points to the plot (shown in red) points(x = c(200, 900), y = c(100, 15), pch = 18, col = \"red\", cex = 2)   # this function can also be used to calculate representation targets # following Rodrigues et al. (2014). For example, let's say that # we had a set of species we were interested in calculating representation # targets for and we had information on their range sizes (in km^2). spp_range_size_km2 <- seq(0.01, 15000000, by = 100)  # we can now use this function to calculate representation targets # (expressed as a percentage of the species' range sizes) using # the thresholds and cap sizes reported by Rodrigues et al. 2014 spp_target_percentage_rodrigues <- loglinear_interpolation(     x = spp_range_size_km2,     coordinate_one_x = 1000,     coordinate_one_y = 1,     coordinate_two_x = 250000,     coordinate_two_y = 0.1 ) * 100  # it is also common to apply a cap to the representation targets, # so let's apply the cap these targets following Butchart et al. (2015) spp_target_percentage_butchart <- ifelse(   spp_range_size_km2 >= 10000000,   (1000000 / spp_range_size_km2) * 100,   spp_target_percentage_rodrigues )  # plot species range sizes and representation targets plot(   spp_target_percentage_butchart ~ spp_range_size_km2,   xlab = \"Range size km^2\" , ylab = \"Representation target (%)\", type = \"l\" )   # plot species range sizes and representation targets on a log10 scale plot(   spp_target_percentage_butchart ~ log10(spp_range_size_km2),   xlab = \"Range size km^2\" , ylab = \"Representation target (%)\",   type = \"l\", xaxt = \"n\" ) axis(   1, pretty(log10(spp_range_size_km2)),   10^pretty(log10(spp_range_size_km2)) )  # }"},{"path":"https://prioritizr.net/reference/marxan_boundary_data_to_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Marxan boundary data to matrix format — marxan_boundary_data_to_matrix","title":"Convert Marxan boundary data to matrix format — marxan_boundary_data_to_matrix","text":"Convert data.frame object containing Marxan boundary data matrix format. function designed specifically boundary data (connectivity data). ensures output matrix correctly specifies symmetric spatial relationships planning units.","code":""},{"path":"https://prioritizr.net/reference/marxan_boundary_data_to_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Marxan boundary data to matrix format — marxan_boundary_data_to_matrix","text":"","code":"marxan_boundary_data_to_matrix(x, data)"},{"path":"https://prioritizr.net/reference/marxan_boundary_data_to_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Marxan boundary data to matrix format — marxan_boundary_data_to_matrix","text":"x problem() object contains planning unit zone data ensure argument data converted correctly. argument can set NULL checks required (recommended). data data.frame object columns \"id1\", \"id2\", \"boundary\".","code":""},{"path":"https://prioritizr.net/reference/marxan_boundary_data_to_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Marxan boundary data to matrix format — marxan_boundary_data_to_matrix","text":"dgCMatrix sparse matrix object.","code":""},{"path":"https://prioritizr.net/reference/marxan_boundary_data_to_matrix.html","id":"notes","dir":"Reference","previous_headings":"","what":"Notes","title":"Convert Marxan boundary data to matrix format — marxan_boundary_data_to_matrix","text":"earlier versions, function convert boundary data pertain multiple zones. longer possible, following updates streamline package.","code":""},{"path":"https://prioritizr.net/reference/marxan_boundary_data_to_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Marxan boundary data to matrix format — marxan_boundary_data_to_matrix","text":"","code":"# create marxan boundary with four planning units and one zone bldf1 <- expand.grid(id1 = seq_len(4), id2 = seq_len(4)) bldf1$boundary <- 1 bldf1$boundary[bldf1$id1 == bldf1$id2] <- 0.5  # convert to matrix m1 <- marxan_boundary_data_to_matrix(NULL, bldf1)  # visualize matrix # \\dontrun{ image(m1)  # }"},{"path":"https://prioritizr.net/reference/marxan_connectivity_data_to_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Marxan connectivity data to matrix format — marxan_connectivity_data_to_matrix","title":"Convert Marxan connectivity data to matrix format — marxan_connectivity_data_to_matrix","text":"Convert data.frame object containing Marxan connectivity data matrix format. function designed specifically connectivity data (boundary data). ensures output matrix correctly specifies symmetric asymmetric connectivity relationships planning units.","code":""},{"path":"https://prioritizr.net/reference/marxan_connectivity_data_to_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Marxan connectivity data to matrix format — marxan_connectivity_data_to_matrix","text":"","code":"marxan_connectivity_data_to_matrix(x, data, symmetric = TRUE)"},{"path":"https://prioritizr.net/reference/marxan_connectivity_data_to_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Marxan connectivity data to matrix format — marxan_connectivity_data_to_matrix","text":"x problem() object contains planning unit zone data ensure argument data converted correctly. argument can set NULL checks required (recommended). data data.frame object columns \"id1\", \"id2\", \"boundary\". symmetric logical connectivity data describe symmetric relationships planning units? data contain asymmetric connectivity data, parameter set FALSE. Defaults TRUE.","code":""},{"path":"https://prioritizr.net/reference/marxan_connectivity_data_to_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Marxan connectivity data to matrix format — marxan_connectivity_data_to_matrix","text":"dgCMatrix sparse matrix object.","code":""},{"path":"https://prioritizr.net/reference/marxan_connectivity_data_to_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Marxan connectivity data to matrix format — marxan_connectivity_data_to_matrix","text":"","code":"# \\dontrun{ # create marxan connectivity data with four planning units and one zone, # and symmetric connectivity values bldf1 <- expand.grid(id1 = seq_len(4), id2 = seq_len(4)) bldf1$boundary <- 1 bldf1$boundary[bldf1$id1 == bldf1$id2] <- 0.5  # print data print(bldf1) #>    id1 id2 boundary #> 1    1   1      0.5 #> 2    2   1      1.0 #> 3    3   1      1.0 #> 4    4   1      1.0 #> 5    1   2      1.0 #> 6    2   2      0.5 #> 7    3   2      1.0 #> 8    4   2      1.0 #> 9    1   3      1.0 #> 10   2   3      1.0 #> 11   3   3      0.5 #> 12   4   3      1.0 #> 13   1   4      1.0 #> 14   2   4      1.0 #> 15   3   4      1.0 #> 16   4   4      0.5  # convert to matrix m1 <- marxan_connectivity_data_to_matrix(NULL, bldf1)  # print matrix print(m1) #> 4 x 4 sparse Matrix of class \"dsCMatrix\" #>                      #> [1,] 0.5 1.0 1.0 1.0 #> [2,] 1.0 0.5 1.0 1.0 #> [3,] 1.0 1.0 0.5 1.0 #> [4,] 1.0 1.0 1.0 0.5  # visualize matrix image(m1)   # create marxan connectivity data with four planning units and one zone, # and asymmetric connectivity values bldf2 <- expand.grid(id1 = seq_len(4), id2 = seq_len(4)) bldf2$boundary <- runif(nrow(bldf2)) bldf2$boundary[bldf1$id1 == bldf1$id2] <- 0.5  # print data print(bldf2) #>    id1 id2   boundary #> 1    1   1 0.50000000 #> 2    2   1 0.48469318 #> 3    3   1 0.85434472 #> 4    4   1 0.58924564 #> 5    1   2 0.57586891 #> 6    2   2 0.50000000 #> 7    3   2 0.23870311 #> 8    4   2 0.23721283 #> 9    1   3 0.23125087 #> 10   2   3 0.98898790 #> 11   3   3 0.50000000 #> 12   4   3 0.06918062 #> 13   1   4 0.19277122 #> 14   2   4 0.65083831 #> 15   3   4 0.07945488 #> 16   4   4 0.50000000  # convert to matrix m2 <- marxan_connectivity_data_to_matrix(NULL, bldf2, symmetric = FALSE)  # print matrix print(m2) #> 4 x 4 sparse Matrix of class \"dgCMatrix\" #>                                                #> [1,] 0.5000000 0.5758689 0.23125087 0.19277122 #> [2,] 0.4846932 0.5000000 0.98898790 0.65083831 #> [3,] 0.8543447 0.2387031 0.50000000 0.07945488 #> [4,] 0.5892456 0.2372128 0.06918062 0.50000000  # visualize matrix image(m2)   # create marxan connectivity with three planning units and two zones, # and symmetric connectivity values bldf3 <- expand.grid(   id1 = seq_len(3), id2 = seq_len(3),   zone1 = c(\"z1\", \"z2\"),   zone2 = c(\"z1\", \"z2\") ) bldf3$boundary <- 1 bldf3$boundary[bldf2$id1 == bldf2$id2 & bldf2$zone1 == bldf2$zone2] <- 0.5 bldf3$boundary[bldf2$id1 == bldf2$id2 & bldf2$zone1 != bldf2$zone2] <- 0  # print data print(bldf3) #>    id1 id2 zone1 zone2 boundary #> 1    1   1    z1    z1        1 #> 2    2   1    z1    z1        1 #> 3    3   1    z1    z1        1 #> 4    1   2    z1    z1        1 #> 5    2   2    z1    z1        1 #> 6    3   2    z1    z1        1 #> 7    1   3    z1    z1        1 #> 8    2   3    z1    z1        1 #> 9    3   3    z1    z1        1 #> 10   1   1    z2    z1        1 #> 11   2   1    z2    z1        1 #> 12   3   1    z2    z1        1 #> 13   1   2    z2    z1        1 #> 14   2   2    z2    z1        1 #> 15   3   2    z2    z1        1 #> 16   1   3    z2    z1        1 #> 17   2   3    z2    z1        1 #> 18   3   3    z2    z1        1 #> 19   1   1    z1    z2        1 #> 20   2   1    z1    z2        1 #> 21   3   1    z1    z2        1 #> 22   1   2    z1    z2        1 #> 23   2   2    z1    z2        1 #> 24   3   2    z1    z2        1 #> 25   1   3    z1    z2        1 #> 26   2   3    z1    z2        1 #> 27   3   3    z1    z2        1 #> 28   1   1    z2    z2        1 #> 29   2   1    z2    z2        1 #> 30   3   1    z2    z2        1 #> 31   1   2    z2    z2        1 #> 32   2   2    z2    z2        1 #> 33   3   2    z2    z2        1 #> 34   1   3    z2    z2        1 #> 35   2   3    z2    z2        1 #> 36   3   3    z2    z2        1  # convert to array m3 <- marxan_connectivity_data_to_matrix(NULL, bldf3)  # print array print(m3) #> , , 1, 1 #>  #>      [,1] [,2] [,3] #> [1,]    1    1    1 #> [2,]    1    1    1 #> [3,]    1    1    1 #>  #> , , 2, 1 #>  #>      [,1] [,2] [,3] #> [1,]    1    1    1 #> [2,]    1    1    1 #> [3,]    1    1    1 #>  #> , , 1, 2 #>  #>      [,1] [,2] [,3] #> [1,]    1    1    1 #> [2,]    1    1    1 #> [3,]    1    1    1 #>  #> , , 2, 2 #>  #>      [,1] [,2] [,3] #> [1,]    1    1    1 #> [2,]    1    1    1 #> [3,]    1    1    1 #>  # }"},{"path":"https://prioritizr.net/reference/marxan_problem.html","id":null,"dir":"Reference","previous_headings":"","what":"Marxan conservation problem — marxan_problem","title":"Marxan conservation problem — marxan_problem","text":"Create conservation planning problem() following mathematical formulations used Marxan (detailed Beyer et al. 2016). Note problems solved using exact algorithms simulated annealing (.e., Marxan software).","code":""},{"path":"https://prioritizr.net/reference/marxan_problem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Marxan conservation problem — marxan_problem","text":"","code":"marxan_problem(x, ...)  # S3 method for default marxan_problem(x, ...)  # S3 method for data.frame marxan_problem(x, spec, puvspr, bound = NULL, blm = 0, symmetric = TRUE, ...)  # S3 method for character marxan_problem(x, ...)"},{"path":"https://prioritizr.net/reference/marxan_problem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Marxan conservation problem — marxan_problem","text":"x character file path Marxan input file (typically called \"input.dat\"), data.frame containing planning unit data (typically called \"pu.dat\"). argument x data.frame, row corresponds different planning unit, must following columns: id integer unique identifier planning unit. identifiers used argument puvspr. cost numeric cost planning unit. status integer indicating planning unit locked solution (0) locked (2) locked (3) solution. Although Marxan allows planning units selected initial solution (using values 1), values effect . column optional. ... used. spec data.frame containing information features. argument spec must follow conventions used Marxan species data file (conventionally called \"spec.dat\"). row corresponds different feature column corresponds different information features. must contain columns listed . Note argument spec must contain least one column named \"prop\" \"amount\"---columns names---specify target feature. id integer unique identifier feature identifiers used argument puvspr. name character name feature. prop numeric relative target feature (optional). amount numeric absolute target feature (optional). puvspr data.frame containing information amount feature planning unit. argument puvspr must follow conventions used Marxan input data file (conventionally called \"puvspr.dat\"). must contain following columns: pu integer planning unit identifier. species integer feature identifier. amount numeric amount feature planning unit. bound NULL object indicating boundary data required conservation planning problem, data.frame containing information planning units' boundaries. argument bound must follow conventions used Marxan input data file (conventionally called \"bound.dat\"). must contain following columns: id1 integer planning unit identifier. id2 integer planning unit identifier. boundary numeric length shared boundary planning units identified previous two columns. blm numeric boundary length modifier. argument effect argument x data.frame. default argument zero. symmetric logical boundary data (.e., argument bound) describe symmetric relationships planning units? boundary data contain asymmetric connectivity data, parameter set FALSE. Defaults TRUE.","code":""},{"path":"https://prioritizr.net/reference/marxan_problem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Marxan conservation problem — marxan_problem","text":"problem() object.","code":""},{"path":"https://prioritizr.net/reference/marxan_problem.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Marxan conservation problem — marxan_problem","text":"function provided convenient wrapper solving Marxan problems using prioritizr package. Please note requires installation data.table package import Marxan data files.","code":""},{"path":"https://prioritizr.net/reference/marxan_problem.html","id":"notes","dir":"Reference","previous_headings":"","what":"Notes","title":"Marxan conservation problem — marxan_problem","text":"previous versions, function accommodate asymmetric connectivity data. now updated handle asymmetric connectivity data.","code":""},{"path":"https://prioritizr.net/reference/marxan_problem.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Marxan conservation problem — marxan_problem","text":"Ball IR, Possingham HP, Watts M (2009) Marxan relatives: Software spatial conservation prioritisation Spatial conservation prioritisation: Quantitative methods computational tools. Eds Moilanen , Wilson KA, Possingham HP. Oxford University Press, Oxford, UK. Beyer HL, Dujardin Y, Watts , Possingham HP (2016) Solving conservation planning problems integer linear programming. Ecological Modelling, 228: 14--22.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/marxan_problem.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Marxan conservation problem — marxan_problem","text":"","code":"# create Marxan problem using Marxan input file # (note this example requires the data.table package to be installed) # \\dontrun{ input_file <- system.file(\"extdata/marxan/input.dat\", package = \"prioritizr\") p1 <-   marxan_problem(input_file) %>%   add_default_solver(verbose = FALSE)  # solve problem s1 <- solve(p1)  # print solution head(s1) #>   id       cost status    xloc     yloc locked_in locked_out solution_1 #> 1  3      0.000      0 1116623 -4493479     FALSE      FALSE          0 #> 2 30   7527.275      3 1110623 -4496943     FALSE       TRUE          0 #> 3 56  37349.075      0 1092623 -4500408     FALSE      FALSE          0 #> 4 58  16959.021      0 1116623 -4500408     FALSE      FALSE          0 #> 5 84  34220.256      0 1098623 -4503872     FALSE      FALSE          0 #> 6 85 178907.584      0 1110623 -4503872     FALSE      FALSE          0  # create Marxan problem using data.frames that have been loaded into R # (note this example also requires the data.table package to be installed) ## load in planning unit data pu_path <- system.file(\"extdata/marxan/input/pu.dat\", package = \"prioritizr\") pu_dat <- data.table::fread(pu_path, data.table = FALSE) head(pu_dat) #>   id       cost status    xloc     yloc #> 1  3      0.000      0 1116623 -4493479 #> 2 30   7527.275      3 1110623 -4496943 #> 3 56  37349.075      0 1092623 -4500408 #> 4 58  16959.021      0 1116623 -4500408 #> 5 84  34220.256      0 1098623 -4503872 #> 6 85 178907.584      0 1110623 -4503872  ## load in feature data spec_path <- system.file(   \"extdata/marxan/input/spec.dat\", package = \"prioritizr\" ) spec_dat <- data.table::fread(spec_path, data.table = FALSE) head(spec_dat) #>   id prop spf   name #> 1 10  0.3   1  bird1 #> 2 11  0.3   1  nvis2 #> 3 12  0.3   1  nvis8 #> 4 13  0.3   1  nvis9 #> 5 14  0.3   1 nvis14 #> 6 15  0.3   1 nvis20  ## load in planning unit vs feature data puvspr_path <- system.file(   \"extdata/marxan/input/puvspr.dat\", package = \"prioritizr\" ) puvspr_dat <- data.table::fread(puvspr_path, data.table = FALSE) head(puvspr_dat) #>   species  pu     amount #> 1      26  56 120.344884 #> 2      26  58  45.167010 #> 3      26  84  68.047375 #> 4      26  85   9.735624 #> 5      26  86   7.803476 #> 6      26 111 478.327417  ## load in the boundary data bound_path <- system.file(   \"extdata/marxan/input/bound.dat\", package = \"prioritizr\" ) bound_dat <- data.table::fread(bound_path, data.table = FALSE) head(bound_dat) #>   id1 id2 boundary #> 1   3   3    16000 #> 2   3  30     4000 #> 3   3  58     4000 #> 4  30  30    12000 #> 5  30  58     4000 #> 6  30  85     4000  # create problem without the boundary data p2 <-   marxan_problem(pu_dat, spec_dat, puvspr_dat) %>%   add_default_solver(verbose = FALSE)  # solve problem s2 <- solve(p2)  # print solution head(s2) #>   id       cost status    xloc     yloc locked_in locked_out solution_1 #> 1  3      0.000      0 1116623 -4493479     FALSE      FALSE          0 #> 2 30   7527.275      3 1110623 -4496943     FALSE       TRUE          0 #> 3 56  37349.075      0 1092623 -4500408     FALSE      FALSE          0 #> 4 58  16959.021      0 1116623 -4500408     FALSE      FALSE          0 #> 5 84  34220.256      0 1098623 -4503872     FALSE      FALSE          0 #> 6 85 178907.584      0 1110623 -4503872     FALSE      FALSE          0  # create problem with the boundary data and a boundary length modifier # set to 5 p3 <-   marxan_problem(pu_dat, spec_dat, puvspr_dat, bound_dat, blm = 5) %>%   add_default_solver(verbose = FALSE)  # solve problem s3 <- solve(p3)  # print solution head(s3) #>   id       cost status    xloc     yloc locked_in locked_out solution_1 #> 1  3      0.000      0 1116623 -4493479     FALSE      FALSE          0 #> 2 30   7527.275      3 1110623 -4496943     FALSE       TRUE          0 #> 3 56  37349.075      0 1092623 -4500408     FALSE      FALSE          0 #> 4 58  16959.021      0 1116623 -4500408     FALSE      FALSE          0 #> 5 84  34220.256      0 1098623 -4503872     FALSE      FALSE          0 #> 6 85 178907.584      0 1110623 -4503872     FALSE      FALSE          0 # }"},{"path":"https://prioritizr.net/reference/new_waiver.html","id":null,"dir":"Reference","previous_headings":"","what":"Waiver — new_waiver","title":"Waiver — new_waiver","text":"Create waiver object.","code":""},{"path":"https://prioritizr.net/reference/new_waiver.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Waiver — new_waiver","text":"","code":"new_waiver()"},{"path":"https://prioritizr.net/reference/new_waiver.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Waiver — new_waiver","text":"Waiver object.","code":""},{"path":"https://prioritizr.net/reference/new_waiver.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Waiver — new_waiver","text":"object used represent user manually specified setting, defaults used. explicitly using new_waiver(), means NULL objects can valid setting. use waiver object inspired ggplot2 package.","code":""},{"path":"https://prioritizr.net/reference/new_waiver.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Waiver — new_waiver","text":"","code":"# create new waiver object w <- new_waiver()  # print object print(w) #> list() #> attr(,\"class\") #> [1] \"Waiver\""},{"path":"https://prioritizr.net/reference/number_of_features.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of features — number_of_features","title":"Number of features — number_of_features","text":"Extract number features object.","code":""},{"path":"https://prioritizr.net/reference/number_of_features.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of features — number_of_features","text":"","code":"number_of_features(x, ...)  # S3 method for ConservationProblem number_of_features(x, ...)  # S3 method for OptimizationProblem number_of_features(x, ...)  # S3 method for ZonesSpatRaster number_of_features(x, ...)  # S3 method for ZonesRaster number_of_features(x, ...)  # S3 method for ZonesCharacter number_of_features(x, ...)"},{"path":"https://prioritizr.net/reference/number_of_features.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of features — number_of_features","text":"x problem(), optimization_problem(), zones() object. ... used.","code":""},{"path":"https://prioritizr.net/reference/number_of_features.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of features — number_of_features","text":"integer number features.","code":""},{"path":"https://prioritizr.net/reference/number_of_features.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of features — number_of_features","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features()  # create problem p <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.2) %>%   add_binary_decisions()  # print number of features print(number_of_features(p)) #> [1] 5 # }"},{"path":"https://prioritizr.net/reference/number_of_planning_units.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of planning units — number_of_planning_units","title":"Number of planning units — number_of_planning_units","text":"Extract number planning units object.","code":""},{"path":"https://prioritizr.net/reference/number_of_planning_units.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of planning units — number_of_planning_units","text":"","code":"number_of_planning_units(x, ...)  # S3 method for ConservationProblem number_of_planning_units(x, ...)  # S3 method for OptimizationProblem number_of_planning_units(x, ...)"},{"path":"https://prioritizr.net/reference/number_of_planning_units.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of planning units — number_of_planning_units","text":"x problem() optimization_problem() object. ... used.","code":""},{"path":"https://prioritizr.net/reference/number_of_planning_units.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of planning units — number_of_planning_units","text":"integer number planning units.","code":""},{"path":"https://prioritizr.net/reference/number_of_planning_units.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Number of planning units — number_of_planning_units","text":"planning units object corresponds number entries (e.g., rows, cells) planning unit data missing (NA) values every zone. example, single-layer raster dataset might 90 cells two cells contain non-missing (NA) values. , dataset two planning units.","code":""},{"path":"https://prioritizr.net/reference/number_of_planning_units.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of planning units — number_of_planning_units","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features()  # create problem p <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.2) %>%   add_binary_decisions()  # print number of planning units print(number_of_planning_units(p)) #> [1] 90 # }"},{"path":"https://prioritizr.net/reference/number_of_total_units.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of total units — number_of_total_units","title":"Number of total units — number_of_total_units","text":"Extract number total units object.","code":""},{"path":"https://prioritizr.net/reference/number_of_total_units.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of total units — number_of_total_units","text":"","code":"number_of_total_units(x, ...)  # S3 method for ConservationProblem number_of_total_units(x, ...)"},{"path":"https://prioritizr.net/reference/number_of_total_units.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of total units — number_of_total_units","text":"x problem() object. ... used.","code":""},{"path":"https://prioritizr.net/reference/number_of_total_units.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of total units — number_of_total_units","text":"integer number total units.","code":""},{"path":"https://prioritizr.net/reference/number_of_total_units.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Number of total units — number_of_total_units","text":"total units object corresponds total number entries (e.g., rows, cells) planning unit data. example, single-layer raster dataset might 90 cells two cells contain non-missing (NA) values. , dataset 90 total units two planning units.","code":""},{"path":"https://prioritizr.net/reference/number_of_total_units.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of total units — number_of_total_units","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_features <- get_sim_zones_features()  # create problem with one zone p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.2) %>%   add_binary_decisions()  # print number of planning units print(number_of_planning_units(p1)) #> [1] 90  # print number of total units print(number_of_total_units(p1)) #> [1] 100  # create problem with multiple zones p2 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_min_set_objective() %>%   add_relative_targets(matrix(0.2, ncol = 3, nrow = 5)) %>%   add_binary_decisions()  # print number of planning units print(number_of_planning_units(p2)) #> [1] 90  # print number of total units print(number_of_total_units(p2)) #> [1] 100 # }"},{"path":"https://prioritizr.net/reference/number_of_zones.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of zones — number_of_zones","title":"Number of zones — number_of_zones","text":"Extract number zones object.","code":""},{"path":"https://prioritizr.net/reference/number_of_zones.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of zones — number_of_zones","text":"","code":"number_of_zones(x, ...)  # S3 method for ConservationProblem number_of_zones(x, ...)  # S3 method for OptimizationProblem number_of_zones(x, ...)  # S3 method for ZonesRaster number_of_zones(x, ...)  # S3 method for ZonesSpatRaster number_of_zones(x, ...)  # S3 method for ZonesCharacter number_of_zones(x, ...)"},{"path":"https://prioritizr.net/reference/number_of_zones.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of zones — number_of_zones","text":"x problem(), optimization_problem(), zones() object. ... used.","code":""},{"path":"https://prioritizr.net/reference/number_of_zones.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of zones — number_of_zones","text":"integer number zones.","code":""},{"path":"https://prioritizr.net/reference/number_of_zones.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of zones — number_of_zones","text":"","code":"# \\dontrun{ # load data sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_features <- get_sim_zones_features()  # print number of zones in a Zones object print(number_of_zones(sim_zones_features)) #> [1] 3 # create problem with multiple zones p <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_min_set_objective() %>%   add_relative_targets(matrix(0.2, ncol = 3, nrow = 5)) %>%   add_binary_decisions()  # print number of zones in the problem print(number_of_zones(p)) #> [1] 3 # }"},{"path":"https://prioritizr.net/reference/objectives.html","id":null,"dir":"Reference","previous_headings":"","what":"Add an objective — objectives","title":"Add an objective — objectives","text":"objective used specify overall goal conservation planning problem. conservation planning problems involve minimizing maximizing kind objective. instance, planner may require solution conserves enough habitat species minimizing overall cost reserve network. Alternatively, planner may require solution maximizes number conserved species ensuring cost reserve network exceed budget.","code":""},{"path":"https://prioritizr.net/reference/objectives.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add an objective — objectives","text":"Please note conservation planning problems formulated using prioritizr package require objective function, attempting solve problem without objective result error. following objectives can added conservation planning problem(): add_min_set_objective() Minimize cost solution whilst ensuring targets met. objective similar used Marxan. add_max_cover_objective() Represent least one instance many features possible within given budget. add_max_features_objective() Fulfill many targets possible ensuring cost solution exceed budget. add_min_shortfall_objective() Minimize overall (weighted sum) shortfall many targets possible ensuring cost solution exceed budget. add_min_largest_shortfall_objective() Minimize largest (maximum) shortfall among targets ensuring cost solution exceed budget. add_max_phylo_div_objective() Maximize phylogenetic diversity features represented solution subject budget. add_max_phylo_end_objective() Maximize phylogenetic endemism features represented solution subject budget. add_max_utility_objective() Secure much features possible without exceeding budget.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/objectives.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add an objective — objectives","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features() sim_phylogeny <- get_sim_phylogeny()  # create base problem p <-   problem(sim_pu_raster, sim_features) %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)   # create problem with added minimum set objective p1 <- p %>% add_min_set_objective()  # create problem with added maximum coverage objective # note that this objective does not use targets p2 <- p %>% add_max_cover_objective(500)  # create problem with added maximum feature representation objective p3 <- p %>% add_max_features_objective(1900)  # create problem with added minimum shortfall objective p4 <- p %>% add_min_shortfall_objective(1900)  # create problem with added minimum largest shortfall objective p5 <- p %>% add_min_largest_shortfall_objective(1900)  # create problem with added maximum phylogenetic diversity objective p6 <- p %>% add_max_phylo_div_objective(1900, sim_phylogeny)  # create problem with added maximum phylogenetic diversity objective p7 <- p %>% add_max_phylo_end_objective(1900, sim_phylogeny)  # create problem with added maximum utility objective # note that this objective does not use targets p8 <- p %>% add_max_utility_objective(1900)  # solve problems s <- c(   solve(p1), solve(p2), solve(p3), solve(p4), solve(p5), solve(p6),   solve(p7), solve(p8) ) #> Warning: Targets specified for the problem will be ignored. #> ℹ If the targets are important, use a different objective. #> Warning: Targets specified for the problem will be ignored. #> ℹ If the targets are important, use a different objective. names(s) <- c(   \"min set\", \"max coverage\", \"max features\", \"min shortfall\",   \"min largest shortfall\", \"max phylogenetic diversity\",   \"max phylogenetic endemism\", \"max utility\" ) # plot solutions plot(s, axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/optimization_problem.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimization problem — optimization_problem","title":"Optimization problem — optimization_problem","text":"Create new optimization problem.","code":""},{"path":"https://prioritizr.net/reference/optimization_problem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimization problem — optimization_problem","text":"","code":"optimization_problem(x = NULL)"},{"path":"https://prioritizr.net/reference/optimization_problem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimization problem — optimization_problem","text":"x NULL list object. See Details information. Defaults NULL.","code":""},{"path":"https://prioritizr.net/reference/optimization_problem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimization problem — optimization_problem","text":"OptimizationProblem object.","code":""},{"path":"https://prioritizr.net/reference/optimization_problem.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Optimization problem — optimization_problem","text":"argument x can NULL list. x NULL, empty optimization problem created. Alternately, x list fully formulated optimization problem created. Specifically, list contain following elements. modelsense character model sense. number_of_features integer number features problem. number_of_planning_units integer number planning units. A_i integer row indices problem matrix. A_j integer column indices problem matrix. A_x numeric values problem matrix. obj numeric objective function values. lb numeric lower bound decision values. ub numeric upper bound decision values. rhs numeric right-hand side values. sense numeric constraint senses. vtype character variable types. used specify decision variables binary (\"B\") continuous (\"C\"). row_ids character identifiers rows problem matrix. col_ids character identifiers columns problem matrix.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/optimization_problem.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Optimization problem — optimization_problem","text":"","code":"# create new empty object x1 <- optimization_problem()  # print new empty object print(x1) #> An optimization problem (<OptimizationProblem>) #> • model sense: missing #> • dimensions:  0, 0, 0 (rows, columns, cells) #> • variables:   none  # create list with optimization problem l <- list(   modelsense = \"min\",   number_of_features = 2,   number_of_planning_units = 3,   number_of_zones = 1,   A_i = c(0L, 1L, 0L, 1L, 0L, 1L),   A_j = c(0L, 0L, 1L, 1L, 2L, 2L),   A_x = c(2, 10, 1, 10, 1, 10),   obj = c(1, 2, 2),   lb = c(0, 1, 0),   ub = c(0, 1, 1),   rhs = c(2, 10),   compressed_formulation = TRUE,   sense = c(\">=\", \">=\"),   vtype = c(\"B\", \"B\", \"B\"),   row_ids = c(\"spp_target\", \"spp_target\"),   col_ids = c(\"pu\", \"pu\", \"pu\") )  # create fully formulated object based on lists x2 <- optimization_problem(l)  # print fully formulated object print(x2) #> An optimization problem (<OptimizationProblem>) #> • model sense: min #> • dimensions:  2, 3, 6 (rows, columns, cells) #> • variables:   3 (B)"},{"path":"https://prioritizr.net/reference/penalties.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a penalty — penalties","title":"Add a penalty — penalties","text":"penalty can applied conservation planning problem penalize solutions according specific metric. directly trade-primary objective problem (e.g., primary objective using add_min_set_objective() minimize solution cost).","code":""},{"path":"https://prioritizr.net/reference/penalties.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add a penalty — penalties","text":"penalties constraints can used modify problem identify solutions exhibit specific characteristics. Constraints work invalidating solutions exhibit specific characteristics. hand, penalties work specifying trade-offs primary problem objective mediated penalty factor. following penalties can added conservation planning problem(): add_boundary_penalties() Add penalties conservation problem favor solutions planning units clumped together contiguous areas. add_asym_connectivity_penalties() Add penalties conservation problem account asymmetric connectivity. add_connectivity_penalties() Add penalties conservation problem account symmetric connectivity. add_linear_penalties() Add penalties conservation problem favor solutions avoid selecting planning units based certain variable (e.g., anthropogenic pressure).","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/penalties.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add a penalty — penalties","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features()  # create basic problem p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.2) %>%   add_default_solver(verbose = FALSE)  # create problem with boundary penalties p2 <- p1 %>% add_boundary_penalties(5, 1)  # create connectivity matrix based on spatial proximity  scm <- terra::as.data.frame(sim_pu_raster, xy = TRUE, na.rm = FALSE)  scm <- 1 / (as.matrix(dist(as.matrix(scm))) + 1)  # remove weak and moderate connections between planning units to reduce # run time scm[scm < 0.85] <- 0  # create problem with connectivity penalties p3 <- p1 %>% add_connectivity_penalties(25, data = scm)  # create asymmetric connectivity data by randomly simulating values acm <- matrix(runif(ncell(sim_pu_raster) ^ 2), ncol = ncell(sim_pu_raster)) acm[acm < 0.85] <- 0  # create problem with asymmetric connectivity penalties p4 <- p1 %>% add_asym_connectivity_penalties(1, data = acm)  # create problem with linear penalties, # here the penalties will be based on random numbers to keep it simple  # simulate penalty data sim_penalty_raster <- simulate_cost(sim_pu_raster)  # plot penalty data plot(sim_penalty_raster, main = \"penalty data\", axes = FALSE)   # create problem with linear penalties, with a penalty scaling factor of 100 p5 <- p1 %>% add_linear_penalties(100, data = sim_penalty_raster)  # solve problems s <- c(solve(p1), solve(p2), solve(p3), solve(p4), solve(p5)) names(s) <- c(   \"basic solution\", \"boundary penalties\", \"connectivity penalties\",   \"asymmetric penalties\", \"linear penalties\" )  # plot solutions plot(s, axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/portfolios.html","id":null,"dir":"Reference","previous_headings":"","what":"Add portfolios — portfolios","title":"Add portfolios — portfolios","text":"Conservation planning exercises rarely access data needed identify truly perfect solution. available data may lack important details (e.g., land acquisition costs may unavailable), contain errors (e.g., species presence/absence data may false positives), key objectives may formally incorporated prioritization process (e.g., future land use requirements). , conservation planners can help decision makers providing portfolio solutions inform decision.","code":""},{"path":"https://prioritizr.net/reference/portfolios.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add portfolios — portfolios","text":"following portfolios can added conservation planning problem(). Note methods generating portfolios return solutions within specified optimality gap. add_extra_portfolio() Generate portfolio solutions storing feasible solutions found optimization process. method useful quickly obtaining multiple solutions, provide guarantees number solutions, quality solutions. Note requires Gurobi solver. add_top_portfolio() Generate portfolio solutions finding pre-specified number solutions closest optimality (.e., top solutions). useful examining differences among near-optimal solutions. can also used generate multiple solutions , turn, calculate selection frequencies small problems. Note requires Gurobi solver. add_gap_portfolio() Generate portfolio solutions finding certain number solutions within pre- specified optimality gap. method useful generating multiple solutions can used calculate selection frequencies moderate large-sized problems (similar Marxan). Note requires Gurobi solver. add_cuts_portfolio() Generate portfolio distinct solutions within pre-specified optimality gap using Bender's cuts. recommended replacement add_top_portfolio() Gurobi software available. add_shuffle_portfolio() Generate portfolio solutions randomly reordering data prior attempting solve problem. recommended replacement add_gap_portfolio() Gurobi software available.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/portfolios.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add portfolios — portfolios","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features()  # create problem p <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_default_solver(gap = 0.02, verbose = FALSE)  # create problem with cuts portfolio with 4 solutions p1 <- p %>% add_cuts_portfolio(4)  # create problem with shuffle portfolio with 4 solutions p2 <- p %>% add_shuffle_portfolio(4)  # create problem with extra portfolio p3 <- p %>% add_extra_portfolio()  # create problem with top portfolio with 4 solutions p4 <- p %>% add_top_portfolio(4)  # create problem with gap portfolio with 4 solutions within 50% of optimality p5 <- p %>% add_gap_portfolio(4, 0.5)  # solve problems and create solution portfolios s <- list(solve(p1), solve(p2), solve(p3), solve(p4), solve(p5)) #> Warning: Portfolio could only find 3 out of 4 solutions.  # plot solutions from cuts portfolio plot(terra::rast(s[[1]]), axes = FALSE)   # plot solutions from shuffle portfolio plot(terra::rast(s[[2]]), axes = FALSE)   # plot solutions from extra portfolio plot(terra::rast(s[[3]]), axes = FALSE)   # plot solutions from top portfolio plot(terra::rast(s[[4]]), axes = FALSE)   # plot solutions from gap portfolio plot(terra::rast(s[[5]]), axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/presolve_check.html","id":null,"dir":"Reference","previous_headings":"","what":"Presolve check — presolve_check","title":"Presolve check — presolve_check","text":"Check conservation planning problem potential issues trying solve . Specifically, problems checked () values likely result \"strange\" solutions (ii) values likely cause numerical instability issues lead unreasonably long run times solving . Although checks provided help diagnose potential issues, please aware detected issues may false positives. Please note checks able verify problem feasible solution .","code":""},{"path":"https://prioritizr.net/reference/presolve_check.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Presolve check — presolve_check","text":"","code":"presolve_check(x, warn = TRUE)  # S3 method for ConservationProblem presolve_check(x, warn = TRUE)  # S3 method for OptimizationProblem presolve_check(x, warn = TRUE)"},{"path":"https://prioritizr.net/reference/presolve_check.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Presolve check — presolve_check","text":"x problem() optimization_problem() object. warn logical warning thrown presolve checks fail? Defaults TRUE.","code":""},{"path":"https://prioritizr.net/reference/presolve_check.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Presolve check — presolve_check","text":"logical value indicating checks passed successfully.","code":""},{"path":"https://prioritizr.net/reference/presolve_check.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Presolve check — presolve_check","text":"function checks issues likely result \"strange\" solutions. Specifically, checks () planning units locked , (ii) planning units locked , (iii) planning units negative cost values (applying penalties specified). Although conservation planning problems mathematically valid, generally result coding mistake building problem (e.g., using absurdly high penalty value using wrong dataset lock planning units). Thus issues, indeed issues false positives, can fixed carefully checking code, data, parameters used build conservation planning problem. function checks values may lead numerical instability issues solving problem. Specifically, checks range values certain components optimization problem certain threshold (.e., \\(1 \\times 10 ^9\\)) values exceed certain threshold (.e., \\(1 \\times 10^{10}\\)). cases, issues simply cause exact algorithm solver take long time generate solution. rare cases, issues can cause incorrect calculations can lead exact algorithm solvers returning infeasible solutions (e.g., solution minimum set problem targets met) solutions exceed specified optimality gap (e.g., suboptimal solution zero optimality gap specified). can conservation planning problem fails pass checks? Well, function thrown warning messages describing source issues, read carefully. instance, common issue relatively large penalty value specified boundary (add_boundary_penalties()) connectivity penalties (add_connectivity_penalties()). can fixed trying smaller penalty value. cases, original penalty value supplied high optimal solution just selected every single planning unit solution---may especially helpful anyway (see example). Another common issue planning unit cost values large. example, express costs planning units terms USD might planning units cost one billion dollars large-scale planning exercises. can fixed rescaling values smaller (e.g., multiplying values number smaller one, expressing fraction maximum cost). consider another common issue, pretend used habitat suitability models predict amount suitable habitat planning unit feature. calculated amount suitable habitat planning unit square meters lead large numbers. fix converting units square meters square kilometers thousands square kilometers. Alternatively, calculate percentage planning unit occupied suitable habitat, yield values zero one hundred. can fix issues simply changing penalty values rescaling data? need apply creative thinking. run couple scenarios. pretend planning units cost billion times planning unit fix rescaling cost values. case, extremely unlikely planning units selected optimal solution just set costs zero lock . procedure yields problem feasible solution, one (several) planning units manually locked contains critical habitat feature, find planning unit(s) causing infeasibility set cost zero. solving problem, need manually recalculate cost solutions least now can confident optimal solution. Now pretend using maximum features objective (.e., add_max_features_objective()) assigned really high weights targets features ensure targets met optimal solution. set weights features one billion probably run numerical instability issues. Instead, can calculate minimum weight needed guarantee features represented optimal solution use value instead one billion. minimum weight value can calculated sum weight values features adding small number (e.g., 1). Finally, running ideas addressing numerical stability issues one remaining option: can use numeric_focus argument add_gurobi_solver() function tell solver pay extra attention numerical instability issues. free lunch, however, telling solver pay extra attention numerical issues can substantially increase run time. , problems already taking unreasonable time solve, help .","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/presolve_check.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Presolve check — presolve_check","text":"","code":"# \\dontrun{ # set seed for reproducibility set.seed(500)  # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features()  # create minimal problem with no issues p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions()  # run presolve checks # note that no warning is thrown which suggests that we should not # encounter any numerical stability issues when trying to solve the problem print(presolve_check(p1)) #> [1] TRUE  # create a minimal problem, containing cost values that are really # high so that they could cause numerical instability issues when trying # to solve it sim_pu_raster2 <- sim_pu_raster sim_pu_raster2[1] <- 1e+15 p2 <-   problem(sim_pu_raster2, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions()  # run presolve checks # note that a warning is thrown which suggests that we might encounter # some issues, such as long solve time or suboptimal solutions, when # trying to solve the problem print(presolve_check(p2)) #> Warning: Problem failed presolve checks. #>  #> These failures indicate that numerical issues could stall optimizer or produce #> incorrect results: #>  #> ✖ Planning units must not have cost values that are too high (> 1e6). #> → Try re-scaling cost values (e.g., convert units from USD to millions of USD). #>  #> ℹ For more information, see `presolve_check()`. #> [1] FALSE  # create a minimal problem with connectivity penalties values that have # a really high penalty value that is likely to cause numerical instability # issues when trying to solve the it cm <- adjacency_matrix(sim_pu_raster) p3 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_connectivity_penalties(1e+15, data = cm) %>%   add_binary_decisions()  # run presolve checks # note that a warning is thrown which suggests that we might encounter # some numerical instability issues when trying to solve the problem print(presolve_check(p3)) #> Warning: Problem failed presolve checks. #>  #> These failures indicate that numerical issues could stall optimizer or produce #> incorrect results: #>  #> ✖ Multiplying the connectivity data by `penalty` must not produce values that #>   are too high (> 1e6). #> → Try using a smaller `penalty` in `add_connectivity_penalties()`. #>  #> ℹ For more information, see `presolve_check()`. #> [1] FALSE  # let's forcibly solve the problem using Gurobi and tell it to # be extra careful about numerical instability problems s3 <-    p3 %>%    add_gurobi_solver(numeric_focus = TRUE) %>%    solve(force = TRUE) #> Warning: Problem failed presolve checks. #>  #> These failures indicate that numerical issues could stall optimizer or produce #> incorrect results: #>  #> ✖ Multiplying the connectivity data by `penalty` must not produce values that #>   are too high (> 1e6). #> → Try using a smaller `penalty` in `add_connectivity_penalties()`. #>  #> ℹ For more information, see `presolve_check()`. #> Gurobi Optimizer version 10.0.2 build v10.0.2rc0 (linux64) #>  #> CPU model: 11th Gen Intel(R) Core(TM) i7-1185G7 @ 3.00GHz, instruction set [SSE2|AVX|AVX2|AVX512] #> Thread count: 4 physical cores, 8 logical processors, using up to 1 threads #>  #> Optimize a model with 293 rows, 234 columns and 1026 nonzeros #> Model fingerprint: 0x91dcff5b #> Variable types: 0 continuous, 234 integer (234 binary) #> Coefficient statistics: #>   Matrix range     [2e-01, 1e+00] #>   Objective range  [2e+02, 1e+15] #>   Bounds range     [1e+00, 1e+00] #>   RHS range        [3e+00, 8e+00] #> Warning: Model contains large objective coefficients #> Found heuristic solution: objective -1.44000e+17 #>  #> Explored 0 nodes (0 simplex iterations) in 0.00 seconds (0.00 work units) #> Thread count was 1 (of 8 available processors) #>  #> Solution count 1: -1.44e+17  #> No other solutions better than -1.44e+17 #>  #> Optimal solution found (tolerance 1.00e-01) #> Best objective -1.440000000000e+17, best bound -1.440000000000e+17, gap 0.0000%  # plot solution # we can see that all planning units were selected because the connectivity # penalty is so high that cost becomes irrelevant, so we should try using # a much lower penalty value plot(s3, main = \"solution\", axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/prioritizr-deprecated.html","id":null,"dir":"Reference","previous_headings":"","what":"Deprecation notice — prioritizr-deprecated","title":"Deprecation notice — prioritizr-deprecated","text":"functions listed deprecated. means existed earlier versions prioritizr package, since removed entirely, replaced functions, renamed functions newer versions. help make easier transition new versions prioritizr package, listed alternatives deprecated functions (applicable). function described renamed, means name function changed (.e., inputs, outputs, underlying code remain ).","code":""},{"path":"https://prioritizr.net/reference/prioritizr-deprecated.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deprecation notice — prioritizr-deprecated","text":"","code":"add_connected_constraints(...)  add_corridor_constraints(...)  set_number_of_threads(...)  get_number_of_threads(...)  is.parallel(...)  add_pool_portfolio(...)  connected_matrix(...)  feature_representation(...)  replacement_cost(...)  rarity_weighted_richness(...)  ferrier_score(...)  distribute_load(...)  new_optimization_problem(...)  predefined_optimization_problem(...)"},{"path":"https://prioritizr.net/reference/prioritizr-deprecated.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deprecation notice — prioritizr-deprecated","text":"... used.","code":""},{"path":"https://prioritizr.net/reference/prioritizr-deprecated.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Deprecation notice — prioritizr-deprecated","text":"following functions deprecated: add_connected_constraints() renamed add_contiguity_constraints() function. add_corridor_constraints() replaced add_feature_contiguity_constraints() function. set_number_of_threads() longer needed due improved data extraction methods. get_number_of_threads() longer needed due improved data extraction methods. .parallel() longer needed due improved data extraction methods. add_pool_portfolio() replaced add_extra_portfolio() add_top_portfolio(). connected_matrix() renamed adjacency_matrix() function. feature_representation() replaced eval_feature_representation_summary() function consistency functions. replacement_cost() renamed eval_replacement_importance() function consistency functions evaluating solutions. rarity_weighted_richness() renamed eval_rare_richness_importance() function consistency functions evaluating solutions. ferrier_score() renamed eval_ferrier_importance() function consistency functions evaluating solutions. distribute_load() removed longer used. See parallel::splitIndices() equivalent functionality. new_optimization_problem() replaced optimization_problem(). predefined_optimization_problem() replaced optimization_problem().","code":""},{"path":"https://prioritizr.net/reference/prioritizr.html","id":null,"dir":"Reference","previous_headings":"","what":"prioritizr: Systematic Conservation Prioritization in R — prioritizr","title":"prioritizr: Systematic Conservation Prioritization in R — prioritizr","text":"prioritizr R package uses mixed integer linear programming (MILP) techniques provide flexible interface building solving conservation planning problems (Rodrigues et al. 2000; Billionnet 2013). supports broad range objectives, constraints, penalties can used custom-tailor conservation planning problems specific needs conservation planning exercise. built, conservation planning problems can solved using variety commercial open-source exact algorithm solvers. contrast algorithms conventionally used solve conservation problems, heuristics simulated annealing (Ball et al. 2009), exact algorithms used guaranteed find optimal solutions. Furthermore, conservation problems can constructed optimize spatial allocation different management actions zones, meaning conservation practitioners can identify solutions benefit multiple stakeholders. Finally, package functionality read input data formatted Marxan conservation planning program (Ball et al. 2009), find much cheaper solutions much shorter period time Marxan (Beyer et al. 2016). See online code repository information.","code":""},{"path":"https://prioritizr.net/reference/prioritizr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"prioritizr: Systematic Conservation Prioritization in R — prioritizr","text":"package contains several vignettes designed showcase functionality. view , please use code vignette(\"name\", package = \"prioritizr\") \"name\" name desired vignette (e.g., \"gurobi_installation\"). prioritizr Background information systematic conservation planning, package intallation instructions citation, demonstration main package features. package_overview Comprehensive introduction package example workflows main package features. calibrating_trade-offs_tutorial Examples balancing different criteria identify candidate prioritizations. connectivity_tutorial Examples incorporating evaluating connectivity prioritizations using range approaches. management_zones_tutorial Tutorial using multiple management actions zones create detailed prioritizations. gurobi_installation Instructions installing setting Gurobi optimization software use package. solver_benchmark Reports run times solving conservation planning problems varying size complexity using different solvers. publication_record List publications cited package.","code":""},{"path":"https://prioritizr.net/reference/prioritizr.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"prioritizr: Systematic Conservation Prioritization in R — prioritizr","text":"Ball IR, Possingham HP, Watts M (2009) Marxan relatives: Software spatial conservation prioritisation Spatial conservation prioritisation: Quantitative methods computational tools. Eds Moilanen , Wilson KA, Possingham HP. Oxford University Press, Oxford, UK. Beyer HL, Dujardin Y, Watts , Possingham HP (2016) Solving conservation planning problems integer linear programming. Ecological Modelling, 228: 14--22. Billionnet (2013) Mathematical optimization ideas biodiversity conservation. European Journal Operational Research, 231: 514--534. Rodrigues , Cerdeira OJ, Gaston KJ (2000) Flexibility, efficiency, accountability: adapting reserve selection algorithms complex conservation problems. Ecography, 23: 565--574.","code":""},{"path":"https://prioritizr.net/reference/problem.html","id":null,"dir":"Reference","previous_headings":"","what":"Conservation planning problem — problem","title":"Conservation planning problem — problem","text":"Create systematic conservation planning problem. function used specify basic data used spatial prioritization problem: spatial distribution planning units costs, well features (e.g., species, ecosystems) need conserved. constructing object, can customized meet specific goals using objectives, targets, constraints, penalties. building problem, solve() function can used identify solutions.","code":""},{"path":"https://prioritizr.net/reference/problem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conservation planning problem — problem","text":"","code":"problem(x, features, ...)  # S4 method for SpatRaster,SpatRaster problem(x, features, run_checks, ...)  # S4 method for SpatRaster,ZonesSpatRaster problem(x, features, run_checks, ...)  # S4 method for data.frame,character problem(x, features, cost_column, ...)  # S4 method for data.frame,ZonesCharacter problem(x, features, cost_column, ...)  # S4 method for data.frame,data.frame problem(x, features, rij, cost_column, zones, ...)  # S4 method for numeric,data.frame problem(x, features, rij_matrix, ...)  # S4 method for matrix,data.frame problem(x, features, rij_matrix, ...)  # S4 method for sf,SpatRaster problem(x, features, cost_column, run_checks, ...)  # S4 method for sf,ZonesSpatRaster problem(x, features, cost_column, run_checks, ...)  # S4 method for sf,character problem(x, features, cost_column, ...)  # S4 method for sf,ZonesCharacter problem(x, features, cost_column, ...)  # S4 method for Raster,Raster problem(x, features, run_checks, ...)  # S4 method for Raster,ZonesRaster problem(x, features, run_checks, ...)  # S4 method for Spatial,Raster problem(x, features, cost_column, run_checks, ...)  # S4 method for Spatial,ZonesRaster problem(x, features, cost_column, run_checks, ...)  # S4 method for Spatial,character problem(x, features, cost_column, ...)  # S4 method for Spatial,ZonesCharacter problem(x, features, cost_column, ...)  # S4 method for sf,Raster problem(x, features, cost_column, run_checks, ...)  # S4 method for sf,ZonesRaster problem(x, features, cost_column, run_checks, ...)"},{"path":"https://prioritizr.net/reference/problem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conservation planning problem — problem","text":"x terra::rast(), sf::st_sf(), data.frame, matrix, numeric vector specifying planning units use reserve design exercise corresponding cost. may desirable exclude planning units analysis, example outside study area. exclude planning units, set cost raster cells NA, use add_locked_out_constraints() function. features feature data can specified variety ways. specific formats can used depend cost data format (.e., argument x) whether problem single zone multiple zones. problem single zone, feature data can specified following: x terra::rast() sf::st_sf() planning units argument features can terra::rast() object showing distribution conservation features. Missing values (.e., NA values) can used indicate absence feature particular cell instead explicitly setting cells zero. Note argument type features can used specify data problems involving single zone. x sf::st_sf() data.frame planning units argument features can character vector column names (x) correspond abundance occurrence different features planning unit. Note argument type can used create problems involving single zone. x data.frame, matrix, numeric vector planning units argument features can data.frame object containing names features. Note type argument supplied features argument rij rij_matrix must also supplied. type argument follow conventions used Marxan, wherein row corresponds different feature. must also contain following columns: id integer unique identifier feature identifiers used argument rij. name character name feature. prop numeric relative target feature (optional). amount numeric absolute target feature (optional). problem multiple zones, feature data can specified following: x terra::rast() sf::st_sf() planning units argument features can ZonesRaster object showing distribution conservation features multiple zones. , missing values (.e., NA values) can used indicate absence feature particular cell instead explicitly setting cells zero. x sf::st_sf() data.frame planning units argument features can ZonesCharacter object column names (x) correspond abundance occurrence different features planning unit different zones. ... used. run_checks logical flag indicating whether checks run ensure integrity input data. checks run default; however, large datasets may increase run time. taking prohibitively long time create prioritization problem, try setting run_checks FALSE. cost_column character name integer indicating column(s) cost data. argument must supplied argument x sf::st_sf() data.frame object. argument contain name column containing cost data management zone creating problems multiple zones. create problem single zone, set argument cost_column single column name. rij data.frame containing information amount feature planning unit assuming management zone. Similar data.frame arguments features, data.frame objects must follow conventions used Marxan. Note \"zone\" column needed problems involving single management zone. Specifically, argument contain following columns: pu integer planning unit identifier. species integer feature identifier. zone integer zone identifier (optional problems involving single zone). amount numeric amount feature planning unit. zones data.frame containing information zones. argument used argument x features data.frame objects problem built contains multiple zones. Following conventions used MarZone, argument contain following columns: columns: id integer zone identifier. name character zone name. rij_matrix list matrix dgCMatrix objects specifying amount feature (rows) within planning unit (columns) zone. list elements denote different zones, matrix rows denote features, matrix columns denote planning units. convenience, argument rij_matrix can single matrix dgCMatrix specifying problem single management zone. argument used argument x numeric matrix object.","code":""},{"path":"https://prioritizr.net/reference/problem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conservation planning problem — problem","text":"new problem() (ConservationProblem) object.","code":""},{"path":"https://prioritizr.net/reference/problem.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Conservation planning problem — problem","text":"systematic conservation planning exercise leverages data help inform conservation decision making. help ensure data -- resulting prioritizations -- relevant -arching goals exercise, decide management action (set actions) need considered exercise. example, actions include establishing protected areas, selecting land conservation easements, restoring habitat, planting trees carbon sequestration, eradicating invasive species, combination previous actions. exercise involves multiple different actions, can incorporated using multiple zones (see Management Zones vignette details). deciding management action(s), can compile following data. First, need create set planning units (.e., discrete spatial areas) inform decision making. Planning units often created subdividing study region set square hexagonal cells. can also created using administrative boundaries (e.g., provinces), land management boundaries (e.g., property boundaries derived cadastral data), ecological boundaries (e.g., based ecosystem classification data). size (.e., spatial grain) planning units often determined based compromise scale needed inform decision making, spatial accuracy (resolution) available datasets, computational resources available generating prioritizations (e.g., RAM number CPU cores computer). Second, need data quantify cost implementing management action within planning unit. Critically, cost data reflect management action(s) considered exercise. example, costs often specified using data reflect economic expenditure (e.g., land acquisition cost), socioeconomic conditions (e.g., human population density), opportunity costs foregone commercial activities (e.g., logging agriculture), opportunity costs foregone recreational activities (e.g., recreational fishing). cases -- depending management action(s) considered -- can make sense use constant cost value (e.g., planning units assigned cost value equal one) use cost value based spatial extent (e.g., planning unit assigned cost value based total area). Also, cases, want avoid negative cost values. negative value means place desirable implementing management action, places almost always selected prioritization even provide benefit. Third, need data quantify benefits implementing management actions within planning units. achieve , need select set conservation features relate -arching goals exercise. example, conservation features often include species (e.g., Clouded Leopard), habitats (e.g., mangroves cloud forest), ecosystems. benefit feature derives planning unit can take variety forms, typically occupancy (.e., presence absence), area occurrence within planning unit (e.g., based species' geographic range data), measure habitat suitability (e.g., estimated using statistical model). compiling data, minimal data needed generate prioritization. systematic conservation planning exercise involves prioritizing set management actions implemented within certain planning units. Critically, prioritization ideally optimize trade-benefits costs. accomplish , prioritizr package uses input data formulate optimization problems (see Optimization section details). Broadly speaking, goal optimization problem minimize (maximize) objective function set decision variables, subject series constraints. , objective function specifies metric evaluating conservation plans. decision variables control, usually one binary variable planning unit specify whether unit selected (approaches available, see decisions). constraints can thought rules must followed. example, constraints can used ensure prioritization must stay within certain budget. constraints can also leverage additional data help ensure prioritizations meet -arching goals exercise. example, account existing conservation efforts, obtain data delineating extent existing protected areas use constraints lock planning units covered (see add_locked_in_constraints).","code":""},{"path":"https://prioritizr.net/reference/problem.html","id":"optimization","dir":"Reference","previous_headings":"","what":"Optimization","title":"Conservation planning problem — problem","text":"prioritizr package uses exact algorithms solve reserve design problems (see solvers details). achieve , internally formulates mathematical optimization problems using mixed integer linear programming (MILP). general form problems can expressed matrix notation using following equation. $$\\mathit{Minimize} \\space \\mathbf{c}^{\\mathbf{T}}\\mathbf{x} \\space \\mathit{subject \\space } \\space \\mathbf{Ax}\\geq= \\leq \\mathbf{b}$$ , \\(x\\) vector decision variables, \\(c\\) \\(b\\) vectors known coefficients, \\(\\) constraint matrix. final term specifies series structural constraints relational operators constraint can either \\(\\ge\\), \\(=\\), \\(\\le\\) coefficients. example, minimum set cover problem, \\(c\\) vector costs planning unit, \\(b\\) vector targets conservation feature, relational operator \\(\\ge\\) features, \\(\\) representation matrix \\(A_{ij}=r_{ij}\\), representation level feature \\(\\) planning unit \\(j\\). wish see exactly conservation planning problem formulated mixed integer linear programming problem, can use write_problem() function save optimization problem plain-text file computer view using standard text editor (e.g., Notepad). Please note function internally computes amount feature planning unit data supplied (using rij_matrix() function). consequence, can take initialize large-scale conservation planning problems involve millions planning units.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/problem.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conservation planning problem — problem","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_pu_polygons <- get_sim_pu_polygons() sim_pu_points <- get_sim_pu_points() sim_pu_lines <- get_sim_pu_lines() sim_features <- get_sim_features() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_pu_polygons <- get_sim_zones_pu_polygons() sim_zones_features <- get_sim_zones_features()  # create problem using raster planning unit data p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.2) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # create problem using polygon planning unit data p2 <-   problem(sim_pu_polygons, sim_features, \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.2) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # create problem using line planning unit data p3 <-   problem(sim_pu_lines, sim_features, \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.2) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # create problem using point planning unit data p4 <-   problem(sim_pu_points, sim_features, \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.2) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # since geo-processing can be slow for large spatial vector datasets # (e.g., polygons, lines, points), it can be worthwhile to pre-process the # planning unit data so that it contains columns indicating the amount of # each feature inside each planning unit # (i.e., each column corresponds to a different feature)  # calculate the amount of each species within each planning unit pre_proc_data <- rij_matrix(sim_pu_polygons, sim_features)  # add extra columns to the polygon planning unit data # to indicate the amount of each species within each planning unit pre_proc_data <- as.data.frame(t(as.matrix(pre_proc_data))) names(pre_proc_data) <- names(sim_features) sim_pu_polygons <- cbind(sim_pu_polygons, pre_proc_data)  # create problem using the polygon planning unit data # with the pre-processed columns p5 <-   problem(sim_pu_polygons, features = names(pre_proc_data), \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.2) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # in addition to spatially explicit data, pre-processed aspatial data # can also be used to create a problem # (e.g., data created using external spreadsheet software) costs <- sim_pu_polygons$cost features <- data.frame(   id = seq_len(terra::nlyr(sim_features)),   name = names(sim_features) ) rij_mat <- rij_matrix(sim_pu_polygons, sim_features) p6 <-   problem(costs, features, rij_matrix = rij_mat) %>%   add_min_set_objective() %>%   add_relative_targets(0.2) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problems s1 <- solve(p1) s2 <- solve(p2) s3 <- solve(p3) s4 <- solve(p4) s5 <- solve(p5) s6 <- solve(p6)  # plot solutions for problems associated with spatial data plot(s1, main = \"raster data\", axes = FALSE)  plot(s2[, \"solution_1\"], main = \"polygon data\")  plot(s3[, \"solution_1\"], main = \"line data\")  plot(s4[, \"solution_1\"], main = \"point data\")  plot(s5[, \"solution_1\"], main = \"preprocessed data (polygon data)\")   # show solutions for problems associated with aspatial data str(s6) #>  num [1:90] 0 0 0 0 0 0 0 0 0 1 ... #>  - attr(*, \"objective\")= Named num 3586 #>   ..- attr(*, \"names\")= chr \"solution_1\" #>  - attr(*, \"status\")= Named chr \"OPTIMAL\" #>   ..- attr(*, \"names\")= chr \"solution_1\" #>  - attr(*, \"runtime\")= Named num 0.003 #>   ..- attr(*, \"names\")= chr \"solution_1\"  # create some problems with multiple zones  # first, create a matrix containing the targets for multi-zone problems # here each row corresponds to a different feature, each # column corresponds to a different zone, and values correspond # to the total (absolute) amount of a given feature that needs to be secured # in a given zone targets <- matrix(   rpois(15, 1),   nrow = number_of_features(sim_zones_features),   ncol = number_of_zones(sim_zones_features),   dimnames = list(     feature_names(sim_zones_features), zone_names(sim_zones_features)   ) )  # print targets print(targets) #>           zone_1 zone_2 zone_3 #> feature_1      2      0      0 #> feature_2      1      1      2 #> feature_3      3      3      2 #> feature_4      1      2      0 #> feature_5      2      1      1  # create a multi-zone problem with raster data p7 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_min_set_objective() %>%   add_absolute_targets(targets) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s7 <- solve(p7)  # plot solution # here, each layer/panel corresponds to a different zone and pixel values # indicate if a given planning unit has been allocated to a given zone par(mfrow = c(1, 1)) plot(s7, main = c(\"zone 1\", \"zone 2\", \"zone 3\"), axes = FALSE)   # alternatively, the category_layer function can be used to create # a new raster object containing the zone ids for each planning unit # in the solution (note this only works for problems with binary decisions) par(mfrow = c(1, 1)) plot(category_layer(s7), axes = FALSE)   # create a multi-zone problem with polygon data p8 <-   problem(     sim_zones_pu_polygons, sim_zones_features,     cost_column = c(\"cost_1\", \"cost_2\", \"cost_3\")   ) %>%   add_min_set_objective() %>%   add_absolute_targets(targets) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s8 <- solve(p8)  # create column containing the zone id for which each planning unit was # allocated to in the solution s8$solution <- category_vector(sf::st_drop_geometry(  s8[, c(\"solution_1_zone_1\", \"solution_1_zone_2\", \"solution_1_zone_3\")] )) s8$solution <- factor(s8$solution)  # plot solution plot(s8[, \"solution\"], axes = FALSE)   # create a multi-zone problem with polygon planning unit data # and where columns correspond to feature abundances  # to begin with, we will add columns to the planning unit data # that indicate the amount of each feature in each zone sim_zones_pu_polygons$spp1_z1 <- rpois(nrow(sim_zones_pu_polygons), 1) sim_zones_pu_polygons$spp2_z1 <- rpois(nrow(sim_zones_pu_polygons), 1) sim_zones_pu_polygons$spp3_z1 <- rpois(nrow(sim_zones_pu_polygons), 1) sim_zones_pu_polygons$spp1_z2 <- rpois(nrow(sim_zones_pu_polygons), 1) sim_zones_pu_polygons$spp2_z2 <- rpois(nrow(sim_zones_pu_polygons), 1) sim_zones_pu_polygons$spp3_z2 <- rpois(nrow(sim_zones_pu_polygons), 1)  # create problem with polygon planning unit data and use column names # to indicate feature data # additionally, to make this example slightly more interesting, # the problem will have proportion-type decisions such that # a proportion of each planning unit can be allocated to each of the # two management zones p9 <-   problem(     sim_zones_pu_polygons,     zones(       c(\"spp1_z1\", \"spp2_z1\", \"spp3_z1\"),       c(\"spp1_z2\", \"spp2_z2\", \"spp3_z2\"),       zone_names = c(\"z1\", \"z2\")     ),     cost_column = c(\"cost_1\", \"cost_2\")   ) %>%   add_min_set_objective() %>%   add_absolute_targets(targets[1:3, 1:2]) %>%   add_proportion_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s9 <- solve(p9)  # plot solution plot(s9[, c(\"solution_1_z1\", \"solution_1_z2\")], axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/proximity_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Proximity matrix — proximity_matrix","title":"Proximity matrix — proximity_matrix","text":"Create matrix showing planning units within certain spatial proximity .","code":""},{"path":"https://prioritizr.net/reference/proximity_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Proximity matrix — proximity_matrix","text":"","code":"proximity_matrix(x, distance)  # S3 method for Raster proximity_matrix(x, distance)  # S3 method for SpatRaster proximity_matrix(x, distance)  # S3 method for SpatialPolygons proximity_matrix(x, distance)  # S3 method for SpatialLines proximity_matrix(x, distance)  # S3 method for SpatialPoints proximity_matrix(x, distance)  # S3 method for sf proximity_matrix(x, distance)  # S3 method for default proximity_matrix(x, distance)"},{"path":"https://prioritizr.net/reference/proximity_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Proximity matrix — proximity_matrix","text":"x terra::rast() sf::sf() object representing planning units. distance numeric distance threshold. Planning units apart threshold treated within proximity .","code":""},{"path":"https://prioritizr.net/reference/proximity_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Proximity matrix — proximity_matrix","text":"dsCMatrix symmetric sparse matrix object. row column represents planning unit. Cells values indicate pair-wise distances different planning units within distance threshold (using ones zeros). reduce computational burden, cells among matrix diagonal set zero. Furthermore, argument x terra::rast() object, cells missing (NA) values set zero .","code":""},{"path":"https://prioritizr.net/reference/proximity_matrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Proximity matrix — proximity_matrix","text":"Proximity calculations performed using sf::st_is_within_distance().","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/proximity_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Proximity matrix — proximity_matrix","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_pu_polygons <- get_sim_pu_polygons() sim_pu_lines <- get_sim_pu_lines() sim_pu_points <- get_sim_pu_points()  # create proximity matrix using raster data ## crop raster to 9 cells to provide a small example r <- terra::crop(sim_pu_raster, c(0, 0.3, 0, 0.3))  ## make proximity matrix using a distance threshold of 2 cm_raster <- proximity_matrix(r, distance = 2)  # create proximity matrix using polygon data ## subset 9 polygons to provide a small example ply <- sim_pu_polygons[c(1:3, 11:13, 20:22), ]  ## make proximity matrix using a distance threshold of 2 cm_ply <- proximity_matrix(ply, distance = 2)  # create proximity matrix using line data ## subset 9 lines to provide a small example lns <- sim_pu_lines[c(1:3, 11:13, 20:22), ]  ## make proximity matrix cm_lns <- proximity_matrix(lns, distance = 2)  ## create proximity matrix using point data ## subset 9 points to provide a small example pts <- sim_pu_points[c(1:3, 11:13, 20:22), ]  # make proximity matrix cm_pts <- proximity_matrix(pts, distance = 2)  ## plot raster and proximity matrix plot(r, main = \"raster\", axes = FALSE)  Matrix::image(cm_raster, main = \"proximity matrix\")   ## plot polygons and proximity matrix plot(ply[, 1], main = \"polygons\", axes = FALSE)  Matrix::image(cm_ply, main = \"proximity matrix\")   ## plot lines and proximity matrix plot(lns[, 1], main = \"lines\", axes = FALSE)  Matrix::image(cm_lns, main = \"proximity matrix\")   ## plot points and proximity matrix plot(pts[, 1], main = \"points\", axes = FALSE)  Matrix::image(cm_pts, main = \"proximity matrix\")  # }"},{"path":"https://prioritizr.net/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. magrittr %>%, %T>%","code":""},{"path":"https://prioritizr.net/reference/rescale_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Rescale a matrix — rescale_matrix","title":"Rescale a matrix — rescale_matrix","text":"Linearly rescale matrix. Specifically, values matrix rescaled maximum value matrix equal new user-specified maximum value.","code":""},{"path":"https://prioritizr.net/reference/rescale_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rescale a matrix — rescale_matrix","text":"","code":"rescale_matrix(x, max = 1000)"},{"path":"https://prioritizr.net/reference/rescale_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rescale a matrix — rescale_matrix","text":"x matrix, array, Matrix object. max numeric new maximum value matrix. Defaults 1000.","code":""},{"path":"https://prioritizr.net/reference/rescale_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rescale a matrix — rescale_matrix","text":"matrix, array, Matrix object. returned object class argument x.","code":""},{"path":"https://prioritizr.net/reference/rescale_matrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rescale a matrix — rescale_matrix","text":"function particularly useful rescaling data prior optimization avoid numerical issues. example, boundary length (e.g., generated using boundary_matrix()) connectivity data (e.g., generated using connectivity_matrix()) can contain large values (e.g., values greater 1,000,000) large values can, turn, degrade performance exact algorithm solvers (see Details section presolve_check() information numerical issues). using function rescale boundary length connectivity data prior optimization (e.g., using add_boundary_penalties() add_connectivity_penalties(), can help avoid numerical issues optimization.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/rescale_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rescale a matrix — rescale_matrix","text":"","code":"# TODO"},{"path":"https://prioritizr.net/reference/rij_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Feature by planning unit matrix — rij_matrix","title":"Feature by planning unit matrix — rij_matrix","text":"Generate matrix showing amount feature planning unit (also known rij matrix).","code":""},{"path":"https://prioritizr.net/reference/rij_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Feature by planning unit matrix — rij_matrix","text":"","code":"rij_matrix(x, y, ...)  # S4 method for Raster,Raster rij_matrix(x, y, ...)  # S4 method for SpatRaster,SpatRaster rij_matrix(x, y, memory, ...)  # S4 method for Spatial,Raster rij_matrix(x, y, fun, ...)  # S4 method for sf,Raster rij_matrix(x, y, fun, ...)  # S4 method for sf,SpatRaster rij_matrix(x, y, fun, ...)"},{"path":"https://prioritizr.net/reference/rij_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Feature by planning unit matrix — rij_matrix","text":"x terra::rast() sf::sf() object representing planning units. y terra::rast()  object. ... used. memory logical calculations performed using method prioritizes reduced memory consumption speed? TRUE, calculations performed using method reduces memory consumption, can take long time complete. FALSE, calculations performed using method reduces run time, fail insufficient memory available. Defaults NA, calculations automatically performed using best method given available memory dataset sizes. Note parameter can used arguments x y terra::rast() objects. fun character summarizing values inside planning unit. parameter used argument x sf::sf() object. Defaults \"sum\".","code":""},{"path":"https://prioritizr.net/reference/rij_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Feature by planning unit matrix — rij_matrix","text":"dgCMatrix sparse matrix object. sparse matrix represents spatial intersection planning units features. Rows correspond features, columns correspond planning units. Values correspond amount (presence/absence) feature planning unit. example, amount third species second planning unit stored third column second row.","code":""},{"path":"https://prioritizr.net/reference/rij_matrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Feature by planning unit matrix — rij_matrix","text":"Generally, processing sf::st_sf() data takes much longer process terra::rast() data. , recommended use terra::rast() data planning units possible. performance function large terra::rast() datasets can improved increasing GDAL cache size. default cache size 25 MB. example, following code can used set cache size 4 GB.","code":"terra::gdalCache(size = 4000)"},{"path":"https://prioritizr.net/reference/rij_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Feature by planning unit matrix — rij_matrix","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_pu_polygons <- get_sim_pu_polygons() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_features <- get_sim_features()  # create rij matrix using raster layer planning units rij_raster <- rij_matrix(sim_pu_raster, sim_features) print(rij_raster) #> 5 x 90 sparse Matrix of class \"dgCMatrix\" #>                                                                                 #> feature_1 0.7150548 0.6990429 0.6859317 0.6783193 0.6782107 0.6863253 0.7017231 #> feature_2 0.2900901 0.3052216 0.3266036 0.3510977 0.3750470 0.3950113 0.4084749 #> feature_3 0.8178213 0.8064534 0.7852441 0.7541320 0.7131559 0.6628435 0.6046203 #> feature_4 0.2199663 0.2713800 0.3296247 0.3900085 0.4468281 0.4946333 0.5292249 #> feature_5 0.4533809 0.4413639 0.4343547 0.4355628 0.4474871 0.4714105 0.5068508 #>                                                                                 #> feature_1 0.7219284 0.7435505 0.7631509 0.7505900 0.7357790 0.7233151 0.7156627 #> feature_2 0.4142271 0.4123446 0.4038949 0.2800841 0.2967547 0.3181723 0.3409791 #> feature_3 0.5411391 0.4763017 0.4147364 0.8275983 0.8194545 0.8013062 0.7730504 #> feature_4 0.5479991 0.5498153 0.5348758 0.2208512 0.2738525 0.3350935 0.3998241 #> feature_5 0.5510725 0.5991256 0.6448475 0.4741697 0.4569167 0.4453572 0.4428185 #>                                                                                 #> feature_1 0.7147517 0.7212831 0.7343615 0.7516415 0.7699543 0.7897989 0.7772875 #> feature_2 0.3615030 0.3765606 0.3841341 0.3836641 0.3759393 0.2716298 0.2901825 #> feature_3 0.7345400 0.6860553 0.6288231 0.5654560 0.5000330 0.8346555 0.8298830 #> feature_4 0.4618047 0.5148343 0.5541170 0.5767631 0.5815260 0.2249796 0.2776009 #> feature_5 0.4517499 0.4732935 0.5068285 0.5495481 0.5965013 0.5022737 0.4802429 #>                                                                                 #> feature_1 0.7661407 0.7585160 0.7561970 0.7599327 0.7690603 0.7816119 0.7948577 #> feature_2 0.3119889 0.3334326 0.3508138 0.3612252 0.3631965 0.3568911 0.3438731 #> feature_3 0.8151305 0.7903745 0.7553823 0.7102172 0.6558247 0.5945687 0.5304188 #> feature_4 0.3390011 0.4047008 0.4684589 0.5238040 0.5655910 0.5906737 0.5976492 #> feature_5 0.4646212 0.4587578 0.4649526 0.4840959 0.5153215 0.5556964 0.6003282 #>                                                                                 #> feature_1 0.8059966 0.8286461 0.8189873 0.8095434 0.8020377 0.7980313 0.7983423 #> feature_2 0.3265679 0.2650109 0.2854743 0.3077757 0.3280176 0.3424767 0.3485511 #> feature_3 0.4684656 0.8381119 0.8367193 0.8254115 0.8043530 0.7733527 0.7323690 #> feature_4 0.5863706 0.2330116 0.2831343 0.3416658 0.4047077 0.4665769 0.5210694 #> feature_5 0.6432595 0.5353515 0.5095593 0.4907793 0.4822721 0.4860960 0.5028092 #>                                                                                 #> feature_1 0.8026563 0.8095316 0.8167838 0.8220091 0.8633036 0.8564520 0.8487799 #> feature_2 0.3453627 0.3338433 0.3163452 0.2959188 0.2603208 0.2824472 0.3051395 #> feature_3 0.6821137 0.6246373 0.5636095 0.5039577 0.8370439 0.8390267 0.8310691 #> feature_4 0.5629582 0.5888172 0.5969403 0.5869119 0.2456164 0.2910969 0.3438600 #> feature_5 0.5312405 0.5683321 0.6093528 0.6487381 0.5700379 0.5418938 0.5211593 #>                                                                                 #> feature_1 0.8415392 0.8360026 0.8325552 0.8337363 0.8339533 0.8912849 0.8867860 #> feature_2 0.3242198 0.3359588 0.3303278 0.3143945 0.2708325 0.2575975 0.2809245 #> feature_3 0.8136049 0.7866027 0.7045768 0.6519656 0.5398929 0.8305082 0.8359634 #> feature_4 0.4008068 0.4572360 0.5471036 0.5718452 0.5700791 0.2632827 0.3020677 #> feature_5 0.5108758 0.5127704 0.5521633 0.5850800 0.6559584 0.6024207 0.5734186 #>                                                                                 #> feature_1 0.8807106 0.8738915 0.8672825 0.8616340 0.8571536 0.8533099 0.8488533 #> feature_2 0.3037493 0.3216412 0.3308881 0.3295497 0.3179542 0.2985197 0.2749763 #> feature_3 0.8312740 0.8171942 0.7939453 0.7616869 0.7210739 0.6737961 0.6228802 #> feature_4 0.3465595 0.3945501 0.4425012 0.4859430 0.5203217 0.5418532 0.5479865 #> feature_5 0.5520171 0.5408934 0.5413573 0.5531961 0.5746993 0.6028225 0.6335756 #>                                                                                 #> feature_1 0.8419809 0.9117805 0.9090526 0.9042812 0.8979800 0.8833313 0.8758136 #> feature_2 0.2512416 0.2570026 0.2809260 0.3035274 0.3201754 0.3229680 0.3083414 #> feature_3 0.5724977 0.8175488 0.8267525 0.8253873 0.8145533 0.7665224 0.7305762 #> feature_4 0.5375278 0.2860727 0.3163391 0.3506471 0.3876576 0.4590604 0.4860971 #> feature_5 0.6626552 0.6287730 0.6001593 0.5792111 0.5681102 0.5773113 0.5951498 #>                                                                                 #> feature_1 0.8679237 0.8586633 0.8463772 0.9251764 0.9199524 0.9141710 0.9067838 #> feature_2 0.2863446 0.2611997 0.2370352 0.2589605 0.3047683 0.3200938 0.3251705 #> feature_3 0.6886563 0.6435894 0.5991429 0.7972733 0.8129275 0.8053969 0.7890073 #> feature_4 0.5023710 0.5050812 0.4927354 0.3133764 0.3566663 0.3816158 0.4070643 #> feature_5 0.6183284 0.6433893 0.6667633 0.6461805 0.5990580 0.5886663 0.5878728 #>                                                                                 #> feature_1 0.8981802 0.8643680 0.8473654 0.9322748 0.9317639 0.9287528 0.9159813 #> feature_2 0.3186414 0.2521341 0.2280966 0.2641903 0.2872474 0.3081174 0.3253427 #> feature_3 0.7645150 0.6570162 0.6186335 0.7690766 0.7873422 0.7936492 0.7768533 #> feature_4 0.4304725 0.4559778 0.4408970 0.3437657 0.3535038 0.3646749 0.3908502 #> feature_5 0.5957192 0.6486412 0.6667338 0.6528234 0.6269820 0.6089827 0.5991743 #>                                                                                 #> feature_1 0.9066665 0.8822224 0.8658993 0.8449602 0.9336696 0.9339561 0.9315392 #> feature_2 0.3170430 0.2740393 0.2478478 0.2243090 0.2736019 0.2951441 0.3143908 #> feature_3 0.7561399 0.6972504 0.6635963 0.6310227 0.7330271 0.7567351 0.7677462 #> feature_4 0.4031866 0.4135759 0.4061247 0.3879679 0.3750617 0.3743479 0.3741982 #> feature_5 0.6058227 0.6325923 0.6479832 0.6617020 0.6480033 0.6238689 0.6078230 #>                                                                       #> feature_1 0.9265291 0.9190510 0.8968893 0.8817701 0.8629507 0.8388748 #> feature_2 0.3265712 0.3282949 0.2992975 0.2742827 0.2483226 0.2255383 #> feature_3 0.7679649 0.7589920 0.7195554 0.6927857 0.6644490 0.6371886 #> feature_4 0.3753241 0.3774461 0.3785580 0.3729115 0.3601426 0.3391285 #> feature_5 0.6002170 0.6002851 0.6166496 0.6288149 0.6410043 0.6515710  # create rij matrix using polygon planning units rij_polygons <- rij_matrix(sim_pu_polygons, sim_features) print(rij_polygons) #> 5 x 90 sparse Matrix of class \"dgCMatrix\" #>                                                                                 #> feature_1 0.7150548 0.6990429 0.6859317 0.6783193 0.6782107 0.6863253 0.7017231 #> feature_2 0.2900901 0.3052216 0.3266036 0.3510977 0.3750470 0.3950113 0.4084749 #> feature_3 0.8178213 0.8064534 0.7852441 0.7541320 0.7131559 0.6628435 0.6046203 #> feature_4 0.2199663 0.2713800 0.3296247 0.3900085 0.4468281 0.4946333 0.5292249 #> feature_5 0.4533809 0.4413639 0.4343547 0.4355628 0.4474871 0.4714105 0.5068508 #>                                                                                 #> feature_1 0.7219284 0.7435505 0.7631509 0.7505900 0.7357790 0.7233151 0.7156627 #> feature_2 0.4142271 0.4123446 0.4038949 0.2800841 0.2967547 0.3181723 0.3409791 #> feature_3 0.5411391 0.4763017 0.4147364 0.8275983 0.8194545 0.8013062 0.7730504 #> feature_4 0.5479991 0.5498153 0.5348758 0.2208512 0.2738525 0.3350935 0.3998241 #> feature_5 0.5510725 0.5991256 0.6448475 0.4741697 0.4569167 0.4453572 0.4428185 #>                                                                                 #> feature_1 0.7147517 0.7212831 0.7343615 0.7516415 0.7699543 0.7897989 0.7772875 #> feature_2 0.3615030 0.3765606 0.3841341 0.3836641 0.3759393 0.2716298 0.2901825 #> feature_3 0.7345400 0.6860553 0.6288231 0.5654560 0.5000330 0.8346555 0.8298830 #> feature_4 0.4618047 0.5148343 0.5541170 0.5767631 0.5815260 0.2249796 0.2776009 #> feature_5 0.4517499 0.4732935 0.5068285 0.5495481 0.5965013 0.5022737 0.4802429 #>                                                                                 #> feature_1 0.7661407 0.7585160 0.7561970 0.7599327 0.7690603 0.7816119 0.7948577 #> feature_2 0.3119889 0.3334326 0.3508138 0.3612252 0.3631965 0.3568911 0.3438731 #> feature_3 0.8151305 0.7903745 0.7553823 0.7102172 0.6558247 0.5945687 0.5304188 #> feature_4 0.3390011 0.4047008 0.4684589 0.5238040 0.5655910 0.5906737 0.5976492 #> feature_5 0.4646212 0.4587578 0.4649526 0.4840959 0.5153215 0.5556964 0.6003282 #>                                                                                 #> feature_1 0.8059966 0.8286461 0.8189873 0.8095434 0.8020377 0.7980313 0.7983423 #> feature_2 0.3265679 0.2650109 0.2854743 0.3077757 0.3280176 0.3424767 0.3485511 #> feature_3 0.4684656 0.8381119 0.8367193 0.8254115 0.8043530 0.7733527 0.7323690 #> feature_4 0.5863706 0.2330116 0.2831343 0.3416658 0.4047077 0.4665769 0.5210694 #> feature_5 0.6432595 0.5353515 0.5095593 0.4907793 0.4822721 0.4860960 0.5028092 #>                                                                                 #> feature_1 0.8026563 0.8095316 0.8167838 0.8220091 0.8633036 0.8564520 0.8487799 #> feature_2 0.3453627 0.3338433 0.3163452 0.2959188 0.2603208 0.2824472 0.3051395 #> feature_3 0.6821137 0.6246373 0.5636095 0.5039577 0.8370439 0.8390267 0.8310691 #> feature_4 0.5629582 0.5888172 0.5969403 0.5869119 0.2456164 0.2910969 0.3438600 #> feature_5 0.5312405 0.5683321 0.6093528 0.6487381 0.5700379 0.5418938 0.5211593 #>                                                                                 #> feature_1 0.8415392 0.8360026 0.8325552 0.8337363 0.8339533 0.8912849 0.8867860 #> feature_2 0.3242198 0.3359588 0.3303278 0.3143945 0.2708325 0.2575975 0.2809245 #> feature_3 0.8136049 0.7866027 0.7045768 0.6519656 0.5398929 0.8305082 0.8359634 #> feature_4 0.4008068 0.4572360 0.5471036 0.5718452 0.5700791 0.2632827 0.3020677 #> feature_5 0.5108758 0.5127704 0.5521633 0.5850800 0.6559584 0.6024207 0.5734186 #>                                                                                 #> feature_1 0.8807106 0.8738915 0.8672825 0.8616340 0.8571536 0.8533099 0.8488533 #> feature_2 0.3037493 0.3216412 0.3308881 0.3295497 0.3179542 0.2985197 0.2749763 #> feature_3 0.8312740 0.8171942 0.7939453 0.7616869 0.7210739 0.6737961 0.6228802 #> feature_4 0.3465595 0.3945501 0.4425012 0.4859430 0.5203217 0.5418532 0.5479865 #> feature_5 0.5520171 0.5408934 0.5413573 0.5531961 0.5746993 0.6028225 0.6335756 #>                                                                                 #> feature_1 0.8419809 0.9117805 0.9090526 0.9042812 0.8979800 0.8833313 0.8758136 #> feature_2 0.2512416 0.2570026 0.2809260 0.3035274 0.3201754 0.3229680 0.3083414 #> feature_3 0.5724977 0.8175488 0.8267525 0.8253873 0.8145533 0.7665224 0.7305762 #> feature_4 0.5375278 0.2860727 0.3163391 0.3506471 0.3876576 0.4590604 0.4860971 #> feature_5 0.6626552 0.6287730 0.6001593 0.5792111 0.5681102 0.5773113 0.5951498 #>                                                                                 #> feature_1 0.8679237 0.8586633 0.8463772 0.9251764 0.9199524 0.9141710 0.9067838 #> feature_2 0.2863446 0.2611997 0.2370352 0.2589605 0.3047683 0.3200938 0.3251705 #> feature_3 0.6886563 0.6435894 0.5991429 0.7972733 0.8129275 0.8053969 0.7890073 #> feature_4 0.5023710 0.5050812 0.4927354 0.3133764 0.3566663 0.3816158 0.4070643 #> feature_5 0.6183284 0.6433893 0.6667633 0.6461805 0.5990580 0.5886663 0.5878728 #>                                                                                 #> feature_1 0.8981802 0.8643680 0.8473654 0.9322748 0.9317639 0.9287528 0.9159813 #> feature_2 0.3186414 0.2521341 0.2280966 0.2641903 0.2872474 0.3081174 0.3253427 #> feature_3 0.7645150 0.6570162 0.6186335 0.7690766 0.7873422 0.7936492 0.7768533 #> feature_4 0.4304725 0.4559778 0.4408970 0.3437657 0.3535038 0.3646749 0.3908502 #> feature_5 0.5957192 0.6486412 0.6667338 0.6528234 0.6269820 0.6089827 0.5991743 #>                                                                                 #> feature_1 0.9066665 0.8822224 0.8658993 0.8449602 0.9336696 0.9339561 0.9315392 #> feature_2 0.3170430 0.2740393 0.2478478 0.2243090 0.2736019 0.2951441 0.3143908 #> feature_3 0.7561399 0.6972504 0.6635963 0.6310227 0.7330271 0.7567351 0.7677462 #> feature_4 0.4031866 0.4135759 0.4061247 0.3879679 0.3750617 0.3743479 0.3741982 #> feature_5 0.6058227 0.6325923 0.6479832 0.6617020 0.6480033 0.6238689 0.6078230 #>                                                                       #> feature_1 0.9265291 0.9190510 0.8968893 0.8817701 0.8629507 0.8388748 #> feature_2 0.3265712 0.3282949 0.2992975 0.2742827 0.2483226 0.2255383 #> feature_3 0.7679649 0.7589920 0.7195554 0.6927857 0.6644490 0.6371886 #> feature_4 0.3753241 0.3774461 0.3785580 0.3729115 0.3601426 0.3391285 #> feature_5 0.6002170 0.6002851 0.6166496 0.6288149 0.6410043 0.6515710  # create rij matrix using raster planning units with multiple zones rij_zones_raster <- rij_matrix(sim_zones_pu_raster, sim_features) print(rij_zones_raster) #> 5 x 90 sparse Matrix of class \"dgCMatrix\" #>                                                                                 #> feature_1 0.7150548 0.6990429 0.6859317 0.6783193 0.6782107 0.6863253 0.7219284 #> feature_2 0.2900901 0.3052216 0.3266036 0.3510977 0.3750470 0.3950113 0.4142271 #> feature_3 0.8178213 0.8064534 0.7852441 0.7541320 0.7131559 0.6628435 0.5411391 #> feature_4 0.2199663 0.2713800 0.3296247 0.3900085 0.4468281 0.4946333 0.5479991 #> feature_5 0.4533809 0.4413639 0.4343547 0.4355628 0.4474871 0.4714105 0.5510725 #>                                                                                 #> feature_1 0.7435505 0.7631509 0.7505900 0.7357790 0.7233151 0.7156627 0.7147517 #> feature_2 0.4123446 0.4038949 0.2800841 0.2967547 0.3181723 0.3409791 0.3615030 #> feature_3 0.4763017 0.4147364 0.8275983 0.8194545 0.8013062 0.7730504 0.7345400 #> feature_4 0.5498153 0.5348758 0.2208512 0.2738525 0.3350935 0.3998241 0.4618047 #> feature_5 0.5991256 0.6448475 0.4741697 0.4569167 0.4453572 0.4428185 0.4517499 #>                                                                                 #> feature_1 0.7212831 0.7343615 0.7699543 0.7861227 0.7897989 0.7772875 0.7561970 #> feature_2 0.3765606 0.3841341 0.3759393 0.3627013 0.2716298 0.2901825 0.3508138 #> feature_3 0.6860553 0.6288231 0.5000330 0.4375452 0.8346555 0.8298830 0.7553823 #> feature_4 0.5148343 0.5541170 0.5815260 0.5684388 0.2249796 0.2776009 0.4684589 #> feature_5 0.4732935 0.5068285 0.5965013 0.6415349 0.5022737 0.4802429 0.4649526 #>                                                                                 #> feature_1 0.7599327 0.7690603 0.7816119 0.7948577 0.8059966 0.8286461 0.8189873 #> feature_2 0.3612252 0.3631965 0.3568911 0.3438731 0.3265679 0.2650109 0.2854743 #> feature_3 0.7102172 0.6558247 0.5945687 0.5304188 0.4684656 0.8381119 0.8367193 #> feature_4 0.5238040 0.5655910 0.5906737 0.5976492 0.5863706 0.2330116 0.2831343 #> feature_5 0.4840959 0.5153215 0.5556964 0.6003282 0.6432595 0.5353515 0.5095593 #>                                                                                 #> feature_1 0.8095434 0.8020377 0.7980313 0.7983423 0.8026563 0.8095316 0.8167838 #> feature_2 0.3077757 0.3280176 0.3424767 0.3485511 0.3453627 0.3338433 0.3163452 #> feature_3 0.8254115 0.8043530 0.7733527 0.7323690 0.6821137 0.6246373 0.5636095 #> feature_4 0.3416658 0.4047077 0.4665769 0.5210694 0.5629582 0.5888172 0.5969403 #> feature_5 0.4907793 0.4822721 0.4860960 0.5028092 0.5312405 0.5683321 0.6093528 #>                                                                                 #> feature_1 0.8220091 0.8633036 0.8564520 0.8487799 0.8360026 0.8330038 0.8337363 #> feature_2 0.2959188 0.2603208 0.2824472 0.3051395 0.3359588 0.3380832 0.3143945 #> feature_3 0.5039577 0.8370439 0.8390267 0.8310691 0.7866027 0.7500573 0.6519656 #> feature_4 0.5869119 0.2456164 0.2910969 0.3438600 0.4572360 0.5076754 0.5718452 #> feature_5 0.6487381 0.5700379 0.5418938 0.5211593 0.5127704 0.5270232 0.5850800 #>                                                                                 #> feature_1 0.8348882 0.8339533 0.8912849 0.8867860 0.8807106 0.8738915 0.8672825 #> feature_2 0.2933767 0.2708325 0.2575975 0.2809245 0.3037493 0.3216412 0.3308881 #> feature_3 0.5955431 0.5398929 0.8305082 0.8359634 0.8312740 0.8171942 0.7939453 #> feature_4 0.5797670 0.5700791 0.2632827 0.3020677 0.3465595 0.3945501 0.4425012 #> feature_5 0.6213430 0.6559584 0.6024207 0.5734186 0.5520171 0.5408934 0.5413573 #>                                                                                 #> feature_1 0.8616340 0.8571536 0.8488533 0.9117805 0.9090526 0.9042812 0.8979800 #> feature_2 0.3295497 0.3179542 0.2749763 0.2570026 0.2809260 0.3035274 0.3201754 #> feature_3 0.7616869 0.7210739 0.6228802 0.8175488 0.8267525 0.8253873 0.8145533 #> feature_4 0.4859430 0.5203217 0.5479865 0.2860727 0.3163391 0.3506471 0.3876576 #> feature_5 0.5531961 0.5746993 0.6335756 0.6287730 0.6001593 0.5792111 0.5681102 #>                                                                                 #> feature_1 0.8908018 0.8833313 0.8758136 0.8679237 0.8586633 0.8463772 0.9251764 #> feature_2 0.3271982 0.3229680 0.3083414 0.2863446 0.2611997 0.2370352 0.2589605 #> feature_3 0.7947903 0.7665224 0.7305762 0.6886563 0.6435894 0.5991429 0.7972733 #> feature_4 0.4249398 0.4590604 0.4860971 0.5023710 0.5050812 0.4927354 0.3133764 #> feature_5 0.5676758 0.5773113 0.5951498 0.6183284 0.6433893 0.6667633 0.6461805 #>                                                                                 #> feature_1 0.9237208 0.9199524 0.9141710 0.9067838 0.8981802 0.8885294 0.8775561 #> feature_2 0.2828033 0.3047683 0.3200938 0.3251705 0.3186414 0.3017897 0.2781030 #> feature_3 0.8107003 0.8129275 0.8053969 0.7890073 0.7645150 0.7330004 0.6962687 #> feature_4 0.3337335 0.3566663 0.3816158 0.4070643 0.4304725 0.4485815 0.4580145 #> feature_5 0.6187615 0.5990580 0.5886663 0.5878728 0.5957192 0.6102524 0.6288607 #>                                                                                 #> feature_1 0.8643680 0.8473654 0.9322748 0.9317639 0.9287528 0.9234146 0.9159813 #> feature_2 0.2521341 0.2280966 0.2641903 0.2872474 0.3081174 0.3219892 0.3253427 #> feature_3 0.6570162 0.6186335 0.7690766 0.7873422 0.7936492 0.7897301 0.7768533 #> feature_4 0.4559778 0.4408970 0.3437657 0.3535038 0.3646749 0.3773969 0.3908502 #> feature_5 0.6486412 0.6667338 0.6528234 0.6269820 0.6089827 0.5997976 0.5991743 #>                                                                                 #> feature_1 0.9066665 0.8955188 0.8822224 0.8658993 0.8449602 0.9336696 0.9339561 #> feature_2 0.3170430 0.2986799 0.2740393 0.2478478 0.2243090 0.2736019 0.2951441 #> feature_3 0.7561399 0.7289606 0.6972504 0.6635963 0.6310227 0.7330271 0.7567351 #> feature_4 0.4031866 0.4117466 0.4135759 0.4061247 0.3879679 0.3750617 0.3743479 #> feature_5 0.6058227 0.6177441 0.6325923 0.6479832 0.6617020 0.6480033 0.6238689 #>                                                                       #> feature_1 0.9315392 0.9190510 0.9091912 0.8968893 0.8629507 0.8388748 #> feature_2 0.3143908 0.3282949 0.3186099 0.2992975 0.2483226 0.2255383 #> feature_3 0.7677462 0.7589920 0.7423053 0.7195554 0.6644490 0.6371886 #> feature_4 0.3741982 0.3774461 0.3792402 0.3785580 0.3601426 0.3391285 #> feature_5 0.6078230 0.6002851 0.6064383 0.6166496 0.6410043 0.6515710 # }"},{"path":"https://prioritizr.net/reference/run_calculations.html","id":null,"dir":"Reference","previous_headings":"","what":"Run calculations — run_calculations","title":"Run calculations — run_calculations","text":"Execute preliminary calculations conservation problem store results later use. function useful creating slightly different versions conservation planning problem involve pre-processing steps (e.g., calculating boundary data), means calculations run multiple times.","code":""},{"path":"https://prioritizr.net/reference/run_calculations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run calculations — run_calculations","text":"","code":"run_calculations(x)"},{"path":"https://prioritizr.net/reference/run_calculations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run calculations — run_calculations","text":"x problem() object.","code":""},{"path":"https://prioritizr.net/reference/run_calculations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run calculations — run_calculations","text":"invisible TRUE indicating success.","code":""},{"path":"https://prioritizr.net/reference/run_calculations.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Run calculations — run_calculations","text":"function used effect modifying input ConservationProblem object. , return anything. use function pipe() operators, use %T>% operator %>% operator.","code":""},{"path":"https://prioritizr.net/reference/run_calculations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run calculations — run_calculations","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features()  # let us imagine a scenario where we wanted to understand the effect of # setting different targets on our solution.  # create a conservation problem with no targets p <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_boundary_penalties(10, 0.5) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # create a copies of p and add targets p1 <- p %>% add_relative_targets(0.1) p2 <- p %>% add_relative_targets(0.2) p3 <- p %>% add_relative_targets(0.3)  # now solve each of the different problems and record the time spent # solving them s1 <- system.time({solve(p1); solve(p2); solve(p3)})  # This approach is inefficient. Since these problems all share the same # planning units it is actually performing the same calculations three times. # To avoid this, we can use the \"run_calculations\" function before creating # the copies. Normally, R runs the calculations just before solving the # problem  # recreate a conservation problem with no targets and tell R run the # preliminary calculations. Note how we use the %T>% operator here. p <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_boundary_penalties(10, 0.5) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE) %T>%   run_calculations()  # create a copies of p and add targets just like before p1 <- p %>% add_relative_targets(0.1) p2 <- p %>% add_relative_targets(0.2) p3 <- p %>% add_relative_targets(0.3)  # solve each of the different problems and record the time spent # solving them s2 <- system.time({solve(p1); solve(p2); solve(p3)})  # now lets compare the times print(s1) # time spent without running preliminary calculations #>    user  system elapsed  #>   0.872   0.004   0.895  print(s2) # time spent after running preliminary calculations #>    user  system elapsed  #>   0.845   0.000   0.845   # As we can see, we can save time by running the preliminary # calculations before making copies of the problem with slightly # different constraints. Although the time saved in this example # is rather small, this is because the example data are very small. # We would expect larger time savings for larger datasets. # }"},{"path":"https://prioritizr.net/reference/show.html","id":null,"dir":"Reference","previous_headings":"","what":"Show — show","title":"Show — show","text":"Display information object.","code":""},{"path":"https://prioritizr.net/reference/show.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Show — show","text":"","code":"# S4 method for ConservationModifier show(x)  # S4 method for ConservationProblem show(x)  # S4 method for OptimizationProblem show(x)  # S4 method for Solver show(x)"},{"path":"https://prioritizr.net/reference/show.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Show — show","text":"x object.","code":""},{"path":"https://prioritizr.net/reference/show.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Show — show","text":"None.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/sim_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Get simulated conservation planning data — sim_data","title":"Get simulated conservation planning data — sim_data","text":"set functions available importing simulated datasets. datasets designed creating small example spatial prioritizations.","code":""},{"path":"https://prioritizr.net/reference/sim_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get simulated conservation planning data — sim_data","text":"","code":"get_sim_pu_polygons()  get_sim_zones_pu_polygons()  get_sim_pu_lines()  get_sim_pu_points()  get_sim_pu_raster()  get_sim_locked_in_raster()  get_sim_locked_out_raster()  get_sim_zones_pu_raster()  get_sim_features()  get_sim_zones_features()  get_sim_phylogeny()"},{"path":"https://prioritizr.net/reference/sim_data.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Get simulated conservation planning data — sim_data","text":"get_sim_pu_polygons() sf::st_sf() object. get_sim_zones_pu_polygons() sf::st_sf() object. get_sim_pu_lines() sf::st_sf() object. get_sim_pu_points() sf::st_sf() object. get_sim_pu_raster() terra::rast() object. get_sim_zones_pu_raster() terra::rast() object. get_sim_locked_in_raster() terra::rast() object. get_sim_locked_out_raster() terra::rast() object. get_sim_features() terra::rast() object. get_sim_zones_features() ZonesRaster() object. get_sim_phylogeny() terra::rast() object.","code":""},{"path":"https://prioritizr.net/reference/sim_data.html","id":"single-zone-datasets","dir":"Reference","previous_headings":"","what":"Single zone datasets","title":"Get simulated conservation planning data — sim_data","text":"following functions provided generating spatial prioritizations contain single management zone. get_sim_pu_raster() Import planning unit data stored raster format. , cell values indicate planning unit cost missing (NA) values indicate cell planning unit. get_sim_locked_in_raster() Import planning unit data stored raster format. , cell values binary indicate planning units locked solution. get_sim_locked_out_raster() Import planning unit data stored raster format. , cell values binary indicate planning units locked solution. get_sim_pu_polygons() Import planning unit data stored vector format. , planning units represented using spatial polygons (e.g., polygon corresponds different management areas). data contains columns indicating expenditure required prioritizing planning unit (\"cost\" column), planning units selected solution (\"locked_in\" column), planning units never selected solution (\"locked_out\" column). get_sim_pu_points() Import planning unit data stored vector format. , planning units represented using spatial lines (e.g., line corresponds different section along river) . attribute table follows conventions sim_pu_polygons. get_sim_pu_lines() Import planning unit data stored vector format. , planning units represented using spatial points (e.g., point corresponds different site) . attribute table follows conventions sim_pu_polygons. get_sim_features() Import feature data stored raster format. , data describe spatial distribution five species. layer corresponds different species, cell values indicate habitat suitability. get_sim_phylogeny() Import phylogenetic tree ten species.","code":""},{"path":"https://prioritizr.net/reference/sim_data.html","id":"multiple-zone-datasets","dir":"Reference","previous_headings":"","what":"Multiple zone datasets","title":"Get simulated conservation planning data — sim_data","text":"following functions provided generating spatial prioritizations contain multiple management zones. get_sim_zones_pu_raster() Import planning unit data multiple management zones stored raster format. , layer indicates cost different management zone. Cells NA values given zone indicate planning unit allocated zone solution. Additionally, cells NA values layers planning unit. get_sim_zones_pu_polygons() Import planning unit data multiple management zones stored vector format. , planning units represented using spatial polygons. data contains columns indicating expenditure required prioritizing planning unit different management zones (\"cost_1\", \"cost_2\", \"cost_3\" columns), series columns indicating value planning unit assigned solution (\"locked_1\", \"locked_2\", \"locked_3\" columns). locked columns, planning units locked specific value assigned missing (NA) value. get_sim_zones_features() Import feature data multiple management zones stored raster format. , data describe spatial distribution ten species three different management zones.","code":""},{"path":"https://prioritizr.net/reference/sim_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get simulated conservation planning data — sim_data","text":"","code":"# load data sim_pu_polygons <- get_sim_pu_polygons() sim_zones_pu_polygons <- get_sim_zones_pu_polygons() sim_pu_lines <- get_sim_pu_lines() sim_pu_points <- get_sim_pu_points() sim_pu_raster <- get_sim_pu_raster() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_locked_in_raster <- get_sim_locked_in_raster() sim_locked_out_raster <- get_sim_locked_out_raster() sim_phylogeny <- get_sim_phylogeny() sim_features <- get_sim_features() sim_zones_features <- get_sim_zones_features()  # plot raster data # \\dontrun{ par(mfrow = c(2, 2)) plot(sim_pu_raster, main = \"planning units (raster)\", axes = FALSE) plot(sim_locked_in_raster, main = \"locked in units (raster)\", axes = FALSE) plot(sim_locked_out_raster, main = \"locked out units (raster)\", axes = FALSE)  # plot vector planning unit data par(mfrow = c(1, 1))  plot(sim_pu_polygons)  plot(sim_pu_lines)  plot(sim_pu_points)   # plot vector planning unit data for multiple management zones plot(sim_zones_pu_polygons)   # plot phylogeny data par(mfrow = c(1, 1)) plot(sim_phylogeny, main = \"simulated phylogeny\")   # plot feature data par(mfrow = c(1, 1)) plot(sim_features, axes = FALSE)   # plot cost data for multiple management zones par(mfrow = c(1, 1)) plot(sim_zones_pu_raster, axes = FALSE)   # plot feature data for multiple management zones plot_names <- paste0(   \"Species \",    rep(      seq_len(number_of_zones(sim_zones_features)),      number_of_features(sim_zones_features)    ),    \" (zone \",    rep(      seq_len(number_of_features(sim_zones_features)),      each = number_of_zones(sim_zones_features)    ),    \")\" ) plot(   terra::rast(as.list(sim_zones_features)),    main = plot_names, axes = FALSE )  # }"},{"path":"https://prioritizr.net/reference/simulate_cost.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate cost data — simulate_cost","title":"Simulate cost data — simulate_cost","text":"Generates simulated cost data using Gaussian random fields.","code":""},{"path":"https://prioritizr.net/reference/simulate_cost.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate cost data — simulate_cost","text":"","code":"simulate_cost(x, n, intensity, sd, scale)  # S3 method for Raster simulate_cost(x, n = 1, intensity = 100, sd = 20, scale = 2.5)  # S3 method for SpatRaster simulate_cost(x, n = 1, intensity = 100, sd = 20, scale = 2.5)"},{"path":"https://prioritizr.net/reference/simulate_cost.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate cost data — simulate_cost","text":"x terra::rast() object use template. n integer number layers simulate. Defaults 1. intensity numeric average value simulated data. Defaults 100. sd numeric standard deviation simulated data. Defaults 20. scale numeric parameter control level spatial auto-correlation simulated data. Defaults 2.5.","code":""},{"path":"https://prioritizr.net/reference/simulate_cost.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate cost data — simulate_cost","text":"terra::rast() object integer values greater zero.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/simulate_cost.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate cost data — simulate_cost","text":"","code":"# \\dontrun{ # create raster r <- terra::rast(   ncols = 10, nrows = 10, xmin = 0, xmax = 1, ymin = 0, ymax = 1, vals = 1 )  # simulate data cost <- simulate_cost(r)  # plot simulated species plot(cost, main = \"simulated cost data\", axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/simulate_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate data — simulate_data","title":"Simulate data — simulate_data","text":"Simulate spatially auto-correlated data using Gaussian random fields.","code":""},{"path":"https://prioritizr.net/reference/simulate_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate data — simulate_data","text":"","code":"simulate_data(x, n, scale, intensity, sd, transform)  # S3 method for Raster simulate_data(   x,   n = 1,   scale = 0.5,   intensity = 0,   sd = 1,   transform = identity )  # S3 method for SpatRaster simulate_data(   x,   n = 1,   scale = 0.5,   intensity = 0,   sd = 1,   transform = identity )"},{"path":"https://prioritizr.net/reference/simulate_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate data — simulate_data","text":"x terra::rast() object use template. n integer number layers simulate. Defaults 1. scale numeric parameter control level spatial auto-correlation simulated data. Defaults 0.5. intensity numeric average value simulated data. Defaults 0. sd numeric standard deviation simulated data. Defaults 1. transform function transform values output simulation. Defaults identity() function values remain following transformation.","code":""},{"path":"https://prioritizr.net/reference/simulate_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate data — simulate_data","text":"terra::rast() object.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/simulate_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate data — simulate_data","text":"","code":"# \\dontrun{ # create raster r <- terra::rast(   ncols = 10, nrows = 10, xmin = 0, xmax = 1, ymin = 0, ymax = 1, vals = 1 )  # simulate data using a Gaussian field x <- simulate_data(r, n = 1, scale = 0.2)  # plot simulated data plot(x, main = \"simulated data\", axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/simulate_species.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate species habitat suitability data — simulate_species","title":"Simulate species habitat suitability data — simulate_species","text":"Generates simulated species data using Gaussian random fields.","code":""},{"path":"https://prioritizr.net/reference/simulate_species.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate species habitat suitability data — simulate_species","text":"","code":"simulate_species(x, n, scale)  # S3 method for Raster simulate_species(x, n = 1, scale = 0.5)  # S3 method for SpatRaster simulate_species(x, n = 1, scale = 0.5)"},{"path":"https://prioritizr.net/reference/simulate_species.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate species habitat suitability data — simulate_species","text":"x terra::rast() object use template. n integer number layers simulate. Defaults 1. scale numeric parameter control level spatial auto-correlation simulated data. Defaults 0.5.","code":""},{"path":"https://prioritizr.net/reference/simulate_species.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate species habitat suitability data — simulate_species","text":"terra::rast() object values zero one.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/simulate_species.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate species habitat suitability data — simulate_species","text":"","code":"# \\dontrun{ # create raster r <- terra::rast(   ncols = 10, nrows = 10, xmin = 0, xmax = 1, ymin = 0, ymax = 1, vals = 1 )  # simulate data for 4 species spp <- simulate_species(r, 4)  # plot simulated species plot(spp, main = \"simulated species distributions\", axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/solve.html","id":null,"dir":"Reference","previous_headings":"","what":"Solve — solve","title":"Solve — solve","text":"Solve conservation planning problem.","code":""},{"path":"https://prioritizr.net/reference/solve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Solve — solve","text":"","code":"# S3 method for ConservationProblem solve(a, b, ..., run_checks = TRUE, force = FALSE)"},{"path":"https://prioritizr.net/reference/solve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Solve — solve","text":"problem() object. b missing. ... arguments passed compile(). run_checks logical flag indicating whether presolve checks run prior solving problem. checks performed using presolve_check() function. Defaults TRUE. Skipping checks may reduce run time large problems. force logical flag indicating attempt made solve problem even potential issues detected presolve checks. Defaults FALSE.","code":""},{"path":"https://prioritizr.net/reference/solve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Solve — solve","text":"numeric, matrix, data.frame, sf::st_sf(), terra::rast() object containing solution problem. Additionally, returned object following additional attributes: \"objective\" containing solution's objective, \"runtime\" denoting number seconds elapsed solving problem, \"status\" describing status solution (e.g., \"OPTIMAL\" indicates optimal solution found).","code":""},{"path":"https://prioritizr.net/reference/solve.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Solve — solve","text":"formulating conservation planning problem(), can solved using exact algorithm solver (see solvers available solvers). solver explicitly specified, best available exact algorithm solver used default (see add_default_solver()). Although exact algorithm solvers often display lot information really helpful (e.g., nodes, cutting planes), display information progress making solving problem (e.g., performance best solution found given point time). potential issues detected presolve checks (see presolve_check()) problem forcibly solved (.e., force = TRUE), also worth checking warnings displayed solver see potential issues actually causing issues (e.g., Gurobi can display warnings include \"Warning: Model contains large matrix coefficient range\" \"Warning: Model contains large rhs\").","code":""},{"path":"https://prioritizr.net/reference/solve.html","id":"output-format","dir":"Reference","previous_headings":"","what":"Output format","title":"Solve — solve","text":"function output solutions similar format planning units associated . Specifically, return solutions based following types planning units. numeric planning units solution returned numeric vector. , element vector corresponds different planning unit. Note portfolio used generate multiple solutions, list numeric vectors returned. matrix planning units solution returned matrix object. , rows correspond different planning units, columns correspond different  management zones. Note portfolio used generate multiple solutions, list matrix objects returned. terra::rast() planning units solution returned terra::rast() object. argument x contains multiple zones, object different layer management zone. Note portfolio used generate multiple solutions, list terra::rast() objects returned. sf::sf(), data.frame planning units solution returned data format planning units. , row corresponds different planning unit, columns contain solutions. argument contains single zone, solution object contain columns named solution. Specifically, column names containing solution values named \"solution_XXX\" \"XXX\" corresponds solution identifier (e.g., \"solution_1\"). argument contains multiple zones, columns containing solutions named \"solution_XXX_YYY\" \"XXX\" corresponds solution identifier \"YYY\" name management zone (e.g., \"solution_1_zone1\").","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/solve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Solve — solve","text":"","code":"# \\dontrun{ # set seed for reproducibility set.seed(500)  # load data sim_pu_raster <- get_sim_pu_raster() sim_pu_polygons <- get_sim_pu_polygons() sim_features <- get_sim_features() sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_pu_polygons <- get_sim_zones_pu_polygons() sim_zones_features <- get_sim_zones_features()  # build minimal conservation problem with raster data p1 <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve the problem s1 <- solve(p1)  # print solution print(s1) #> class       : SpatRaster  #> dimensions  : 10, 10, 1  (nrow, ncol, nlyr) #> resolution  : 0.1, 0.1  (x, y) #> extent      : 0, 1, 0, 1  (xmin, xmax, ymin, ymax) #> coord. ref. : Undefined Cartesian SRS  #> source(s)   : memory #> name        : layer  #> min value   :     0  #> max value   :     1   # print attributes describing the optimization process and the solution print(attr(s1, \"objective\")) #> solution_1  #>   1987.399  print(attr(s1, \"runtime\")) #> solution_1  #>      0.023  print(attr(s1, \"status\")) #> solution_1  #>  \"OPTIMAL\"   # calculate feature representation in the solution r1 <- eval_feature_representation_summary(p1, s1) print(r1) #> # A tibble: 5 × 5 #>   summary feature   total_amount absolute_held relative_held #>   <chr>   <chr>            <dbl>         <dbl>         <dbl> #> 1 overall feature_1         83.3          8.91         0.107 #> 2 overall feature_2         31.2          3.13         0.100 #> 3 overall feature_3         72.0          7.34         0.102 #> 4 overall feature_4         42.7          4.35         0.102 #> 5 overall feature_5         56.7          6.01         0.106  # plot solution plot(s1, main = \"solution\", axes = FALSE)   # build minimal conservation problem with polygon data p2 <-   problem(sim_pu_polygons, sim_features, cost_column = \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve the problem s2 <- solve(p2)  # print solution print(s2) #> Simple feature collection with 90 features and 4 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 0 ymin: 0 xmax: 1 ymax: 1 #> Projected CRS: Undefined Cartesian SRS #> # A tibble: 90 × 5 #>     cost locked_in locked_out solution_1                                    geom #>    <dbl> <lgl>     <lgl>           <dbl>                           <POLYGON [m]> #>  1  216. FALSE     FALSE               0     ((0 1, 0.1 1, 0.1 0.9, 0 0.9, 0 1)) #>  2  213. FALSE     FALSE               0 ((0.1 1, 0.2 1, 0.2 0.9, 0.1 0.9, 0.1 … #>  3  207. FALSE     FALSE               0 ((0.2 1, 0.3 1, 0.3 0.9, 0.2 0.9, 0.2 … #>  4  209. FALSE     TRUE                0 ((0.3 1, 0.4 1, 0.4 0.9, 0.3 0.9, 0.3 … #>  5  214. FALSE     FALSE               0 ((0.4 1, 0.5 1, 0.5 0.9, 0.4 0.9, 0.4 … #>  6  214. FALSE     FALSE               0 ((0.5 1, 0.6 1, 0.6 0.9, 0.5 0.9, 0.5 … #>  7  210. FALSE     FALSE               0 ((0.6 1, 0.7 1, 0.7 0.9, 0.6 0.9, 0.6 … #>  8  211. FALSE     TRUE                0 ((0.7 1, 0.8 1, 0.8 0.9, 0.7 0.9, 0.7 … #>  9  210. FALSE     FALSE               0 ((0.8 1, 0.9 1, 0.9 0.9, 0.8 0.9, 0.8 … #> 10  204. FALSE     FALSE               0   ((0.9 1, 1 1, 1 0.9, 0.9 0.9, 0.9 1)) #> # ℹ 80 more rows  # calculate feature representation in the solution r2 <- eval_feature_representation_summary(p2, s2[, \"solution_1\"]) print(r2) #> # A tibble: 5 × 5 #>   summary feature   total_amount absolute_held relative_held #>   <chr>   <chr>            <dbl>         <dbl>         <dbl> #> 1 overall feature_1         74.5          8.05         0.108 #> 2 overall feature_2         28.1          2.83         0.101 #> 3 overall feature_3         64.9          6.65         0.103 #> 4 overall feature_4         38.2          3.87         0.101 #> 5 overall feature_5         50.7          5.41         0.107  # plot solution plot(s2[, \"solution_1\"], main = \"solution\", axes = FALSE)   # build multi-zone conservation problem with raster data p3 <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_min_set_objective() %>%   add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve the problem s3 <- solve(p3)  # print solution print(s3) #> class       : SpatRaster  #> dimensions  : 10, 10, 3  (nrow, ncol, nlyr) #> resolution  : 0.1, 0.1  (x, y) #> extent      : 0, 1, 0, 1  (xmin, xmax, ymin, ymax) #> coord. ref. : Undefined Cartesian SRS  #> source(s)   : memory #> names       : zone_1, zone_2, zone_3  #> min values  :      0,      0,      0  #> max values  :      1,      1,      1   # calculate feature representation in the solution r3 <- eval_feature_representation_summary(p3, s3) print(r3) #> # A tibble: 20 × 5 #>    summary feature   total_amount absolute_held relative_held #>    <chr>   <chr>            <dbl>         <dbl>         <dbl> #>  1 overall feature_1        250.          47.1          0.188 #>  2 overall feature_2         93.6         17.9          0.191 #>  3 overall feature_3        216.          41.6          0.193 #>  4 overall feature_4        128.          23.7          0.185 #>  5 overall feature_5        170.          31.6          0.186 #>  6 zone_1  feature_1         83.3         16.5          0.198 #>  7 zone_1  feature_2         31.2          5.65         0.181 #>  8 zone_1  feature_3         72.0         14.2          0.198 #>  9 zone_1  feature_4         42.7          7.56         0.177 #> 10 zone_1  feature_5         56.7         11.1          0.197 #> 11 zone_2  feature_1         83.3         15.7          0.189 #> 12 zone_2  feature_2         31.2          6.03         0.193 #> 13 zone_2  feature_3         72.0         14.5          0.201 #> 14 zone_2  feature_4         42.7          7.82         0.183 #> 15 zone_2  feature_5         56.7         10.3          0.181 #> 16 zone_3  feature_1         83.3         14.8          0.178 #> 17 zone_3  feature_2         31.2          6.22         0.199 #> 18 zone_3  feature_3         72.0         13.0          0.180 #> 19 zone_3  feature_4         42.7          8.27         0.194 #> 20 zone_3  feature_5         56.7         10.2          0.180  # plot solution plot(category_layer(s3), main = \"solution\", axes = FALSE)   # build multi-zone conservation problem with polygon data p4 <-   problem(     sim_zones_pu_polygons, sim_zones_features,     cost_column = c(\"cost_1\", \"cost_2\", \"cost_3\")   ) %>%   add_min_set_objective() %>%   add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5, ncol = 3)) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve the problem s4 <- solve(p4)  # print solution print(s4) #> Simple feature collection with 90 features and 9 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 0 ymin: 0 xmax: 1 ymax: 1 #> Projected CRS: Undefined Cartesian SRS #> # A tibble: 90 × 10 #>    cost_1 cost_2 cost_3 locked_1 locked_2 locked_3 solution_1_zone_1 #>     <dbl>  <dbl>  <dbl> <lgl>    <lgl>    <lgl>                <dbl> #>  1   216.   183.   205. FALSE    FALSE    FALSE                    0 #>  2   213.   189.   210. FALSE    FALSE    FALSE                    0 #>  3   207.   194.   215. TRUE     FALSE    FALSE                    0 #>  4   209.   198.   219. FALSE    FALSE    FALSE                    0 #>  5   214.   200.   221. FALSE    FALSE    FALSE                    0 #>  6   214.   203.   225. FALSE    FALSE    FALSE                    0 #>  7   211.   209.   223. FALSE    FALSE    FALSE                    0 #>  8   210.   212.   222. TRUE     FALSE    FALSE                    1 #>  9   204.   218.   214. FALSE    FALSE    FALSE                    1 #> 10   213.   183.   206. FALSE    FALSE    FALSE                    0 #> # ℹ 80 more rows #> # ℹ 3 more variables: solution_1_zone_2 <dbl>, solution_1_zone_3 <dbl>, #> #   geom <POLYGON [m]>  # calculate feature representation in the solution r4 <- eval_feature_representation_summary(   p4, s4[, c(\"solution_1_zone_1\", \"solution_1_zone_2\", \"solution_1_zone_3\")] ) print(r4) #> # A tibble: 20 × 5 #>    summary feature   total_amount absolute_held relative_held #>    <chr>   <chr>            <dbl>         <dbl>         <dbl> #>  1 overall feature_1        225.          37.5          0.166 #>  2 overall feature_2         83.9         14.6          0.174 #>  3 overall feature_3        195.          34.0          0.174 #>  4 overall feature_4        114.          18.4          0.161 #>  5 overall feature_5        154.          25.1          0.163 #>  6 zone_1  feature_1         75.1         12.8          0.170 #>  7 zone_1  feature_2         28.0          4.63         0.165 #>  8 zone_1  feature_3         65.0         10.6          0.163 #>  9 zone_1  feature_4         38.0          6.29         0.165 #> 10 zone_1  feature_5         51.2          8.88         0.174 #> 11 zone_2  feature_1         75.1         11.0          0.146 #> 12 zone_2  feature_2         28.0          5.26         0.188 #> 13 zone_2  feature_3         65.0         10.7          0.165 #> 14 zone_2  feature_4         38.0          6.49         0.171 #> 15 zone_2  feature_5         51.2          7.27         0.142 #> 16 zone_3  feature_1         75.1         13.7          0.182 #> 17 zone_3  feature_2         28.0          4.75         0.170 #> 18 zone_3  feature_3         65.0         12.7          0.195 #> 19 zone_3  feature_4         38.0          5.62         0.148 #> 20 zone_3  feature_5         51.2          8.93         0.175  # create new column representing the zone id that each planning unit # was allocated to in the solution s4$solution <- category_vector(   s4[, c(\"solution_1_zone_1\", \"solution_1_zone_2\", \"solution_1_zone_3\")] ) s4$solution <- factor(s4$solution)  # plot solution plot(s4[, \"solution\"])  # }"},{"path":"https://prioritizr.net/reference/solvers.html","id":null,"dir":"Reference","previous_headings":"","what":"Add solvers — solvers","title":"Add solvers — solvers","text":"Specify software configuration used solve conservation planning problem. default, best available software currently installed system used. information performance different solvers, please see Schuster et al. (2020) benchmarks comparing run time solution quality solvers applied different sized datasets.","code":""},{"path":"https://prioritizr.net/reference/solvers.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add solvers — solvers","text":"following solvers can used find solutions conservation planning problem(): add_default_solver() solver uses best software currently installed system. add_gurobi_solver() Gurobi state---art commercial optimization software R package interface. recommend using solver possible. far fastest solvers available generating prioritizations, however, freely available. said, licenses available academics cost. gurobi package distributed Gurobi software suite. solver uses gurobi package solve problems. add_cplex_solver() IBM CPLEX commercial optimization software. faster open source solvers available generating prioritizations, however, freely available. Similar Gurobi software, licenses available academics cost. solver uses cplexAPI package solve problems using IBM CPLEX. add_cbc_solver() CBC open-source mixed integer programming solver part Computational Infrastructure Operations Research (COIN-) project. Preliminary benchmarks indicate fastest open source solver currently supported. recommend using solver Gurobi IBM CPLEX unavailable. requires rcbc package, currently available GitHub. add_highs_solver() HiGHS open source optimization software. Although solver can comparable performance CBC solver particular problems generally faster SYMPHONY based solvers (see ), sometimes can take much longer CBC solver particular problems. add_lpsymphony_solver() SYMPHONY open-source mixed integer programming solver also part COIN-project. Although SYMPHONY CBC part COIN-project, different software. lpsymphony package provides interface SYMPHONY software, distributed Bioconductor. recommend using solver CBC HiGHS solvers installed. solver can use parallel processing solve problems, faster Rsymphony package interface (see ). add_rsymphony_solver() solver provides alternative interface SYMPHONY solver using Rsymphony package. Unlike solvers, Rsymphony package can installed directly Comprehensive R Archive Network (CRAN). also slowest available solvers.","code":""},{"path":"https://prioritizr.net/reference/solvers.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Add solvers — solvers","text":"Schuster R, Hanson JO, Strimas-Mackey M, Bennett JR (2020). Exact integer linear programming solvers outperform simulated annealing solving conservation planning problems. PeerJ, 8: e9258.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/solvers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add solvers — solvers","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features()  # create basic problem p <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_proportion_decisions()  # create vector to store plot names n <- c()  # create empty list to store solutions s <- c()  # if gurobi is installed: create problem with added gurobi solver if (require(\"gurobi\")) {   p1 <- p %>% add_gurobi_solver(verbose = FALSE)   n <- c(n, \"gurobi\")   s <- c(s, solve(p1)) } #> Loading required package: gurobi #> Loading required package: slam  # if cplexAPI is installed: create problem with added CPLEX solver if (require(\"cplexAPI\")) {   p2 <- p %>% add_cplex_solver(verbose = FALSE)   n <- c(n, \"CPLEX\")   s <- c(s, solve(p2)) } #> Loading required package: cplexAPI  # if rcbc is installed: create problem with added CBC solver if (require(\"rcbc\")) {   p3 <- p %>% add_cbc_solver(verbose = FALSE)   n <- c(n, \"CBC\")   s <- c(s, solve(p3)) } #> Loading required package: rcbc  # if highs is installed: create problem with added HiGHs solver if (require(\"highs\")) {   p4 <- p %>% add_highs_solver(verbose = FALSE)   n <- c(n, \"HiGHS\")   s <- c(s, solve(p4)) } #> Loading required package: highs  # create problem with added rsymphony solver if (require(\"Rsymphony\")) {   p5 <- p %>% add_rsymphony_solver(verbose = FALSE)   n <- c(n, \"Rsymphony\")   s <- c(s, solve(p5)) } #> Loading required package: Rsymphony  # if lpsymphony is installed: create problem with added lpsymphony solver if (require(\"lpsymphony\")) {   p6 <- p %>% add_lpsymphony_solver(verbose = FALSE)   n <- c(n, \"lpsymphony\")   s <- c(s, solve(p6)) } #> Loading required package: lpsymphony  # plot solutions names(s) <- n plot(terra::rast(s), axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/summaries.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate solutions using summary statistics — summaries","title":"Evaluate solutions using summary statistics — summaries","text":"generating solution conservation planning problem, can useful evaluate well performs. functions can used evaluate solution according various different summary statistics.","code":""},{"path":"https://prioritizr.net/reference/summaries.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Evaluate solutions using summary statistics — summaries","text":"following functions can used summarize performance solution conservation planning problem(): eval_n_summary() Calculate number planning units selected within solution. eval_cost_summary() Calculate total cost solution. eval_feature_representation_summary() Calculate well features represented solution. function can used problems. eval_target_coverage_summary() Calculate well feature representation targets met solution. function can used problems contain targets. eval_boundary_summary() Calculate exposed boundary length (perimeter) associated solution. eval_connectivity_summary() Calculate connectivity held within solution using symmetric data. eval_asym_connectivity_summary() Calculate connectivity held within solution using asymmetric data.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/summaries.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate solutions using summary statistics — summaries","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features()  # create a minimal problem p <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # solve problem s <- solve(p)  # evaluate number of selected planning units in solution eval_n_summary(p, s) #> # A tibble: 1 × 2 #>   summary     n #>   <chr>   <dbl> #> 1 overall    10  # evaluate solution cost eval_cost_summary(p, s) #> # A tibble: 1 × 2 #>   summary  cost #>   <chr>   <dbl> #> 1 overall 1987.  # evaluate feature representation by solution eval_feature_representation_summary(p, s) #> # A tibble: 5 × 5 #>   summary feature   total_amount absolute_held relative_held #>   <chr>   <chr>            <dbl>         <dbl>         <dbl> #> 1 overall feature_1         83.3          8.91         0.107 #> 2 overall feature_2         31.2          3.13         0.100 #> 3 overall feature_3         72.0          7.34         0.102 #> 4 overall feature_4         42.7          4.35         0.102 #> 5 overall feature_5         56.7          6.01         0.106  # evaluate target coverage by solution eval_target_coverage_summary(p, s) #> # A tibble: 5 × 9 #>   feature   met   total_amount absolute_target absolute_held absolute_shortfall #>   <chr>     <lgl>        <dbl>           <dbl>         <dbl>              <dbl> #> 1 feature_1 TRUE          83.3            8.33          8.91                  0 #> 2 feature_2 TRUE          31.2            3.12          3.13                  0 #> 3 feature_3 TRUE          72.0            7.20          7.34                  0 #> 4 feature_4 TRUE          42.7            4.27          4.35                  0 #> 5 feature_5 TRUE          56.7            5.67          6.01                  0 #> # ℹ 3 more variables: relative_target <dbl>, relative_held <dbl>, #> #   relative_shortfall <dbl>  # evaluate exposed boundary (perimeter) length by solution eval_boundary_summary(p, s) #> # A tibble: 1 × 2 #>   summary boundary #>   <chr>      <dbl> #> 1 overall     2.25  # create a symmetric connectivity matrix to describe pair-wise connectivity # values between combinations of planning units, # see ?connectivity_matrix for more information  # for brevity, we will do this using the cost data # cost valuers have high connectivity between them cm <- connectivity_matrix(sim_pu_raster, sim_pu_raster)  # evaluate connectivity of solution using symmetric data eval_connectivity_summary(p, s, data = cm) #> # A tibble: 1 × 2 #>   summary connectivity #>   <chr>          <dbl> #> 1 overall         198.  # create an asymmetric connectivity matrix to describe pair-wise # connectivity values between combinations of planning units  # for brevity, we will just generate a matrix with random values acm <- matrix(   runif(ncell(sim_pu_raster) ^ 2),   ncol = terra::ncell(sim_pu_raster) )  # evaluate connectivity of solution using asymmetric data eval_asym_connectivity_summary(p, s, data = acm) #> # A tibble: 1 × 2 #>   summary asym_connectivity #>   <chr>               <dbl> #> 1 overall              46.9  # }"},{"path":"https://prioritizr.net/reference/targets.html","id":null,"dir":"Reference","previous_headings":"","what":"Add representation targets — targets","title":"Add representation targets — targets","text":"Targets used specify minimum amount proportion feature's distribution (ideally) covered (represented) solution.","code":""},{"path":"https://prioritizr.net/reference/targets.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add representation targets — targets","text":"Please note objectives require targets, attempting solve problem requires targets throw error. following functions can used specify targets conservation planning problem(): add_relative_targets() Set targets proportion (0 1) total amount feature study area. add_absolute_targets() Set targets denote minimum amount feature required prioritization. add_loglinear_targets() Set targets proportion (0 1) calculated using log-linear interpolation. add_manual_targets() Set targets manually.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/targets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add representation targets — targets","text":"","code":"# \\dontrun{ # load data sim_pu_raster <- get_sim_pu_raster() sim_features <- get_sim_features()  # create base problem p <-   problem(sim_pu_raster, sim_features) %>%   add_min_set_objective() %>%   add_binary_decisions() %>%   add_default_solver(verbose = FALSE)  # create problem with added relative targets p1 <- p %>% add_relative_targets(0.1)  # create problem with added absolute targets p2 <- p %>% add_absolute_targets(3)  # create problem with added loglinear targets p3 <- p %>% add_loglinear_targets(10, 0.9, 100, 0.2)  # create problem with manual targets that equate to 10% relative targets targs <- data.frame(   feature = names(sim_features),   target = 0.1,   type = \"relative\" )  p4 <- p %>% add_manual_targets(targs)  # solve problem s <- c(solve(p1), solve(p2), solve(p3), solve(p4)) names(s) <- c(   \"relative targets\", \"absolute targets\", \"loglinear targets\",   \"manual targets\" ) # plot solution plot(s, axes = FALSE)  # }"},{"path":"https://prioritizr.net/reference/tibble-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Manipulate tibbles — tibble-methods","title":"Manipulate tibbles — tibble-methods","text":"Assorted functions manipulating tibble::tibble() objects.","code":""},{"path":"https://prioritizr.net/reference/tibble-methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Manipulate tibbles — tibble-methods","text":"","code":"# S4 method for tbl_df nrow(x)  # S4 method for tbl_df ncol(x)  # S4 method for tbl_df as.list(x)"},{"path":"https://prioritizr.net/reference/tibble-methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Manipulate tibbles — tibble-methods","text":"x tibble::tibble() object.","code":""},{"path":"https://prioritizr.net/reference/tibble-methods.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Manipulate tibbles — tibble-methods","text":"following methods provided manipulating tibble::tibble() objects. nrow integer number rows. ncol integer number columns. .list convert list. print print object.","code":""},{"path":"https://prioritizr.net/reference/tibble-methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Manipulate tibbles — tibble-methods","text":"","code":"# load tibble package require(tibble) #> Loading required package: tibble  # make tibble a <- tibble(value = seq_len(5))  # number of rows nrow(a) #> [1] 5  # number of columns ncol(a) #> [1] 1  # convert to list as.list(a) #> $value #> [1] 1 2 3 4 5 #>"},{"path":"https://prioritizr.net/reference/write_problem.html","id":null,"dir":"Reference","previous_headings":"","what":"Write problem — write_problem","title":"Write problem — write_problem","text":"Save mathematical formulation conservation planning problem file mixed integer programming solvers. Note function requires Rsymphony package installed.","code":""},{"path":"https://prioritizr.net/reference/write_problem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write problem — write_problem","text":"","code":"write_problem(x, path)"},{"path":"https://prioritizr.net/reference/write_problem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write problem — write_problem","text":"x problem() object. path character file path save problem formulation. argument contain \".lp\" .mps\" file extension specify whether problem formulation saved LP MPS format (respectively).","code":""},{"path":"https://prioritizr.net/reference/write_problem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write problem — write_problem","text":"invisible TRUE indicating success.","code":""},{"path":"https://prioritizr.net/reference/write_problem.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Write problem — write_problem","text":"","code":"# \\dontrun{ # set seed for reproducibility set.seed(500)  # load data sim_pu_polygons <- get_sim_pu_polygons() sim_features <- get_sim_features()  # subset data to extract first four planning units sim_pu_polygons <- sim_pu_polygons[1:4, ]  # create minimal problem p <-   problem(sim_pu_polygons, sim_features, cost_column = \"cost\") %>%   add_min_set_objective() %>%   add_relative_targets(0.1) %>%   add_binary_decisions()  # specify file path to save problem formulation path <- file.path(tempdir(), \"model.lp\") print(path) #> [1] \"/tmp/Rtmp0f5E3g/model.lp\"  # save problem to file ## note that the Rsymphony package needs to be installed write_problem(p, path)  # print model file cat(readLines(path), sep = \"\\n\") #> \\Problem name:  #>  #> Minimize #> obj: 215.863839903 x0 + 212.782348080 x1 + 207.496243710 x2 + 208.932169949 x3 #> Subject To #> cons0:  -0.277834862 x0 -0.277834862 x1 -0.277834862 x2 -0.277834862 x3 <= -0.277834862 #> cons1:  -0.127301294 x0 -0.127301294 x1 -0.127301294 x2 -0.127301294 x3 <= -0.127301294 #> cons2:  -0.316365081 x0 -0.316365081 x1 -0.316365081 x2 -0.316365081 x3 <= -0.316365081 #> cons3:  -0.121097955 x0 -0.121097955 x1 -0.121097955 x2 -0.121097955 x3 <= -0.121097955 #> cons4:  -0.176466230 x0 -0.176466230 x1 -0.176466230 x2 -0.176466230 x3 <= -0.176466230 #> Bounds #>  0 <= x0 <= 1 #>  0 <= x1 <= 1 #>  0 <= x2 <= 1 #>  0 <= x3 <= 1 #> Integers #> x0 x1 x2 x3  #> End # }"},{"path":"https://prioritizr.net/reference/zone_names.html","id":null,"dir":"Reference","previous_headings":"","what":"Zone names — zone_names","title":"Zone names — zone_names","text":"Extract names zones object.","code":""},{"path":"https://prioritizr.net/reference/zone_names.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Zone names — zone_names","text":"","code":"zone_names(x, ...)  # S3 method for ConservationProblem zone_names(x, ...)  # S3 method for ZonesRaster zone_names(x, ...)  # S3 method for ZonesSpatRaster zone_names(x, ...)  # S3 method for ZonesCharacter zone_names(x, ...)"},{"path":"https://prioritizr.net/reference/zone_names.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Zone names — zone_names","text":"x problem() zones() object. ... used.","code":""},{"path":"https://prioritizr.net/reference/zone_names.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Zone names — zone_names","text":"character vector zone names.","code":""},{"path":"https://prioritizr.net/reference/zone_names.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Zone names — zone_names","text":"","code":"# \\dontrun{ # load data sim_zones_pu_raster <- get_sim_zones_pu_raster() sim_zones_features <- get_sim_zones_features()  # print names of zones in a Zones object print(zone_names(sim_zones_features)) #> [1] \"zone_1\" \"zone_2\" \"zone_3\" # create problem with multiple zones p <-   problem(sim_zones_pu_raster, sim_zones_features) %>%   add_min_set_objective() %>%   add_relative_targets(matrix(0.2, ncol = 3, nrow = 5)) %>%   add_binary_decisions()  # print zone names in problem print(zone_names(p)) #> [1] \"zone_1\" \"zone_2\" \"zone_3\" # }"},{"path":"https://prioritizr.net/reference/zones.html","id":null,"dir":"Reference","previous_headings":"","what":"Management zones — zones","title":"Management zones — zones","text":"Organize data multiple features multiple management zones. Specifically, data describe expected amount feature within planning unit given management zone. example, data describe occupancy (e.g., presence/absence), probability occurrence, abundance expected feature planning unit allocated different zone.","code":""},{"path":"https://prioritizr.net/reference/zones.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Management zones — zones","text":"","code":"zones(..., zone_names = NULL, feature_names = NULL)"},{"path":"https://prioritizr.net/reference/zones.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Management zones — zones","text":"... terra::rast() character objects pertain biodiversity data. See Details information. zone_names character names management zones. Defaults NULL results sequential integers. feature_names character names features zones. Defaults NULL results sequential integers.","code":""},{"path":"https://prioritizr.net/reference/zones.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Management zones — zones","text":"Zones object containing data zone, feature zone names.","code":""},{"path":"https://prioritizr.net/reference/zones.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Management zones — zones","text":"function used store organize data use conservation planning problem() multiple management zones. cases, data zone input separate argument. correct arguments depends type planning unit data used building conservation planning problem(). problem() terra::rast() sf::st_sf() planning units terra::rast() object can supplied specify expected amount feature within planning unit management zone. Data zone specified separate arguments, data feature given zone specified separate layers terra::rast() object. Note layers given zone must missing (NA) values exactly cells. problem() sf::st_sf() data.frame planning units character vector containing column names can supplied specify expected amount feature zone. Note columns must contain missing (NA) values. problem() sf::st_sf(), data.frame, matrix planning units data.frame object can supplied specify expected amount feature zone. Following conventions used Marxan, data.frame object contain following columns. pu integer planning unit identifier. species integer feature identifier. amount numeric amount feature planning unit given zone. Note data zone specified separate argument, data contained single data.frame object correspond single zone. Also, note data required combinations planning units, features, zones. expected amount features planning units management zones missing table assumed zero.","code":""},{"path":[]},{"path":"https://prioritizr.net/reference/zones.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Management zones — zones","text":"","code":"# \\dontrun{ # load planning unit data sim_pu_raster <- get_sim_pu_raster()  zone_1 <- simulate_species(sim_pu_raster, 3) zone_2 <- simulate_species(sim_pu_raster, 3)  # create zones using two SpatRaster objects # each object corresponds to a different zone and each layer corresponds to # a different species z <- zones(   zone_1, zone_2,   zone_names = c(\"zone_1\", \"zone_2\"),   feature_names = c(\"feature_1\", \"feature_2\", \"feature_3\") ) print(z) #> A zones object <ZonesSpatRaster/Zones> #> • zones:    \"zone_1\" and \"zone_2\" (2 total) #> • features: \"feature_1\", \"feature_2\", and \"feature_3\" (3 total)  # plot the rasters for the first zone in the Zones object plot(  z[[1]],  main = c(\"Zone 1 feature 1\", \"Zone 1 feature 2\", \"Zone 1 feature 3\") )   # note that the do.call function can also be used to create a Zones object # this method for creating a Zones object can be helpful when there are many # management zones l <- list(   zone_1, zone_2,   zone_names = c(\"zone_1\", \"zone_2\"),   feature_names = c(\"feature_1\", \"feature_2\", \"feature_3\") ) z <- do.call(zones, l) print(z) #> A zones object <ZonesSpatRaster/Zones> #> • zones:    \"zone_1\" and \"zone_2\" (2 total) #> • features: \"feature_1\", \"feature_2\", and \"feature_3\" (3 total)  # create zones using character vectors corresponding to column names # of a data.frame or Spatial object that contain the amount # of each species expected different management zones z <- zones(   c(\"spp1_zone1\", \"spp2_zone1\"),   c(\"spp1_zone2\", \"spp2_zone2\"),   c(\"spp1_zone3\", \"spp2_zone3\"),   zone_names = c(\"zone1\", \"zone2\", \"zone3\"),   feature_names = c(\"spp1\", \"spp2\") ) print(z) #> A zones object <ZonesCharacter/Zones> #> • zones:    \"zone1\", \"zone2\", and \"zone3\" (3 total) #> • features: \"spp1\" and \"spp2\" (2 total) # }"},{"path":[]},{"path":"https://prioritizr.net/news/index.html","id":"notice-8-0-2-7","dir":"Changelog","previous_headings":"","what":"Notice","title":"prioritizr 8.0.2.7","text":"developed better approach rescaling boundary data avoid numerical issues optimization (#297). Earlier versions package recommended use scales::rescale() rescale data. However, now realize approach can produce inconsistencies boundary length data (e.g., total perimeter planning unit might necessarily equal sum edge lengths). cases, inconsistencies can cause solutions generated high boundary penalties (.e., using add_boundary_penalties() high penalty value) contain large reserve (.e., spatial cluster selected planning units) single unselected planning unit middle reserve. worst case, inconsistencies produce situation increasing boundary penalties (.e., generating multiple solutions add_boundary_penalties() increasing penalty values) alter spatial configuration solutions. Although use scales::rescale() produce behavior prior version 8.0.0, changes output format boundary_matrix() subsequent versions now mean scales::rescale() can cause issues. now recommend using new rescale_matrix() function rescale boundary length data avoid numerical issues, whilst also avoid inconsistencies.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"new-features-8-0-2-7","dir":"Changelog","previous_headings":"","what":"New features","title":"prioritizr 8.0.2.7","text":"New rescale_matrix() function help rescaling boundary length (e.g., generated using boundary_matrix()) connectivity (e.g., generated using connectivity_matrix()) data avoid numerical issues optimization (#297).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"minor-improvements-and-bug-fixes-8-0-2-7","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"prioritizr 8.0.2.7","text":"Update examples vignettes use rescale_matrix() function instead scales::rescale() function rescaling boundary length connectivity data (#297). Update print() summary() methods problem() objects now better describe situations planning cost data contain constant value (e.g., costs equal 1). Update publication record.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-8026","dir":"Changelog","previous_headings":"","what":"prioritizr 8.0.2.6","title":"prioritizr 8.0.2.6","text":"Update add_neighbors_constraints() additional clamp argument minimum number neighbors permitted planning unit solution clamped number neighbors planning unit . example, planning unit 2 neighbors, k = 3, clamp = FALSE, planning unit ever selected solution. However, clamp = TRUE, planning unit potentially selected solution 2 neighbors also selected. Fix issue problem() prevents features supplied data.frame contains feature names stored factor (#295). Fix broken URLs documentation.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-8025","dir":"Changelog","previous_headings":"","what":"prioritizr 8.0.2.5","title":"prioritizr 8.0.2.5","text":"Update problem() throw meaningful error message user accidentally specifies geometry column sf planning unit data feature.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-8024","dir":"Changelog","previous_headings":"","what":"prioritizr 8.0.2.4","title":"prioritizr 8.0.2.4","text":"Fix compatibility updates terra package. Fix rij_matrix() works none raster layers processed fit memory (#290). Fix spatial extent built-raster datasets extents 0 1 (.e., get_sim_pu_raster(), get_sim_locked_in_raster(), get_sim_locked_out_raster(), get_sim_zones_pu_raster(), get_sim_features(), get_sim_zones_features()). Update add_manual_locked_constraints() add_manual_bounded_constraints() indices specified argument data$pu consistently refer total units. words, indices data$pu refer row numbers (planning units sf data.frame format) cell numbers (planning units Raster SpatRaster format) planning units locked. Fix warnings thrown due package version comparisons. Update publication record.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-8023","dir":"Changelog","previous_headings":"","what":"prioritizr 8.0.2.3","title":"prioritizr 8.0.2.3","text":"Export solve.ConservationProblem() can called directly (#283). Update publication record.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-8022","dir":"Changelog","previous_headings":"","what":"prioritizr 8.0.2.2","title":"prioritizr 8.0.2.2","text":"Update publication record. Fix compatibility highs package (version 0.1-10) (#281).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-8021","dir":"Changelog","previous_headings":"","what":"prioritizr 8.0.2.1","title":"prioritizr 8.0.2.1","text":"Update problem() error thrown argument features contains missing (NA) values (e.g., sf object supplied NA values rows feature’s column). Update publication record.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-802","dir":"Changelog","previous_headings":"","what":"prioritizr 8.0.2","title":"prioritizr 8.0.2","text":"CRAN release: 2023-05-01","code":""},{"path":"https://prioritizr.net/news/index.html","id":"notice-8-0-2","dir":"Changelog","previous_headings":"","what":"Notice","title":"prioritizr 8.0.2","text":"package updated focus using sf terra package spatial vector raster datasets. sf package successor sp package, terra package successor raster package. leveraging newer packages, prioritizr package can provide better performance. Although sp raster package classes (e.g., raster::stack() sp::SpatialPolyonsDataFrame()) still supported, prioritizr package now throw deprecation warnings. Since support sp raster package classes fully deprecated removed later version year, recommend updating code use sf terra packages.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"breaking-changes-8-0-2","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"prioritizr 8.0.2","text":"proto classes migrated R6 classes. update reduces memory usage (#238), problem() objects can now contain many constraints penalties. Note problem() objects produced using earlier versions package longer compatible. proto, raster, sf, sp packages longer automatically loaded alongside prioritizr. , users need load manually (e.g., using library(sf)). built-datasets removed replaced functions import needed (.e., get_sim_pu_raster(), get_sim_pu_polygons(), get_sim_pu_lines(), get_sim_pu_points(),, get_sim_locked_in_raster(), get_sim_locked_out_raster(), get_sim_zones_pu_raster(), get_sim_zones_pu_polygons(), get_sim_phylogeny(), get_sim_features(), get_sim_zones_features()). functions now return sf::st_sf(), terra::rast(), ape::read.tree() zones() objects. Note functions provided data(...) used terra::rast() objects. See ?data information. boundary_matrix() output format updated. means users able use boundary data generated using previous versions package. add_lpsymphony_solver() now throws error, instead warning, old version lpsymphony R package installed known produce incorrect results. marxan_boundary_data_to_matrix() function longer compatible boundary data multiple zones. distribute_load() function deprecated, longer used. equivalent functionality, See parallel::splitIndices(). new_optimization_problem() predefined_optimization_problem() functions superseded new optimization_problem() function. simplify package documentation functionality, following functions longer exported: .Waiver(), add_default_decisions() new_id(), .Id(), print.Id(), pproto().","code":""},{"path":"https://prioritizr.net/news/index.html","id":"new-features-8-0-2","dir":"Changelog","previous_headings":"","what":"New features","title":"prioritizr 8.0.2","text":"print() function problem(), optimization_problem(), zones() objects updated provide information. New summary() function provide extensive detail problem() objects. Updates improve error messages error message handling. Hopefully, users longer see \"bad error message\"!","code":""},{"path":"https://prioritizr.net/news/index.html","id":"minor-improvements-and-bug-fixes-8-0-2","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"prioritizr 8.0.2","text":"Fix bug add_feature_weights() applied problems add_max_phylo_div_objective() add_max_phylo_end_objectve(). Specifically, bug meant weights weren’t applied problems particular objectives. Fix instructions add_gurobi_solver() documentation opening vignette. Update solver functions provide instructions installing dependencies error messages dependencies available. ensure consistency among portfolio functions, (except add_extra_portfolio()) default generating 10 solutions. Update publication record. solve() function now output tibble::tibble() objects (instead data.frame() objects), planning unit data tibble::tibble() objects. boundary_matrix() function now uses terra::sharedPaths() calculations, providing greater performance (#257). eval_ferrier_importance() function can now used objective function uses targets single zone. Fix CRAN note regarding C++ standards (#263). Remove doParallel plyr packages dependencies simplifying add_shuffle_portfolio() eval_replacement_importance() functions. Assorted tweaks improve writing vignettes documentation. Many thanks Marc Edwards (@edwardsmarc)!","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-801","dir":"Changelog","previous_headings":"","what":"prioritizr 8.0.1","title":"prioritizr 8.0.1","text":"Assorted bug fixes.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-800","dir":"Changelog","previous_headings":"","what":"prioritizr 8.0.0","title":"prioritizr 8.0.0","text":"CRAN release: 2023-03-29 version contains incorrect version code, due mistake preparing CRAN release. strongly recommend upgrading version 8.0.1 ensure correct results. apologize inconvenience might caused.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7227","dir":"Changelog","previous_headings":"","what":"prioritizr 7.2.2.7","title":"prioritizr 7.2.2.7","text":"Update README badges. Update publication record.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7226","dir":"Changelog","previous_headings":"","what":"prioritizr 7.2.2.6","title":"prioritizr 7.2.2.6","text":"Update publication record.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7225","dir":"Changelog","previous_headings":"","what":"prioritizr 7.2.2.5","title":"prioritizr 7.2.2.5","text":"Update publication record.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7224","dir":"Changelog","previous_headings":"","what":"prioritizr 7.2.2.4","title":"prioritizr 7.2.2.4","text":"Specify minimum version Matrix package dependency (#255).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7223","dir":"Changelog","previous_headings":"","what":"prioritizr 7.2.2.3","title":"prioritizr 7.2.2.3","text":"New add_highs_solver() function HiGHS optimization software (#250). Update add_default_solver() use HiGHS solver Gurobi, IBM CPLEX, CBC solvers aren’t available. Fix add_default_solver() add_lpsymphony_solver() used instead add_rsymphony_solver().","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7222","dir":"Changelog","previous_headings":"","what":"prioritizr 7.2.2.2","title":"prioritizr 7.2.2.2","text":"Update problem() eval_feature_representation_summary() avoid needlessly converting sparse matrices regular matrices (#252). Fix broken URLs documentation.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7221","dir":"Changelog","previous_headings":"","what":"prioritizr 7.2.2.1","title":"prioritizr 7.2.2.1","text":"Fix mistake NEWS.md. Update publication record.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-722","dir":"Changelog","previous_headings":"","what":"prioritizr 7.2.2","title":"prioritizr 7.2.2","text":"CRAN release: 2022-09-17 Release candidate CRAN. Fix compiler warnings. Update tests skip long-running tests CRAN. Update examples minimize overall package check timings CRAN.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-721","dir":"Changelog","previous_headings":"","what":"prioritizr 7.2.1","title":"prioritizr 7.2.1","text":"Release candidate CRAN (rejected due package check timings).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7209","dir":"Changelog","previous_headings":"","what":"prioritizr 7.2.0.9","title":"prioritizr 7.2.0.9","text":"Fix compatibility upcoming Matrix package version (version 1.5-0). Update package documentation provide details obtaining installing cplexAPI package since archived CRAN (#214). Fix bug caused add_cbc_solver() throw segfault solving problem wherein rij_matrix(x) zero amount last feature last planning unit (#247). Update simulate_data(), simulate_cost() simulate_species() functions improve performance using fields package. Update boundary_matrix() use STR query trees default. Remove maptools, PBSmapping, rgeos packages dependencies. involved updating unit tests hard-code correct results, updating examples use sf package, updating boundary_matrix() use geos package (#218). Fix broken URLs package documentation.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7208","dir":"Changelog","previous_headings":"","what":"prioritizr 7.2.0.8","title":"prioritizr 7.2.0.8","text":"Update simulate_cost() simulate_species() longer depend RandomFields package.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7207","dir":"Changelog","previous_headings":"","what":"prioritizr 7.2.0.7","title":"prioritizr 7.2.0.7","text":"Update publication record.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7206","dir":"Changelog","previous_headings":"","what":"prioritizr 7.2.0.6","title":"prioritizr 7.2.0.6","text":"Update publication record.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7205","dir":"Changelog","previous_headings":"","what":"prioritizr 7.2.0.5","title":"prioritizr 7.2.0.5","text":"Update publication record.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7204","dir":"Changelog","previous_headings":"","what":"prioritizr 7.2.0.4","title":"prioritizr 7.2.0.4","text":"Fix broken URLs documentation.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7203","dir":"Changelog","previous_headings":"","what":"prioritizr 7.2.0.3","title":"prioritizr 7.2.0.3","text":"Update presolve_check() function () reduce chances incorrectly throwing error input data won’t actually cause issues, (ii) provide recommendations addressing issues. Update documentation add_min_largest_shortfall_objective() examples complete shorter period time.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7202","dir":"Changelog","previous_headings":"","what":"prioritizr 7.2.0.2","title":"prioritizr 7.2.0.2","text":"Fix bug processing planning unit data problem constructed using arguments () x numeric matrix format, (ii) x contain missing (NA) values, (iii) rij_matrix dgCMatrix format. bug occurred three specific conditions met. occurred, bug caused planning units NA cost values receive high cost values (e.g., 1e+300). bug meant attempting solve problem, presolve checks (per presolve_check()) throw error complaining high cost values (#236).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7201","dir":"Changelog","previous_headings":"","what":"prioritizr 7.2.0.1","title":"prioritizr 7.2.0.1","text":"Update publication record.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7200","dir":"Changelog","previous_headings":"","what":"prioritizr 7.2.0.0","title":"prioritizr 7.2.0.0","text":"Fix add_locked_in_constraints() add_locked_out_constraints() ensure meaningful error message provided planing units locked (#234). Fix presolve_check() throw meaningless warning mathematical objective function contains zeros. Update presolve_check() help reduce chances mis-attributing high connectivity/boundary values due planning unit costs. Update add_connectivity_penalties() function documentation designed specifically symmetric connectivity data. New add_asym_connectivity_penalties() function designed specifically asymmetric connectivity data. function created help ensure asymmetric connectivity data handled correctly. instance, using asymmetric connectivity data add_connectivity_penalties() function previous versions package sometimes resulted data incorrectly treated symmetric data. Additionally, function uses updated mathematical formulation handling asymmetric connectivity provides similar results Marxan software (#323). Update marxan_problem() function can used asymmetric connectivity data. now possible dedicated functions symmetric asymmetric connectivity. Update publication record. Update URLs publication record pass CRAN checks.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-71112","dir":"Changelog","previous_headings":"","what":"prioritizr 7.1.1.12","title":"prioritizr 7.1.1.12","text":"Update publication record.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-71111","dir":"Changelog","previous_headings":"","what":"prioritizr 7.1.1.11","title":"prioritizr 7.1.1.11","text":"Update publication record.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-71110","dir":"Changelog","previous_headings":"","what":"prioritizr 7.1.1.10","title":"prioritizr 7.1.1.10","text":"Fix broken links documentation. Update publication vignette. Improve documentation zones parameter add_connectivity_penalties() function.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7119","dir":"Changelog","previous_headings":"","what":"prioritizr 7.1.1.9","title":"prioritizr 7.1.1.9","text":"Update documentation eval_ferrier_importance() (#220). Although function now recommended general use, documentation contained outdated warning warning now removed.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7118","dir":"Changelog","previous_headings":"","what":"prioritizr 7.1.1.8","title":"prioritizr 7.1.1.8","text":"Update publication record. Fix bug eval_n_summary() function now returns table column name \"n\" (instead \"cost\") number selected planning units (#219). Update reference index package website. Fix minor typos vignettes.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7117","dir":"Changelog","previous_headings":"","what":"prioritizr 7.1.1.7","title":"prioritizr 7.1.1.7","text":"Minimum version numbers now provided R package dependencies (excepting base R packages) (#217). data.table package now listed suggested (optional) dependency. used marxan_problem() importing Marxan data files.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7116","dir":"Changelog","previous_headings":"","what":"prioritizr 7.1.1.6","title":"prioritizr 7.1.1.6","text":"Update publication record.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7115","dir":"Changelog","previous_headings":"","what":"prioritizr 7.1.1.5","title":"prioritizr 7.1.1.5","text":"Tasmania tutorial reworked Getting started tutorial. tutorial now provides short introduction using package. Salt Spring Island tutorial reworked Connectivity tutorial. tutorial now explores different approaches incorporating connectivity. prioritizr vignette renamed Package overview vignette. New Calibrating trade-offs tutorial showcasing methods running calibration analyses. outlines blended hierarchical approaches generating set different prioritizations based different parameters. also covers different approaches selecting candidate prioritization based different trade-offs.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7114","dir":"Changelog","previous_headings":"","what":"prioritizr 7.1.1.4","title":"prioritizr 7.1.1.4","text":"Update tests reduce run time pass given slightly different results new Gurobi version (9.5.0). Update built-sim_pu_sf sim_pu_zones_sf data given class updates sf package (compatible version 1.0.3+). Update example write_problem() function.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7113","dir":"Changelog","previous_headings":"","what":"prioritizr 7.1.1.3","title":"prioritizr 7.1.1.3","text":"Update publication record.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7112","dir":"Changelog","previous_headings":"","what":"prioritizr 7.1.1.2","title":"prioritizr 7.1.1.2","text":"Update publication record.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7111","dir":"Changelog","previous_headings":"","what":"prioritizr 7.1.1.1","title":"prioritizr 7.1.1.1","text":"Fix URL vignette.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-711","dir":"Changelog","previous_headings":"","what":"prioritizr 7.1.1","title":"prioritizr 7.1.1","text":"CRAN release: 2021-10-29 Release candidate CRAN.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7104","dir":"Changelog","previous_headings":"","what":"prioritizr 7.1.0.4","title":"prioritizr 7.1.0.4","text":"Update eval_ferrier_importance() function verified code. Update documentation information Ferrier importance scores. Brandon Edwards added package author list. Update Gurobi Installation guide vignette. Update benchmark vignette. Update presolve_check() function throw warning really high values specified add_neighbor_constraints().","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7103","dir":"Changelog","previous_headings":"","what":"prioritizr 7.1.0.3","title":"prioritizr 7.1.0.3","text":"Update add_cbc_solver() function can use starting solution reduce run time (via start_solution parameter).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7102","dir":"Changelog","previous_headings":"","what":"prioritizr 7.1.0.2","title":"prioritizr 7.1.0.2","text":"Fix examples fail package checks. Remove xtable R package Suggests longer used.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7101","dir":"Changelog","previous_headings":"","what":"prioritizr 7.1.0.1","title":"prioritizr 7.1.0.1","text":"Update publication vignette.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7100","dir":"Changelog","previous_headings":"","what":"prioritizr 7.1.0.0","title":"prioritizr 7.1.0.0","text":"New add_linear_constraint() function add arbitrary constraints. Update add_min_shortfall_objective() add_min_largest_shortfall_objective() functions handle targets target threshold value zero. Minor improvements documentation. include moving mathematical details dedicated sections, providing links See also sections, fixing text formatting eval_connectivity_summary() function, tweaking header README. Update publication vignette.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7015","dir":"Changelog","previous_headings":"","what":"prioritizr 7.0.1.5","title":"prioritizr 7.0.1.5","text":"Update publication vignette.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7014","dir":"Changelog","previous_headings":"","what":"prioritizr 7.0.1.4","title":"prioritizr 7.0.1.4","text":"Update documentation examples problem() function. Update publication vignette.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7013","dir":"Changelog","previous_headings":"","what":"prioritizr 7.0.1.3","title":"prioritizr 7.0.1.3","text":"New solver benchmark vignette.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7012","dir":"Changelog","previous_headings":"","what":"prioritizr 7.0.1.2","title":"prioritizr 7.0.1.2","text":"Update add_gurobi_solver() function doesn’t print excess debugging information (accidentally introduced previous version 7.0.1.1).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7011","dir":"Changelog","previous_headings":"","what":"prioritizr 7.0.1.1","title":"prioritizr 7.0.1.1","text":"Update add_gurobi_solver() function support node_file_start parameter Gurobi software. functionality useful solving large problems systems limited memory (#139).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-701","dir":"Changelog","previous_headings":"","what":"prioritizr 7.0.1","title":"prioritizr 7.0.1","text":"CRAN release: 2021-03-31 Release candidate CRAN. Update DESCRIPTION information package usage. Update DESCRIPTION details rcbc R package installation.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7008","dir":"Changelog","previous_headings":"","what":"prioritizr 7.0.0.8","title":"prioritizr 7.0.0.8","text":"New write_problem() function save mixed integer programming representation conservation planning problem file. function useful manually executing optimization solvers.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7007","dir":"Changelog","previous_headings":"","what":"prioritizr 7.0.0.7","title":"prioritizr 7.0.0.7","text":"Fix typo rij_matrix() function documentation (#189). Update publication vignette.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7006","dir":"Changelog","previous_headings":"","what":"prioritizr 7.0.0.6","title":"prioritizr 7.0.0.6","text":"Update add_gurobi_solver() function allow specification starting solution (#187). functionality useful conducting boundary penalty parameter calibration exercise. Specifically, users can specify starting solution given penalty value based solution obtained using smaller penalty value. Bug fix: solve now assigns layer names based zone names solutions format.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7005","dir":"Changelog","previous_headings":"","what":"prioritizr 7.0.0.5","title":"prioritizr 7.0.0.5","text":"Update methods calculating solver runtime.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7004","dir":"Changelog","previous_headings":"","what":"prioritizr 7.0.0.4","title":"prioritizr 7.0.0.4","text":"Update publication record. Bug fix: time_limit verbose parameters add_cbc_solver() now work expected.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7003","dir":"Changelog","previous_headings":"","what":"prioritizr 7.0.0.3","title":"prioritizr 7.0.0.3","text":"Update add_gurobi_solver() function report timings following methods solvers.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7002","dir":"Changelog","previous_headings":"","what":"prioritizr 7.0.0.2","title":"prioritizr 7.0.0.2","text":"Update add_lpsymphony_solver() function memory efficient (#183). Added slam R package dependencies enable memory efficient usage lpsymphony R package (#183).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7001","dir":"Changelog","previous_headings":"","what":"prioritizr 7.0.0.1","title":"prioritizr 7.0.0.1","text":"Update unit tests solve greater proportion using continuous integration services (#181). Bug fix: add_cbc_solver() now preferred open source solvers. Bug fix: add_cbc_solver() sometimes return incorrect solutions problems equality constraints.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-7000","dir":"Changelog","previous_headings":"","what":"prioritizr 7.0.0.0","title":"prioritizr 7.0.0.0","text":"Remove unused shiny R package integration dependencies (#141).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-6002","dir":"Changelog","previous_headings":"","what":"prioritizr 6.0.0.2","title":"prioritizr 6.0.0.2","text":"New add_cbc_solver() function generate solutions using open source CBC solver via rcbc R package (https://github.com/dirkschumacher/rcbc). Update add_rsymphony_solver() add_lpsymphony_solver() functions default time_limit argument set maximum machine integer consistency. Update add_rsymphony_solver(), add_lpsymphony_solver(), add_gurobi_solver() functions require logical (TRUE/FALSE) arguments first_feasible parameter. Update documentation solvers provide detailed information. Update publication record. Update add_default_solver() function prefers add_lpsymphony_solver() add_rsymphony_solver(), add_cbc_solver() open source solvers. Bug fix: previous versions package reported gap parameter add_rsymphony_solver() add_lpsymphony_solver() corresponded maximum absolute difference optimal objective value. error due misunderstanding SYMPHONY documentation. previous versions package, gap parameter actually corresponded relative optimality gap expressed percentage (thatgap = 10 indicates solutions must least 10% optimality). now fixed error documentation described gap parameter correct. apologize inconvenience may caused.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-6001","dir":"Changelog","previous_headings":"","what":"prioritizr 6.0.0.1","title":"prioritizr 6.0.0.1","text":"Update Solution format section documentation evaluation functions (.e. functions starting eval_) mention argument solution contain columns correspond solution (#176). Add examples using sf data documentation importance evaluation functions (#176). Add helpful error messages invalid solution arguments supplied evaluation functions (#176). Add functionality calculate importance scores using Ferrier method sf planning unit data. Fix broken link add_manual_targets() documentation. Fix typo equation rarity weighted richness documentation. New add_min_largest_shortfall() objective function.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-6000","dir":"Changelog","previous_headings":"","what":"prioritizr 6.0.0.0","title":"prioritizr 6.0.0.0","text":"New eval_cost() function calculate cost solution. New eval_boundary() function calculate exposed boundary length associated solution. New eval_connectivity() function calculate connectivity associated solution. Deprecated feature_representation() function. now superseded eval_feature_representation() function. New eval_feature_representation() function assess well feature represented solution. function similar deprecated eval_feature_representation() function, except follows conventions evaluation functions (e.g. eval_cost). New eval_target_representation() function assess well target met solution. function similar eval_feature_representation(), except corresponds targets conservation planning problem. Rename ferrier_score function eval_ferrier_importance() function consistency. Rename replacement_cost function eval_replacement_importance() function consistency. Rename rarity_weighted_richness function eval_rare_richness_importance() function consistency. Fix comparability issues Matrix package (version 1.3-0) (#172). Add NEWS build process (#173). Update publication vignette.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-5032","dir":"Changelog","previous_headings":"","what":"prioritizr 5.0.3.2","title":"prioritizr 5.0.3.2","text":"Add Schuster et al. 2020 documentation provide information solver benchmarks (#170).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-5031","dir":"Changelog","previous_headings":"","what":"prioritizr 5.0.3.1","title":"prioritizr 5.0.3.1","text":"Fix add_locked_out_constraints() function enable single planning unit locked multiple zones (data specified raster format).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-503","dir":"Changelog","previous_headings":"","what":"prioritizr 5.0.3","title":"prioritizr 5.0.3","text":"CRAN release: 2020-11-24 Release candidate CRAN.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-5027","dir":"Changelog","previous_headings":"","what":"prioritizr 5.0.2.7","title":"prioritizr 5.0.2.7","text":"Update publication record vignette. Fix URLs CRAN checks.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-5026","dir":"Changelog","previous_headings":"","what":"prioritizr 5.0.2.6","title":"prioritizr 5.0.2.6","text":"Implement GitHub Actions continuous integration (.e. update tests README). Update problem() function reduce memory consumption sparse matrix arguments (#164). Update Tasmania vignette remove superfluous warnings (#168). Update publication record vignette. Fix compatibility issues testthat R package gurobi R package package tests.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-5025","dir":"Changelog","previous_headings":"","what":"prioritizr 5.0.2.5","title":"prioritizr 5.0.2.5","text":"New add_cplex_solver() function generate solutions using IBM CPLEX (via cplexAPI package).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-5024","dir":"Changelog","previous_headings":"","what":"prioritizr 5.0.2.4","title":"prioritizr 5.0.2.4","text":"Update publication record vignette. Update add_gap_portfolio() documentation note works problems binary decisions (#159). Fix target calculations add_loglinear_targets() loglinear_interpolation() functions. Previously used natural logarithm log-linear interpolation. follow target setting approaches outlined Rodrigues et al. (2004), now use decadic logarithm (.e. log10()).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-5023","dir":"Changelog","previous_headings":"","what":"prioritizr 5.0.2.3","title":"prioritizr 5.0.2.3","text":"Update publication record vignette.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-5022","dir":"Changelog","previous_headings":"","what":"prioritizr 5.0.2.2","title":"prioritizr 5.0.2.2","text":"Update publication record vignette.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-5021","dir":"Changelog","previous_headings":"","what":"prioritizr 5.0.2.1","title":"prioritizr 5.0.2.1","text":"Update documentation ferrier_score() function. longer incorrectly states scores can calculated using CLUZ now states functionality experimental formulation can double checked.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-502","dir":"Changelog","previous_headings":"","what":"prioritizr 5.0.2","title":"prioritizr 5.0.2","text":"CRAN release: 2020-07-30 Release candidate CRAN.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-5017","dir":"Changelog","previous_headings":"","what":"prioritizr 5.0.1.7","title":"prioritizr 5.0.1.7","text":"Fix tests updated datasets prioritizrdata R package. Fix small typos documentation. Update citation Scriven et al. (2020) Publication Record vignette. Update Salt Spring Island vignette Ferrier method calculating irreplaceability scores adjust changes cost data. Update examples run CRAN checks (.e. --run-donttest).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-5016","dir":"Changelog","previous_headings":"","what":"prioritizr 5.0.1.6","title":"prioritizr 5.0.1.6","text":"Fix feature_representation() bug incorrectly throwing error vector planning unit data (e.g. sf-class data).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-5015","dir":"Changelog","previous_headings":"","what":"prioritizr 5.0.1.5","title":"prioritizr 5.0.1.5","text":"Fix typo causing rij_matrix() throw error large raster data (#151). Fix “Non-file package-anchored link(s) documentation object” warnings R-devel checks.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-5014","dir":"Changelog","previous_headings":"","what":"prioritizr 5.0.1.4","title":"prioritizr 5.0.1.4","text":"New add_linear_penalties() add penalties penalize planning units according linear metric. Update connectivity_matrix() documentation provide example generate connectivity matrices account functional connectivity. Add information documentation solve() function. Add links documentation solve() function Salt Spring Island Tasmania vignettes.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-5013","dir":"Changelog","previous_headings":"","what":"prioritizr 5.0.1.3","title":"prioritizr 5.0.1.3","text":"Update compile() throw warning compiling problems include feature weights objective function use feature weights.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-5012","dir":"Changelog","previous_headings":"","what":"prioritizr 5.0.1.2","title":"prioritizr 5.0.1.2","text":"Add Schuster et al. (2020) publication record. Update Hanson et al. (2020) publication record. Update Flower et al. (2020) publication record.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-5011","dir":"Changelog","previous_headings":"","what":"prioritizr 5.0.1.1","title":"prioritizr 5.0.1.1","text":"Update add_gurobi_solver() function provide options controlling pre-solve step solving problem.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-501","dir":"Changelog","previous_headings":"","what":"prioritizr 5.0.1","title":"prioritizr 5.0.1","text":"CRAN release: 2020-05-15 Release candidate CRAN.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-5001","dir":"Changelog","previous_headings":"","what":"prioritizr 5.0.0.1","title":"prioritizr 5.0.0.1","text":"New ferrier_score() function compute irreplaceability scores following Ferrier et al (2000).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-5000","dir":"Changelog","previous_headings":"","what":"prioritizr 5.0.0.0","title":"prioritizr 5.0.0.0","text":"Add full support sf package (#6). Add Flower et al. (2020), Hanson et al. (2020), Visalli et al. (2020) publication record (#131). New proximity_matrix() function generate matrices indicating planning units within certain distance (#6). Rename connected_matrix() function adjacency_matrix() function follow naming conventions spatial association functions (#6). New add_extra_portfolio(), add_top_portfolio(), add_gap_portfolio() functions provide specific options generating portfolios (#134). Enhance intersecting_units fast_extract functions use exactextractr fasterize packages speed raster data extraction (#130). Fix compatibility issues upcoming version tibble (3.0.0). Fix bug boundary_matrix() function handling SpatialPolygon planning unit data contain multiple polygons (e.g. single planning unit contains two separate islands) (#132). Remove velox package dependency since may archived CRAN (#130). Deprecate set_number_of_threads(), get_number_of_threads(), .parallel() functions since longer used new data extraction methods. Deprecate add_pool_portfolio() function new add_extra_portfolio() add_top_portfolio() functions provide functionality (#134). Built-datasets now saved latest workspace version (.e. version 3).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4152","dir":"Changelog","previous_headings":"","what":"prioritizr 4.1.5.2","title":"prioritizr 4.1.5.2","text":"Fix bug add_rsymphony_solve()r add_lpsymphony_solver() throwing infeasible error message feasible problems containing continuous semi-continuous variables.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4151","dir":"Changelog","previous_headings":"","what":"prioritizr 4.1.5.1","title":"prioritizr 4.1.5.1","text":"Add Lin et al. (press) publication record.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-415","dir":"Changelog","previous_headings":"","what":"prioritizr 4.1.5","title":"prioritizr 4.1.5","text":"CRAN release: 2020-02-06 Release candidate CRAN.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4144","dir":"Changelog","previous_headings":"","what":"prioritizr 4.1.4.4","title":"prioritizr 4.1.4.4","text":"Fix warnings R-devel CRAN checks related documentation.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4143","dir":"Changelog","previous_headings":"","what":"prioritizr 4.1.4.3","title":"prioritizr 4.1.4.3","text":"Add Williams et al. (press) publication record.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4142","dir":"Changelog","previous_headings":"","what":"prioritizr 4.1.4.2","title":"prioritizr 4.1.4.2","text":"Add Rodewald et al. (2019) publication record. Update press version Rodewald et al. (2019). Make error message presolve_check() function informative (#124).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4141","dir":"Changelog","previous_headings":"","what":"prioritizr 4.1.4.1","title":"prioritizr 4.1.4.1","text":"Add Scriven et al. (press) publication record.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-414","dir":"Changelog","previous_headings":"","what":"prioritizr 4.1.4","title":"prioritizr 4.1.4","text":"CRAN release: 2019-10-03 Release candidate CRAN.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4133","dir":"Changelog","previous_headings":"","what":"prioritizr 4.1.3.3","title":"prioritizr 4.1.3.3","text":"Fix rij_matrix() amounts calculated correctly vector-based planning unit data. Fix documentation fast_extract().","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4132","dir":"Changelog","previous_headings":"","what":"prioritizr 4.1.3.2","title":"prioritizr 4.1.3.2","text":"Add Rodewald et al. (press) publication record. Update reference Bombi et al. (2019) publication record.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4131","dir":"Changelog","previous_headings":"","what":"prioritizr 4.1.3.1","title":"prioritizr 4.1.3.1","text":"Fix typo README.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-413","dir":"Changelog","previous_headings":"","what":"prioritizr 4.1.3","title":"prioritizr 4.1.3","text":"CRAN release: 2019-09-06 Release candidate CRAN.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4128","dir":"Changelog","previous_headings":"","what":"prioritizr 4.1.2.8","title":"prioritizr 4.1.2.8","text":"Update add_locked_in_constraints() add_locked_out_constraints() functions longer throw unnecessary warning added multi-zone problems using raster data NA values. Update documentation add_locked_in_constraints() add_locked_out_constraints() functions provide recommended practices raster data. Update documentation constraints missing “See also” “Value” sections.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4127","dir":"Changelog","previous_headings":"","what":"prioritizr 4.1.2.7","title":"prioritizr 4.1.2.7","text":"Fix issue rarity_weighted_richness() returning incorrect scores feature data contains one feature zeros amounts planning units (e.g. tas_features object prioritizrdata R package; #120). Fix issue add_gurobi_solver() returning solution statuses slightly larger one (e.g. 1+1.0e-10) solving problems proportion-type decisions (#118).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4126","dir":"Changelog","previous_headings":"","what":"prioritizr 4.1.2.6","title":"prioritizr 4.1.2.6","text":"Update replacement_cost() function use parallel processing speed calculations (#119). New add_manual_bounded_constraints() function apply lower upper bounds planning units statuses solution (#118).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4125","dir":"Changelog","previous_headings":"","what":"prioritizr 4.1.2.5","title":"prioritizr 4.1.2.5","text":"Update add_gurobi_solver(), add_lpsymphony_solver(), add_rsymphony_solver() functions return solutions values less zero greater one solving problems proportion-type decisions. issue result inconsistent precision performing floating point arithmetic (#117). Update add_locked_in_constraints() add_locked_out_constraints() functions provide helpful error message locked_in/locked_out argument refers column data logical (.e. TRUE/FALSE; #118).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4124","dir":"Changelog","previous_headings":"","what":"prioritizr 4.1.2.4","title":"prioritizr 4.1.2.4","text":"Update solve() function throw accurate helpful error message solutions found (e.g. due problem infeasibility solver time limits). Standardize error messages none end full stop.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4123","dir":"Changelog","previous_headings":"","what":"prioritizr 4.1.2.3","title":"prioritizr 4.1.2.3","text":"Rename add_max_phylo_objective() function add_max_phylo_div_objective(). New add_max_phylo_end_objective() function maximize phylogenetic endemism species adequately represented prioritization (#113). Add add_max_phylo_end_objective(), replacement_cost(), rarity_weighted_richness() functions Prioritizr vignette. Update simulated phylogeny dataset (sim_phylogeny). Update examples add_max_phylo_div_objective() function. Prettify equations documentation objective functions.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4122","dir":"Changelog","previous_headings":"","what":"prioritizr 4.1.2.2","title":"prioritizr 4.1.2.2","text":"New irreplaceability manual entry document functions calculating irreproducibility scores. New replacement_cost() function calculate irreproducibility scores planning unit solution using replacement cost method (#26). New rarity_weighted_richness() function calculate irreproducibility scores planning unit solution using rarity weighted richness scores (#26). Updated Salt Spring Island vignette section calculating interpreting irreplaceability scores.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4121","dir":"Changelog","previous_headings":"","what":"prioritizr 4.1.2.1","title":"prioritizr 4.1.2.1","text":"Fix typo. Fix broken links Gurobi academic licenses. Fix compiler warnings thrown package installation. Skip tests CRAN’s Windows system reduce CRAN check times. Skip plotting data examples testing reduce CRAN check times. Throw warning message prioritizr _oppr_packages loaded time.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-412","dir":"Changelog","previous_headings":"","what":"prioritizr 4.1.2","title":"prioritizr 4.1.2","text":"Release candidate CRAN (rejected).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4112","dir":"Changelog","previous_headings":"","what":"prioritizr 4.1.1.2","title":"prioritizr 4.1.1.2","text":"Fix example throwing error CRAN checks.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4111","dir":"Changelog","previous_headings":"","what":"prioritizr 4.1.1.1","title":"prioritizr 4.1.1.1","text":"Add Bombi et al. (press) publication record.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4110","dir":"Changelog","previous_headings":"","what":"prioritizr 4.1.1.0","title":"prioritizr 4.1.1.0","text":"Fix broken link main vignette.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-411","dir":"Changelog","previous_headings":"","what":"prioritizr 4.1.1","title":"prioritizr 4.1.1","text":"CRAN release: 2019-06-06 Release candidate CRAN.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4101","dir":"Changelog","previous_headings":"","what":"prioritizr 4.1.0.1","title":"prioritizr 4.1.0.1","text":"New add_min_shortfall_objective() function find solutions minimize target shortfalls. Add new add_min_shortfall_objective() function main vignette. Fix problem() tests work solvers installed.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4100","dir":"Changelog","previous_headings":"","what":"prioritizr 4.1.0.0","title":"prioritizr 4.1.0.0","text":"feature_representation() function now requires missing (NA) values planning unit statuses solution planning units missing (NA) cost data.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4041","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.4.1","title":"prioritizr 4.0.4.1","text":"New presolve_check() function investigate potential sources numerical instability trying solve problem. manual entry function discusses common sources numerical instability approaches fixing . solve() function now use presolve_check() function verify problems obvious sources numerical instability trying solve . problem likely numerical instability issues function now throw error (unless solve(x, force = TRUE)). add_rsymphony_solver() function now uses sparse matrix formats attempts can made solve large problems SYMPHONY—though unlikely SYMPHONY able solve problems feasible period time. Fix warnings thrown tibble R package calling tibble::.tibble() instead tibble::as_tibble(). Add example calculating feature representation solution tabular format output solve() (#110). Fix several typos documentation. Thrown warnings now immediately visible. Update references publication record vignette. Specify English (US) DESCRIPTION file.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-404","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.4","title":"prioritizr 4.0.4","text":"CRAN release: 2019-04-12 Release candidate CRAN.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4031","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.3.1","title":"prioritizr 4.0.3.1","text":"Retain debugging symbols conform CRAN policies.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-403","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.3","title":"prioritizr 4.0.3","text":"CRAN release: 2019-04-08 Release candidate CRAN.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-40216","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.2.16","title":"prioritizr 4.0.2.16","text":"Add new citations.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-40215","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.2.15","title":"prioritizr 4.0.2.15","text":"Fix typos documentation add_boundary_penalties() add_connectivity_penalties() function (#106).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-40214","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.2.14","title":"prioritizr 4.0.2.14","text":"Fix bug use add_rsymphony_solver() add_lpsymphony_solver() sometimes returned infeasible solutions subjected time limit (#105).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-40213","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.2.13","title":"prioritizr 4.0.2.13","text":"Fix assorted bugs render, setter, getter parameter functions ConservationProblem-class objects. methods implemented used future interactive applications currently used package. consequence, bugs affect correctness results.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-40212","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.2.12","title":"prioritizr 4.0.2.12","text":"Fix bad error message error thrown input rasters comparable (.e. coordinate reference system, extent, resolutions, dimensionality) (#104). Add Domisch et al. (2019) publication record vignette.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-40211","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.2.11","title":"prioritizr 4.0.2.11","text":"Fix issue solve() printing annoying text tbl_df (#75).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-40210","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.2.10","title":"prioritizr 4.0.2.10","text":"Tweak add_max_features_objective() example code.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4029","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.2.9","title":"prioritizr 4.0.2.9","text":"Update publication record vignette.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4028","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.2.8","title":"prioritizr 4.0.2.8","text":"Fix bug add_neighbor_constraints() add_contiguity_constraints() functions used memory actually needed (#102). argument validation code converted sparse matrix objects (.e. dgCMatrix) base objects (.e. matrix) class temporarily. bug meant inefficient utilization computer resources—affect correctness results.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4027","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.2.7","title":"prioritizr 4.0.2.7","text":"New add_mandatory_allocation_constraints() function. function can used ensure every planning unit allocated management zone solution. useful developing land-use plans every single parcel land must assigned specific land-use zone. Add add_mandatory_allocation_constraints() Management Zones Prioritizr vignettes. Fix bug $find(x) method Collection prototypes caused throw error incorrectly. method used earlier versions package.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4026","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.2.6","title":"prioritizr 4.0.2.6","text":"Fix bug feature_representation() function caused “amount_held” column NA values instead correct values. bug affected problems multiple zones.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4025","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.2.5","title":"prioritizr 4.0.2.5","text":"Fix bug argument validation code category_layer() function function incorrectly throw error claiming input argument x invalid fact valid. bug encountered different layers argument x non-NA values different cells.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4024","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.2.4","title":"prioritizr 4.0.2.4","text":"Update instructions activating Gurobi licenses remote machines (#98).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4023","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.2.3","title":"prioritizr 4.0.2.3","text":"add_contiguity_constraints() function now uses sparse matrix formats internally single-zone problems. means constraints can applied single-zoned problem many planning units.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4022","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.2.2","title":"prioritizr 4.0.2.2","text":"add_connectivity_penalties() function now uses sparse matrix formats internally single-zone problems. means connectivity penalties can applied single-zoned problem many planning units.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4021","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.2.1","title":"prioritizr 4.0.2.1","text":"Update warning text compiling problems contain () objective functions use targets (ii) targets (#93). Update documentation add_max_utility_objective() add_max_cover_objective() functions make clearer use targets (#94).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-402","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.2","title":"prioritizr 4.0.2","text":"CRAN release: 2018-06-28 Release candidate CRAN.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4016","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.1.6","title":"prioritizr 4.0.1.6","text":"Fix bug add_locked_in_constraints() add_locked_out_constraints() incorrectly threw error using logical locked data (.e. TRUE/FALSE) incorrectly thought valid inputs invalid. Fix bug add_locked_in_constraints(), add_locked_out_constraints(), add_manual_locked_constraints() solving problem object twice resulted incorrect planning units locked solution (#92). Added unit tests objectives, constraints, decisions, targets, penalties ensure solving problems twice result different solutions.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4015","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.1.5","title":"prioritizr 4.0.1.5","text":"Fix bug feature_abundances() caused solve function throw error attempting solve problems single feature. Fix bug add_cuts_portfolio() caused portfolio return solutions within specified optimality gap using Gurobi solver. Add ability specify search pool method number solutions add_pool_portfolio() function.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4014","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.1.4","title":"prioritizr 4.0.1.4","text":"feature_representation() function now allows numeric solutions attributes (e.g. output solve() function) calculating representation statistics problems numeric planning unit data (#91). add_manual_targets() function threw warning features targets equal zero. resulted excessive amount warnings. Now, warnings thrown targets less zero. problem() function sometimes incorrectly threw warning feature data negative values data actually contain negative values. now addressed.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4013","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.1.3","title":"prioritizr 4.0.1.3","text":"problem function now allows negative values cost feature data (throws warning data detected). add_absolute_targets() add_manual_targets() functions now allow negative targets (throw warning targets specified). compile function throws error problem compiled using expanded formulation negative feature data. add_absolute_targets() function now throws warning—instead error—specified targets greater feature abundances planning units accommodate negative values feature data.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4012","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.1.2","title":"prioritizr 4.0.1.2","text":"Fix add_max_cover_objective() prioritizr vignette (#90).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4011","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.1.1","title":"prioritizr 4.0.1.1","text":"add_relative_targets() documentation now makes clear locked planning units included calculations setting targets (#89). add_loglinear_targets() function now includes feature_abundances() parameter specifying total amount feature use calculating targets (#89).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-401","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.1","title":"prioritizr 4.0.1","text":"CRAN release: 2018-05-26 Release candidate CRAN.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-40012","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.0.12","title":"prioritizr 4.0.0.12","text":"New feature_abundances() function calculate total amount feature planning units (#86).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-40011","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.0.11","title":"prioritizr 4.0.0.11","text":"Fix equations documentation (#83).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-40010","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.0.10","title":"prioritizr 4.0.0.10","text":"Add version requirements assertthat tibble packages (#82).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4009","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.0.9","title":"prioritizr 4.0.0.9","text":"Fix minor typos Gurobi installation guide update Management zones tutorial.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4008","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.0.8","title":"prioritizr 4.0.0.8","text":"Add instructions setting Gurobi Academic license computer connected university computer network using computer academic network (#81). example, instructions used set Gurobi cloud-based system using laptop computer connected university’s wireless network.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4007","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.0.7","title":"prioritizr 4.0.0.7","text":"add_cuts_portfolio() function uses Gurobi solution pool generate unique solutions within specified gap optimality tasked solving problems Gurobi (version 8.0.0+; #80).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4006","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.0.6","title":"prioritizr 4.0.0.6","text":"New add_pool_portfolio() function generate portfolio solutions using Gurobi solution pool (#77).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4005","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.0.5","title":"prioritizr 4.0.0.5","text":"boundary_matrix() function now experimental functionality use GEOS STR trees speed processing (#74). Solutions obtained Gurobi contain binary-type decisions explicitly rounded nearest integer. Gurobi can output solutions binary problems contain values exactly zero one (e.g. 0.9999997 using default settings; #78).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4004","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.0.4","title":"prioritizr 4.0.0.4","text":"New feature_representation() function well features represented solutions (#73).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4003","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.0.3","title":"prioritizr 4.0.0.3","text":"prioritizrdata package listed Suggests. vignettes prioritizrdata package moved package make easier find.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4002","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.0.2","title":"prioritizr 4.0.0.2","text":"Fix issue solve() function printing superfluous text (#75).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4001","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.0.1","title":"prioritizr 4.0.0.1","text":"Minor improvements documentation problem() function.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-4000","dir":"Changelog","previous_headings":"","what":"prioritizr 4.0.0.0","title":"prioritizr 4.0.0.0","text":"Added functionality build solve problems multiple management zones (#14). New built-datasets sim_pu_zones_stack, sim_pu_zones_polygons, sim_features_zones exploring conservation problems multiple management zones. New zones function Zones class organize data multiple zones. problem() function now accepts Zone objects arguments feature create problems multiple zones. add_relative_targets() add_absolute_targets() functions adding targets problems can used specify targets feature zone. New add_manual_targets() function creating targets pertain multiple management zones. solve() function now returns list solutions generating portfolio solutions. add_locked_in_constraints() add_locked_out_constraints() functions specifying planning units locked now accept matrix arguments specifying zones locked . New add_manual_locked_constraints() function manually specify planning units shouldn’t allocated specific zones solutions. functions adding constraints penalties now parameters specify treat planning units allocate different zones (using zones parameter) specify applied (using data parameter. functions default arguments mean problems single zone optimal solution problems created earlier version package. add_feature_weights() function can used weight different representation feature zone. binary_stack(), category_layer(), category_vector() functions provided help work data multiple management zones. New Management zones vignette building solving problems multiple management zones. Added mention zones functionality package DESCRIPTION, summary (?prioritizr), README. Quick Start Guide Prioritizr Basics vignettes consolidated prioritizr vignette. marxan_problem() updated comprehensive documentation provide helpful error messages. clarity, now work tabular data standard Marxan format.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-3036","dir":"Changelog","previous_headings":"","what":"prioritizr 3.0.3.6","title":"prioritizr 3.0.3.6","text":"Fix typo README update documentation add_boundary_penalties() (#62).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-3035","dir":"Changelog","previous_headings":"","what":"prioritizr 3.0.3.5","title":"prioritizr 3.0.3.5","text":"Fix bug add_locked_in_constraints() add_locked_out_constraints() throw exception used semi-continuous-type decisions (#59). Exception compile() thrown planning unit locked locked now prints planning unit indices readable format.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-3034","dir":"Changelog","previous_headings":"","what":"prioritizr 3.0.3.4","title":"prioritizr 3.0.3.4","text":"Fix bug add_locked_in_constraints() add_locked_out_constraints() ignored using proportion-type decisions (#58).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-3033","dir":"Changelog","previous_headings":"","what":"prioritizr 3.0.3.3","title":"prioritizr 3.0.3.3","text":"Fix bug predefined_optimization_problem() incorrectly recognized inputs invalid fact valid. Addressed NOTE R CMD check related proto Depends.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-3032","dir":"Changelog","previous_headings":"","what":"prioritizr 3.0.3.2","title":"prioritizr 3.0.3.2","text":"Moved proto package Imports Depends DESCRIPTION","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-3031","dir":"Changelog","previous_headings":"","what":"prioritizr 3.0.3.1","title":"prioritizr 3.0.3.1","text":"Depends R version 3.4.0 (avoids ‘patchlevel 0’ NOTE/WARNING checks)","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-303","dir":"Changelog","previous_headings":"","what":"prioritizr 3.0.3","title":"prioritizr 3.0.3","text":"CRAN release: 2017-11-22 Release candidate CRAN.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-3023","dir":"Changelog","previous_headings":"","what":"prioritizr 3.0.2.3","title":"prioritizr 3.0.2.3","text":"Unit tests fail using lpsymphony due bug lpsymphony now skipped (partially addressing #40).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-3022","dir":"Changelog","previous_headings":"","what":"prioritizr 3.0.2.2","title":"prioritizr 3.0.2.2","text":"add_lpsymphony_solver() now throws warnings alert users potentially incorrect solutions (partially addressing #40).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-3021","dir":"Changelog","previous_headings":"","what":"prioritizr 3.0.2.1","title":"prioritizr 3.0.2.1","text":"Vignette sizes reduced.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-302","dir":"Changelog","previous_headings":"","what":"prioritizr 3.0.2","title":"prioritizr 3.0.2","text":"Release candidate CRAN. Release postponed due issues Travis CI.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-3011","dir":"Changelog","previous_headings":"","what":"prioritizr 3.0.1.1","title":"prioritizr 3.0.1.1","text":"Unit tests add_*_objectives now pass executed slow solvers (partially addressing #40). compile() now works solvers installed (#41). Gap arguments add_*_solvers now unbounded can accept values larger 1 (#44).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-301","dir":"Changelog","previous_headings":"","what":"prioritizr 3.0.1","title":"prioritizr 3.0.1","text":"CRAN release: 2017-11-08 Release candidate CRAN.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-3000","dir":"Changelog","previous_headings":"","what":"prioritizr 3.0.0.0","title":"prioritizr 3.0.0.0","text":"add_max_cover_objective() function renamed add_max_utility_objective(), formulation follow historical formulation maximum coverage reserve selection problem (#38). add_max_cover_objective() function now follows historical maximum coverage objective. fundamentally changes add_max_cover_objective() function breaks compatibility previous versions (#38). Update add_lpsymphony_solver() examples tests skip Linux operating systems. Add tests unit tests skipped new version testthat package.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-2041","dir":"Changelog","previous_headings":"","what":"prioritizr 2.0.4.1","title":"prioritizr 2.0.4.1","text":"Fix bug add_lpsymphony_solver() causing error attempting solve problems.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-204","dir":"Changelog","previous_headings":"","what":"prioritizr 2.0.4","title":"prioritizr 2.0.4","text":"Release candidate CRAN. Release postponed due bug report.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-2031","dir":"Changelog","previous_headings":"","what":"prioritizr 2.0.3.1","title":"prioritizr 2.0.3.1","text":"Fix bug solving problems numeric vector data caused error. Fix bug compiling problems numeric vector input rij data containing NA values. Added unit tests solving problems various input formats. Updated package sizes reported cran-comments.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-203","dir":"Changelog","previous_headings":"","what":"prioritizr 2.0.3","title":"prioritizr 2.0.3","text":"Initial release candidate CRAN. Release postponed due bug report.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-2029","dir":"Changelog","previous_headings":"","what":"prioritizr 2.0.2.9","title":"prioritizr 2.0.2.9","text":"Added vignette record publications use prioritizr (#35).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-2028","dir":"Changelog","previous_headings":"","what":"prioritizr 2.0.2.8","title":"prioritizr 2.0.2.8","text":"Unit tests now compatible development version testthat (#34).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-2027","dir":"Changelog","previous_headings":"","what":"prioritizr 2.0.2.7","title":"prioritizr 2.0.2.7","text":"Fix bug apply_boundary_penalties() add_connectivity_penalties() causing function throw error number boundaries/edges less number planning units.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-2026","dir":"Changelog","previous_headings":"","what":"prioritizr 2.0.2.6","title":"prioritizr 2.0.2.6","text":"Makevars now compatible Mac OSX Sierra (#33).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-2025","dir":"Changelog","previous_headings":"","what":"prioritizr 2.0.2.5","title":"prioritizr 2.0.2.5","text":"Fix bug boundary_matrix() calculations (#30).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-2024","dir":"Changelog","previous_headings":"","what":"prioritizr 2.0.2.4","title":"prioritizr 2.0.2.4","text":"Minor tweaks vignettes.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-2023","dir":"Changelog","previous_headings":"","what":"prioritizr 2.0.2.3","title":"prioritizr 2.0.2.3","text":"Add logo README files package website (#31).","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-2022","dir":"Changelog","previous_headings":"","what":"prioritizr 2.0.2.2","title":"prioritizr 2.0.2.2","text":"Broad-scale improvements documentation. Fix documentation add_max_phylo_objective() (#24). Update Gurobi Installation vignette. Remove prioritizrdata package Suggests. Add shiny xtable Suggests rendering parameters. Added code ScalarParameter ArrayParameter prototypes check t functions generating widgets dependencies installed. URLs lpsymphony Bioconductor now use package’s DOI. Add comprehensive tests portfolios. Fix bug numeric planning unit data portfolios caused solve() throw error. Remove R-devel AppVeyor testing fails unknown reasons.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-2021","dir":"Changelog","previous_headings":"","what":"prioritizr 2.0.2.1","title":"prioritizr 2.0.2.1","text":"Removed shiny functions now prep CRAN release. Rebuilt website documentation.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-2020","dir":"Changelog","previous_headings":"","what":"prioritizr 2.0.2.0","title":"prioritizr 2.0.2.0","text":"Included vignette Gurobi solver installation testing.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-2010","dir":"Changelog","previous_headings":"","what":"prioritizr 2.0.1.0","title":"prioritizr 2.0.1.0","text":"Fixed bug Spatial*DataFrame input marxan_problem() always use first column attribute table cost data. bug serious analysis used Spatial*DataFrame inputs marxan_problem() rerun. Added functionality use feature abundance/occurrence data stored columns planning unit data constructing problem() objects.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-2002","dir":"Changelog","previous_headings":"","what":"prioritizr 2.0.0.2","title":"prioritizr 2.0.0.2","text":"Skip add_cuts_portfolio() Travis.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-2001","dir":"Changelog","previous_headings":"","what":"prioritizr 2.0.0.1","title":"prioritizr 2.0.0.1","text":"Skip add_cuts_portfolio() add_shuffle_portfolio() tests CRAN.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-2000","dir":"Changelog","previous_headings":"","what":"prioritizr 2.0.0.0","title":"prioritizr 2.0.0.0","text":"version breaks compatibility previous releases solutions data.frame Spatial*DataFrame objects now stored columns named \"solution_*\" (e.g. “solution_1”) store multiple solutions. Added support multiple solutions (#23). Solutions now contain additional information stored object’s attributes (#24). See README.Rmd examples accessing information. Tidy examples add_gurobi_solver.R, add_lpsymphony_solver.R, add_rsymphony_solver.R, solvers.R. Add logical verbose argument solvers. replaces verbosity argument add_lpsymphony_solver() add_rsymphony_solver(). verbosity information presented solving problems using add_lpsymphony_solver() add_rsymphony_solver() reduced. Assorted spelling mistakes fixed.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-1023","dir":"Changelog","previous_headings":"","what":"prioritizr 1.0.2.3","title":"prioritizr 1.0.2.3","text":"ConservationProblem$print() now prints first three species names count total number features. update means ConservationProblem objects lots features can now safely printed without polluting R console. Attempt make equations help files prettier. Fix bug lpsymphony Rsymphony solvers return solutions containing NA values find feasible solution within argument time_limit.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-1022","dir":"Changelog","previous_headings":"","what":"prioritizr 1.0.2.2","title":"prioritizr 1.0.2.2","text":"Fix #19.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-1021","dir":"Changelog","previous_headings":"","what":"prioritizr 1.0.2.1","title":"prioritizr 1.0.2.1","text":"Fix #20.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-1020","dir":"Changelog","previous_headings":"","what":"prioritizr 1.0.2.0","title":"prioritizr 1.0.2.0","text":"Passes CRAN checks Winbuilder. Added roxygen2 Suggests Travis CI.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-1016","dir":"Changelog","previous_headings":"","what":"prioritizr 1.0.1.6","title":"prioritizr 1.0.1.6","text":"Simplify vignette workflow. Vignettes can now compiled using devtools::build_vignettes(). Earlier versions needed vignettes compiled using Makefile copy files around avoid tangled R code causing failures R CMD CHECK. Although longer needed, vignettes can still compiled using shell command make vigns desired. README.Rmd now lives top-level directory following standard practices. now complied using rmarkdown::render(\"README.Rmd\") using shell command make readme. Note figures README.md can found directory man/figures. example prshiny now run executed interactive R session. Prior R CMD CHECK hang. UTF-8 math characters vignettes replaced MathJax compatible latex expressions. R code vignettes linted follow package’s style guide. Fix example vignette quick_start.Rmd showing run marxan_problem() using input data.frame() objects. Fix bug vignette quick_start.Rmd counting number selected planning units Make data.table package automatically installed prioritizr installed (#18). Move shiny, shinydashboard, leaflet packages Imports avoid polluting users environment. Update preliminary versions shiny apps call functions packages explicitly. README.Rmd tweaks make look prettier website Lint objective function definition files Remove “” latex sequences objective function definition files CRAN doesn’t support amsmath extensions equations. Update examples objective function files show relevant objectives Added rmarkdown package Suggests following recommended practices.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-1015","dir":"Changelog","previous_headings":"","what":"prioritizr 1.0.1.5","title":"prioritizr 1.0.1.5","text":"Enable 64 bit Armadillo flag. increases maximum size problems can solved. Disable bound-checks Armadillo matrix operations. reduce processing time running compile() function.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-1014","dir":"Changelog","previous_headings":"","what":"prioritizr 1.0.1.4","title":"prioritizr 1.0.1.4","text":"Fix bug problem.data.frame meant check missing values rij$pu.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-1013","dir":"Changelog","previous_headings":"","what":"prioritizr 1.0.1.3","title":"prioritizr 1.0.1.3","text":"Fix bugs add_absolute_targets() add_relative_targets` related standardGeneric incorrectly defined Reduce installation size using Dirk Eddelbuettel’s awesome advice: http://dirk.eddelbuettel.com/blog/2017/08/14#009_compact_shared_libraries Fix bug add_corridor_targets() argument connectivities list. elements list assumed dsCMatrix objects (aka symmetric sparse matrices compressed format) coerced dgCMatrix objects reduce computational burden. typo, however, objects coerced dgCmatrix dgCMatrix. evidently ok earlier versions RcppArmadillo /Matrix packages recent versions.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-1012","dir":"Changelog","previous_headings":"","what":"prioritizr 1.0.1.2","title":"prioritizr 1.0.1.2","text":"Fix #21.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-1011","dir":"Changelog","previous_headings":"","what":"prioritizr 1.0.1.1","title":"prioritizr 1.0.1.1","text":"Add roxygen2 package SUGGESTS building vignettes.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-1010","dir":"Changelog","previous_headings":"","what":"prioritizr 1.0.1.0","title":"prioritizr 1.0.1.0","text":"Fix issue parallel::detectCores() returns NA systems preventing users using Gurobi solver–even one thread specified.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-1005","dir":"Changelog","previous_headings":"","what":"prioritizr 1.0.0.5","title":"prioritizr 1.0.0.5","text":"Fix building issue due incorrect file order DESCRIPTION.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-1004","dir":"Changelog","previous_headings":"","what":"prioritizr 1.0.0.4","title":"prioritizr 1.0.0.4","text":"Compatibility R 3.4.0. Replace structure(NULL, ...) structure(list(), ...). Register compiled library files. Remove duplicate definition new_waiver(). Tests check prioritizrdata package installed skip isn’t.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-1003","dir":"Changelog","previous_headings":"","what":"prioritizr 1.0.0.3","title":"prioritizr 1.0.0.3","text":"Fix missing links documentation Fix typos roxygen2 parameters Move add_default_decisions() add_default_solver() help file Make add_default_objectives() add_default_targets() private functions","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-1002","dir":"Changelog","previous_headings":"","what":"prioritizr 1.0.0.2","title":"prioritizr 1.0.0.2","text":"Fix #13","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-1001","dir":"Changelog","previous_headings":"","what":"prioritizr 1.0.0.1","title":"prioritizr 1.0.0.1","text":"Fix #8. Fix bug add_corridor_constraints() fails actually add constraints argument connectivity list. Fix bug make install command now actually installs package. Fix link Joe’s website package’s website.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-1000","dir":"Changelog","previous_headings":"","what":"prioritizr 1.0.0.0","title":"prioritizr 1.0.0.0","text":"R interface fully functional.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-0129","dir":"Changelog","previous_headings":"","what":"prioritizr 0.1.2.9","title":"prioritizr 0.1.2.9","text":"Package re-implementation.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-012","dir":"Changelog","previous_headings":"","what":"prioritizr 0.1.2","title":"prioritizr 0.1.2","text":"CRAN release: 2016-12-01 Prepare CRAN submission. Add continuous integration. Fixed various bugs. Introduce maximum target coverage model. Add full vignette addition quickstart guide.","code":""},{"path":"https://prioritizr.net/news/index.html","id":"prioritizr-011","dir":"Changelog","previous_headings":"","what":"prioritizr 0.1.1","title":"prioritizr 0.1.1","text":"Initial package version.","code":""}]
